// This file was autogenerated by cloop - Cross Language Object Oriented Programming

#ifndef IDL_FB_INTERFACES_H
#define IDL_FB_INTERFACES_H

#ifndef CLOOP_CARG
#define CLOOP_CARG
#endif


template <typename Policy>
class FirebirdApi
{
private:
	class DoNotInherit
	{
	};

	template <typename T>
	class Inherit : public T
	{
	public:
		Inherit(DoNotInherit = DoNotInherit())
			: T(DoNotInherit())
		{
		}
	};

public:
	// Forward interfaces declarations

	class Versioned;
	class ReferenceCounted;
	class Disposable;
	class Status;
	class Master;
	class PluginBase;
	class PluginSet;
	class ConfigEntry;
	class Config;
	class FirebirdConf;
	class PluginConfig;
	class PluginFactory;
	class PluginModule;
	class PluginManager;
	class ConfigManager;
	class EventCallback;
	class Blob;
	class Transaction;
	class MessageMetadata;
	class MetadataBuilder;
	class ResultSet;
	class Statement;
	class Request;
	class Events;
	class Attachment;
	class Service;
	class Provider;
	class DtcStart;
	class Dtc;
	class Auth;
	class Writer;
	class ServerBlock;
	class ClientBlock;
	class Server;
	class Client;
	class UserField;
	class CharUserField;
	class IntUserField;
	class User;
	class ListUsers;
	class LogonInfo;
	class Management;
	class WireCryptPlugin;
	class CryptKeyCallback;
	class KeyHolderPlugin;
	class DbCryptPlugin;
	class ExternalContext;
	class ExternalResultSet;
	class ExternalFunction;
	class ExternalProcedure;
	class ExternalTrigger;
	class RoutineMetadata;
	class ExternalEngine;
	class Timer;
	class TimerControl;
	class VersionCallback;
	class Utl;
	class TraceConnection;
	class TraceDatabaseConnection;
	class TraceTransaction;
	class TraceParams;
	class TraceStatement;
	class TraceSQLStatement;
	class TraceBLRStatement;
	class TraceDYNRequest;
	class TraceContextVariable;
	class TraceProcedure;
	class TraceFunction;
	class TraceTrigger;
	class TraceServiceConnection;
	class TraceStatusVector;
	class TraceSweepInfo;
	class TraceLogWriter;
	class TraceInitInfo;
	class TracePlugin;
	class TraceFactory;

	// Interfaces declarations

	class Versioned
	{
	public:
		struct VTable
		{
			void* cloopDummy[1];
			uintptr_t version;
			PluginModule* (CLOOP_CARG *getModule)(Versioned* self) throw();
		};

		void* cloopDummy[1];
		VTable* cloopVTable;

	protected:
		Versioned(DoNotInherit)
		{
		}

		~Versioned()
		{
		}

	public:
		static const unsigned VERSION = 1;

		PluginModule* getModule()
		{
			PluginModule* ret = static_cast<VTable*>(this->cloopVTable)->getModule(this);
			return ret;
		}
	};

	class ReferenceCounted : public Versioned
	{
	public:
		struct VTable : public Versioned::VTable
		{
			void (CLOOP_CARG *addRef)(ReferenceCounted* self) throw();
			int (CLOOP_CARG *release)(ReferenceCounted* self) throw();
		};

	protected:
		ReferenceCounted(DoNotInherit)
			: Versioned(DoNotInherit())
		{
		}

		~ReferenceCounted()
		{
		}

	public:
		static const unsigned VERSION = 2;

		void addRef()
		{
			static_cast<VTable*>(this->cloopVTable)->addRef(this);
		}

		int release()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->release(this);
			return ret;
		}
	};

	class Disposable : public Versioned
	{
	public:
		struct VTable : public Versioned::VTable
		{
			void (CLOOP_CARG *dispose)(Disposable* self) throw();
		};

	protected:
		Disposable(DoNotInherit)
			: Versioned(DoNotInherit())
		{
		}

		~Disposable()
		{
		}

	public:
		static const unsigned VERSION = 2;

		void dispose()
		{
			static_cast<VTable*>(this->cloopVTable)->dispose(this);
		}
	};

	class Status : public Disposable
	{
	public:
		struct VTable : public Disposable::VTable
		{
			void (CLOOP_CARG *init)(Status* self) throw();
			unsigned (CLOOP_CARG *getStatus)(const Status* self) throw();
			void (CLOOP_CARG *setErrors2)(Status* self, unsigned length, const intptr_t* value) throw();
			void (CLOOP_CARG *setWarnings2)(Status* self, unsigned length, const intptr_t* value) throw();
			void (CLOOP_CARG *setErrors)(Status* self, const intptr_t* value) throw();
			void (CLOOP_CARG *setWarnings)(Status* self, const intptr_t* value) throw();
			const intptr_t* (CLOOP_CARG *getErrors)(const Status* self) throw();
			const intptr_t* (CLOOP_CARG *getWarnings)(const Status* self) throw();
		};

	protected:
		Status(DoNotInherit)
			: Disposable(DoNotInherit())
		{
		}

		~Status()
		{
		}

	public:
		static const unsigned VERSION = 3;

		static const unsigned FB_HAS_WARNINGS = 1;
		static const unsigned FB_HAS_ERRORS = 2;
		static const int FB_ERROR = -1;
		static const int FB_OK = 0;
		static const int FB_EOF = 1;
		static const int FB_SEGMENT = 2;

		void init()
		{
			static_cast<VTable*>(this->cloopVTable)->init(this);
		}

		unsigned getStatus() const
		{
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getStatus(this);
			return ret;
		}

		void setErrors2(unsigned length, const intptr_t* value)
		{
			static_cast<VTable*>(this->cloopVTable)->setErrors2(this, length, value);
		}

		void setWarnings2(unsigned length, const intptr_t* value)
		{
			static_cast<VTable*>(this->cloopVTable)->setWarnings2(this, length, value);
		}

		void setErrors(const intptr_t* value)
		{
			static_cast<VTable*>(this->cloopVTable)->setErrors(this, value);
		}

		void setWarnings(const intptr_t* value)
		{
			static_cast<VTable*>(this->cloopVTable)->setWarnings(this, value);
		}

		const intptr_t* getErrors() const
		{
			const intptr_t* ret = static_cast<VTable*>(this->cloopVTable)->getErrors(this);
			return ret;
		}

		const intptr_t* getWarnings() const
		{
			const intptr_t* ret = static_cast<VTable*>(this->cloopVTable)->getWarnings(this);
			return ret;
		}
	};

	class Master : public Versioned
	{
	public:
		struct VTable : public Versioned::VTable
		{
			Status* (CLOOP_CARG *getStatus)(Master* self) throw();
			Provider* (CLOOP_CARG *getDispatcher)(Master* self) throw();
			PluginManager* (CLOOP_CARG *getPluginManager)(Master* self) throw();
			const char* (CLOOP_CARG *circularAlloc)(Master* self, const char* s, unsigned len, intptr_t thr) throw();
			TimerControl* (CLOOP_CARG *getTimerControl)(Master* self) throw();
			Dtc* (CLOOP_CARG *getDtc)(Master* self) throw();
			Attachment* (CLOOP_CARG *registerAttachment)(Master* self, Provider* provider, Attachment* attachment) throw();
			Transaction* (CLOOP_CARG *registerTransaction)(Master* self, Attachment* attachment, Transaction* transaction) throw();
			int (CLOOP_CARG *same)(Master* self, Versioned* first, Versioned* second) throw();
			MetadataBuilder* (CLOOP_CARG *getMetadataBuilder)(Master* self, Status* status, unsigned fieldCount) throw();
			int (CLOOP_CARG *serverMode)(Master* self, int mode) throw();
			Utl* (CLOOP_CARG *getUtlInterface)(Master* self) throw();
			ConfigManager* (CLOOP_CARG *getConfigManager)(Master* self) throw();
		};

	protected:
		Master(DoNotInherit)
			: Versioned(DoNotInherit())
		{
		}

		~Master()
		{
		}

	public:
		static const unsigned VERSION = 2;

		Status* getStatus()
		{
			Status* ret = static_cast<VTable*>(this->cloopVTable)->getStatus(this);
			return ret;
		}

		Provider* getDispatcher()
		{
			Provider* ret = static_cast<VTable*>(this->cloopVTable)->getDispatcher(this);
			return ret;
		}

		PluginManager* getPluginManager()
		{
			PluginManager* ret = static_cast<VTable*>(this->cloopVTable)->getPluginManager(this);
			return ret;
		}

		const char* circularAlloc(const char* s, unsigned len, intptr_t thr)
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->circularAlloc(this, s, len, thr);
			return ret;
		}

		TimerControl* getTimerControl()
		{
			TimerControl* ret = static_cast<VTable*>(this->cloopVTable)->getTimerControl(this);
			return ret;
		}

		Dtc* getDtc()
		{
			Dtc* ret = static_cast<VTable*>(this->cloopVTable)->getDtc(this);
			return ret;
		}

		Attachment* registerAttachment(Provider* provider, Attachment* attachment)
		{
			Attachment* ret = static_cast<VTable*>(this->cloopVTable)->registerAttachment(this, provider, attachment);
			return ret;
		}

		Transaction* registerTransaction(Attachment* attachment, Transaction* transaction)
		{
			Transaction* ret = static_cast<VTable*>(this->cloopVTable)->registerTransaction(this, attachment, transaction);
			return ret;
		}

		int same(Versioned* first, Versioned* second)
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->same(this, first, second);
			return ret;
		}

		MetadataBuilder* getMetadataBuilder(Status* status, unsigned fieldCount)
		{
			typename Policy::Status status2(status);
			MetadataBuilder* ret = static_cast<VTable*>(this->cloopVTable)->getMetadataBuilder(this, status2, fieldCount);
			Policy::checkException(status2);
			return ret;
		}

		int serverMode(int mode)
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->serverMode(this, mode);
			return ret;
		}

		Utl* getUtlInterface()
		{
			Utl* ret = static_cast<VTable*>(this->cloopVTable)->getUtlInterface(this);
			return ret;
		}

		ConfigManager* getConfigManager()
		{
			ConfigManager* ret = static_cast<VTable*>(this->cloopVTable)->getConfigManager(this);
			return ret;
		}
	};

	class PluginBase : public ReferenceCounted
	{
	public:
		struct VTable : public ReferenceCounted::VTable
		{
			void (CLOOP_CARG *setOwner)(PluginBase* self, ReferenceCounted* r) throw();
			ReferenceCounted* (CLOOP_CARG *getOwner)(PluginBase* self) throw();
		};

	protected:
		PluginBase(DoNotInherit)
			: ReferenceCounted(DoNotInherit())
		{
		}

		~PluginBase()
		{
		}

	public:
		static const unsigned VERSION = 3;

		void setOwner(ReferenceCounted* r)
		{
			static_cast<VTable*>(this->cloopVTable)->setOwner(this, r);
		}

		ReferenceCounted* getOwner()
		{
			ReferenceCounted* ret = static_cast<VTable*>(this->cloopVTable)->getOwner(this);
			return ret;
		}
	};

	class PluginSet : public ReferenceCounted
	{
	public:
		struct VTable : public ReferenceCounted::VTable
		{
			const char* (CLOOP_CARG *getName)(const PluginSet* self) throw();
			const char* (CLOOP_CARG *getModuleName)(const PluginSet* self) throw();
			PluginBase* (CLOOP_CARG *getPlugin)(PluginSet* self, Status* status) throw();
			void (CLOOP_CARG *next)(PluginSet* self, Status* status) throw();
			void (CLOOP_CARG *set)(PluginSet* self, Status* status, const char* s) throw();
		};

	protected:
		PluginSet(DoNotInherit)
			: ReferenceCounted(DoNotInherit())
		{
		}

		~PluginSet()
		{
		}

	public:
		static const unsigned VERSION = 3;

		const char* getName() const
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getName(this);
			return ret;
		}

		const char* getModuleName() const
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getModuleName(this);
			return ret;
		}

		PluginBase* getPlugin(Status* status)
		{
			typename Policy::Status status2(status);
			PluginBase* ret = static_cast<VTable*>(this->cloopVTable)->getPlugin(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		void next(Status* status)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->next(this, status2);
			Policy::checkException(status2);
		}

		void set(Status* status, const char* s)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->set(this, status2, s);
			Policy::checkException(status2);
		}
	};

	class ConfigEntry : public ReferenceCounted
	{
	public:
		struct VTable : public ReferenceCounted::VTable
		{
			const char* (CLOOP_CARG *getName)(ConfigEntry* self) throw();
			const char* (CLOOP_CARG *getValue)(ConfigEntry* self) throw();
			ISC_INT64 (CLOOP_CARG *getIntValue)(ConfigEntry* self) throw();
			FB_BOOLEAN (CLOOP_CARG *getBoolValue)(ConfigEntry* self) throw();
			Config* (CLOOP_CARG *getSubConfig)(ConfigEntry* self, Status* status) throw();
		};

	protected:
		ConfigEntry(DoNotInherit)
			: ReferenceCounted(DoNotInherit())
		{
		}

		~ConfigEntry()
		{
		}

	public:
		static const unsigned VERSION = 3;

		const char* getName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getName(this);
			return ret;
		}

		const char* getValue()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getValue(this);
			return ret;
		}

		ISC_INT64 getIntValue()
		{
			ISC_INT64 ret = static_cast<VTable*>(this->cloopVTable)->getIntValue(this);
			return ret;
		}

		FB_BOOLEAN getBoolValue()
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->getBoolValue(this);
			return ret;
		}

		Config* getSubConfig(Status* status)
		{
			typename Policy::Status status2(status);
			Config* ret = static_cast<VTable*>(this->cloopVTable)->getSubConfig(this, status2);
			Policy::checkException(status2);
			return ret;
		}
	};

	class Config : public ReferenceCounted
	{
	public:
		struct VTable : public ReferenceCounted::VTable
		{
			ConfigEntry* (CLOOP_CARG *find)(Config* self, Status* status, const char* name) throw();
			ConfigEntry* (CLOOP_CARG *findValue)(Config* self, Status* status, const char* name, const char* value) throw();
			ConfigEntry* (CLOOP_CARG *findPos)(Config* self, Status* status, const char* name, unsigned pos) throw();
		};

	protected:
		Config(DoNotInherit)
			: ReferenceCounted(DoNotInherit())
		{
		}

		~Config()
		{
		}

	public:
		static const unsigned VERSION = 3;

		ConfigEntry* find(Status* status, const char* name)
		{
			typename Policy::Status status2(status);
			ConfigEntry* ret = static_cast<VTable*>(this->cloopVTable)->find(this, status2, name);
			Policy::checkException(status2);
			return ret;
		}

		ConfigEntry* findValue(Status* status, const char* name, const char* value)
		{
			typename Policy::Status status2(status);
			ConfigEntry* ret = static_cast<VTable*>(this->cloopVTable)->findValue(this, status2, name, value);
			Policy::checkException(status2);
			return ret;
		}

		ConfigEntry* findPos(Status* status, const char* name, unsigned pos)
		{
			typename Policy::Status status2(status);
			ConfigEntry* ret = static_cast<VTable*>(this->cloopVTable)->findPos(this, status2, name, pos);
			Policy::checkException(status2);
			return ret;
		}
	};

	class FirebirdConf : public ReferenceCounted
	{
	public:
		struct VTable : public ReferenceCounted::VTable
		{
			unsigned (CLOOP_CARG *getKey)(FirebirdConf* self, const char* name) throw();
			ISC_INT64 (CLOOP_CARG *asInteger)(FirebirdConf* self, unsigned key) throw();
			const char* (CLOOP_CARG *asString)(FirebirdConf* self, unsigned key) throw();
			FB_BOOLEAN (CLOOP_CARG *asBoolean)(FirebirdConf* self, unsigned key) throw();
		};

	protected:
		FirebirdConf(DoNotInherit)
			: ReferenceCounted(DoNotInherit())
		{
		}

		~FirebirdConf()
		{
		}

	public:
		static const unsigned VERSION = 3;

		unsigned getKey(const char* name)
		{
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getKey(this, name);
			return ret;
		}

		ISC_INT64 asInteger(unsigned key)
		{
			ISC_INT64 ret = static_cast<VTable*>(this->cloopVTable)->asInteger(this, key);
			return ret;
		}

		const char* asString(unsigned key)
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->asString(this, key);
			return ret;
		}

		FB_BOOLEAN asBoolean(unsigned key)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->asBoolean(this, key);
			return ret;
		}
	};

	class PluginConfig : public ReferenceCounted
	{
	public:
		struct VTable : public ReferenceCounted::VTable
		{
			const char* (CLOOP_CARG *getConfigFileName)(PluginConfig* self) throw();
			Config* (CLOOP_CARG *getDefaultConfig)(PluginConfig* self, Status* status) throw();
			FirebirdConf* (CLOOP_CARG *getFirebirdConf)(PluginConfig* self, Status* status) throw();
			void (CLOOP_CARG *setReleaseDelay)(PluginConfig* self, Status* status, ISC_UINT64 microSeconds) throw();
		};

	protected:
		PluginConfig(DoNotInherit)
			: ReferenceCounted(DoNotInherit())
		{
		}

		~PluginConfig()
		{
		}

	public:
		static const unsigned VERSION = 3;

		const char* getConfigFileName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getConfigFileName(this);
			return ret;
		}

		Config* getDefaultConfig(Status* status)
		{
			typename Policy::Status status2(status);
			Config* ret = static_cast<VTable*>(this->cloopVTable)->getDefaultConfig(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		FirebirdConf* getFirebirdConf(Status* status)
		{
			typename Policy::Status status2(status);
			FirebirdConf* ret = static_cast<VTable*>(this->cloopVTable)->getFirebirdConf(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		void setReleaseDelay(Status* status, ISC_UINT64 microSeconds)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->setReleaseDelay(this, status2, microSeconds);
			Policy::checkException(status2);
		}
	};

	class PluginFactory : public Versioned
	{
	public:
		struct VTable : public Versioned::VTable
		{
			PluginBase* (CLOOP_CARG *createPlugin)(PluginFactory* self, Status* status, PluginConfig* factoryParameter) throw();
		};

	protected:
		PluginFactory(DoNotInherit)
			: Versioned(DoNotInherit())
		{
		}

		~PluginFactory()
		{
		}

	public:
		static const unsigned VERSION = 2;

		PluginBase* createPlugin(Status* status, PluginConfig* factoryParameter)
		{
			typename Policy::Status status2(status);
			PluginBase* ret = static_cast<VTable*>(this->cloopVTable)->createPlugin(this, status2, factoryParameter);
			Policy::checkException(status2);
			return ret;
		}
	};

	class PluginModule : public Versioned
	{
	public:
		struct VTable : public Versioned::VTable
		{
			void (CLOOP_CARG *doClean)(PluginModule* self) throw();
		};

	protected:
		PluginModule(DoNotInherit)
			: Versioned(DoNotInherit())
		{
		}

		~PluginModule()
		{
		}

	public:
		static const unsigned VERSION = 2;

		void doClean()
		{
			static_cast<VTable*>(this->cloopVTable)->doClean(this);
		}
	};

	class PluginManager : public Versioned
	{
	public:
		struct VTable : public Versioned::VTable
		{
			void (CLOOP_CARG *registerPluginFactory)(PluginManager* self, unsigned pluginType, const char* defaultName, PluginFactory* factory) throw();
			void (CLOOP_CARG *registerModule)(PluginManager* self, PluginModule* cleanup) throw();
			void (CLOOP_CARG *unregisterModule)(PluginManager* self, PluginModule* cleanup) throw();
			PluginSet* (CLOOP_CARG *getPlugins)(PluginManager* self, Status* status, unsigned pluginType, const char* namesList, FirebirdConf* firebirdConf) throw();
			Config* (CLOOP_CARG *getConfig)(PluginManager* self, Status* status, const char* filename) throw();
			void (CLOOP_CARG *releasePlugin)(PluginManager* self, PluginBase* plugin) throw();
		};

	protected:
		PluginManager(DoNotInherit)
			: Versioned(DoNotInherit())
		{
		}

		~PluginManager()
		{
		}

	public:
		static const unsigned VERSION = 2;

		static const unsigned Provider = 1;
		static const unsigned FirstNonLibPlugin = 2;
		static const unsigned AuthServer = 3;
		static const unsigned AuthClient = 4;
		static const unsigned AuthUserManagement = 5;
		static const unsigned ExternalEngine = 6;
		static const unsigned Trace = 7;
		static const unsigned WireCrypt = 8;
		static const unsigned DbCrypt = 9;
		static const unsigned KeyHolder = 10;
		static const unsigned MaxType = 11;

		void registerPluginFactory(unsigned pluginType, const char* defaultName, PluginFactory* factory)
		{
			static_cast<VTable*>(this->cloopVTable)->registerPluginFactory(this, pluginType, defaultName, factory);
		}

		void registerModule(PluginModule* cleanup)
		{
			static_cast<VTable*>(this->cloopVTable)->registerModule(this, cleanup);
		}

		void unregisterModule(PluginModule* cleanup)
		{
			static_cast<VTable*>(this->cloopVTable)->unregisterModule(this, cleanup);
		}

		PluginSet* getPlugins(Status* status, unsigned pluginType, const char* namesList, FirebirdConf* firebirdConf)
		{
			typename Policy::Status status2(status);
			PluginSet* ret = static_cast<VTable*>(this->cloopVTable)->getPlugins(this, status2, pluginType, namesList, firebirdConf);
			Policy::checkException(status2);
			return ret;
		}

		Config* getConfig(Status* status, const char* filename)
		{
			typename Policy::Status status2(status);
			Config* ret = static_cast<VTable*>(this->cloopVTable)->getConfig(this, status2, filename);
			Policy::checkException(status2);
			return ret;
		}

		void releasePlugin(PluginBase* plugin)
		{
			static_cast<VTable*>(this->cloopVTable)->releasePlugin(this, plugin);
		}
	};

	class ConfigManager : public Versioned
	{
	public:
		struct VTable : public Versioned::VTable
		{
			const char* (CLOOP_CARG *getDirectory)(ConfigManager* self, unsigned code) throw();
			FirebirdConf* (CLOOP_CARG *getFirebirdConf)(ConfigManager* self) throw();
			FirebirdConf* (CLOOP_CARG *getDatabaseConf)(ConfigManager* self, const char* dbName) throw();
			Config* (CLOOP_CARG *getPluginConfig)(ConfigManager* self, const char* configuredPlugin) throw();
			const char* (CLOOP_CARG *getInstallDirectory)(ConfigManager* self) throw();
			const char* (CLOOP_CARG *getRootDirectory)(ConfigManager* self) throw();
		};

	protected:
		ConfigManager(DoNotInherit)
			: Versioned(DoNotInherit())
		{
		}

		~ConfigManager()
		{
		}

	public:
		static const unsigned VERSION = 2;

		static const unsigned FB_DIR_BIN = 0;
		static const unsigned FB_DIR_SBIN = 1;
		static const unsigned FB_DIR_CONF = 2;
		static const unsigned FB_DIR_LIB = 3;
		static const unsigned FB_DIR_INC = 4;
		static const unsigned FB_DIR_DOC = 5;
		static const unsigned FB_DIR_UDF = 6;
		static const unsigned FB_DIR_SAMPLE = 7;
		static const unsigned FB_DIR_SAMPLEDB = 8;
		static const unsigned FB_DIR_HELP = 9;
		static const unsigned FB_DIR_INTL = 10;
		static const unsigned FB_DIR_MISC = 11;
		static const unsigned FB_DIR_SECDB = 12;
		static const unsigned FB_DIR_MSG = 13;
		static const unsigned FB_DIR_LOG = 14;
		static const unsigned FB_DIR_GUARD = 15;
		static const unsigned FB_DIR_PLUGINS = 16;
		static const unsigned FB_DIRCOUNT = 17;

		const char* getDirectory(unsigned code)
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getDirectory(this, code);
			return ret;
		}

		FirebirdConf* getFirebirdConf()
		{
			FirebirdConf* ret = static_cast<VTable*>(this->cloopVTable)->getFirebirdConf(this);
			return ret;
		}

		FirebirdConf* getDatabaseConf(const char* dbName)
		{
			FirebirdConf* ret = static_cast<VTable*>(this->cloopVTable)->getDatabaseConf(this, dbName);
			return ret;
		}

		Config* getPluginConfig(const char* configuredPlugin)
		{
			Config* ret = static_cast<VTable*>(this->cloopVTable)->getPluginConfig(this, configuredPlugin);
			return ret;
		}

		const char* getInstallDirectory()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getInstallDirectory(this);
			return ret;
		}

		const char* getRootDirectory()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getRootDirectory(this);
			return ret;
		}
	};

	class EventCallback : public ReferenceCounted
	{
	public:
		struct VTable : public ReferenceCounted::VTable
		{
			void (CLOOP_CARG *eventCallbackFunction)(EventCallback* self, unsigned length, const unsigned char* events) throw();
		};

	protected:
		EventCallback(DoNotInherit)
			: ReferenceCounted(DoNotInherit())
		{
		}

		~EventCallback()
		{
		}

	public:
		static const unsigned VERSION = 3;

		void eventCallbackFunction(unsigned length, const unsigned char* events)
		{
			static_cast<VTable*>(this->cloopVTable)->eventCallbackFunction(this, length, events);
		}
	};

	class Blob : public ReferenceCounted
	{
	public:
		struct VTable : public ReferenceCounted::VTable
		{
			void (CLOOP_CARG *getInfo)(Blob* self, Status* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) throw();
			int (CLOOP_CARG *getSegment)(Blob* self, Status* status, unsigned bufferLength, void* buffer, unsigned* segmentLength) throw();
			void (CLOOP_CARG *putSegment)(Blob* self, Status* status, unsigned length, const void* buffer) throw();
			void (CLOOP_CARG *cancel)(Blob* self, Status* status) throw();
			void (CLOOP_CARG *close)(Blob* self, Status* status) throw();
			int (CLOOP_CARG *seek)(Blob* self, Status* status, int mode, int offset) throw();
		};

	protected:
		Blob(DoNotInherit)
			: ReferenceCounted(DoNotInherit())
		{
		}

		~Blob()
		{
		}

	public:
		static const unsigned VERSION = 3;

		void getInfo(Status* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->getInfo(this, status2, itemsLength, items, bufferLength, buffer);
			Policy::checkException(status2);
		}

		int getSegment(Status* status, unsigned bufferLength, void* buffer, unsigned* segmentLength)
		{
			typename Policy::Status status2(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->getSegment(this, status2, bufferLength, buffer, segmentLength);
			Policy::checkException(status2);
			return ret;
		}

		void putSegment(Status* status, unsigned length, const void* buffer)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->putSegment(this, status2, length, buffer);
			Policy::checkException(status2);
		}

		void cancel(Status* status)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->cancel(this, status2);
			Policy::checkException(status2);
		}

		void close(Status* status)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->close(this, status2);
			Policy::checkException(status2);
		}

		int seek(Status* status, int mode, int offset)
		{
			typename Policy::Status status2(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->seek(this, status2, mode, offset);
			Policy::checkException(status2);
			return ret;
		}
	};

	class Transaction : public ReferenceCounted
	{
	public:
		struct VTable : public ReferenceCounted::VTable
		{
			void (CLOOP_CARG *getInfo)(Transaction* self, Status* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) throw();
			void (CLOOP_CARG *prepare)(Transaction* self, Status* status, unsigned msgLength, const unsigned char* message) throw();
			void (CLOOP_CARG *commit)(Transaction* self, Status* status) throw();
			void (CLOOP_CARG *commitRetaining)(Transaction* self, Status* status) throw();
			void (CLOOP_CARG *rollback)(Transaction* self, Status* status) throw();
			void (CLOOP_CARG *rollbackRetaining)(Transaction* self, Status* status) throw();
			void (CLOOP_CARG *disconnect)(Transaction* self, Status* status) throw();
			Transaction* (CLOOP_CARG *join)(Transaction* self, Status* status, Transaction* transaction) throw();
			Transaction* (CLOOP_CARG *validate)(Transaction* self, Status* status, Attachment* attachment) throw();
			Transaction* (CLOOP_CARG *enterDtc)(Transaction* self, Status* status) throw();
		};

	protected:
		Transaction(DoNotInherit)
			: ReferenceCounted(DoNotInherit())
		{
		}

		~Transaction()
		{
		}

	public:
		static const unsigned VERSION = 3;

		void getInfo(Status* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->getInfo(this, status2, itemsLength, items, bufferLength, buffer);
			Policy::checkException(status2);
		}

		void prepare(Status* status, unsigned msgLength, const unsigned char* message)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->prepare(this, status2, msgLength, message);
			Policy::checkException(status2);
		}

		void commit(Status* status)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->commit(this, status2);
			Policy::checkException(status2);
		}

		void commitRetaining(Status* status)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->commitRetaining(this, status2);
			Policy::checkException(status2);
		}

		void rollback(Status* status)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->rollback(this, status2);
			Policy::checkException(status2);
		}

		void rollbackRetaining(Status* status)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->rollbackRetaining(this, status2);
			Policy::checkException(status2);
		}

		void disconnect(Status* status)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->disconnect(this, status2);
			Policy::checkException(status2);
		}

		Transaction* join(Status* status, Transaction* transaction)
		{
			typename Policy::Status status2(status);
			Transaction* ret = static_cast<VTable*>(this->cloopVTable)->join(this, status2, transaction);
			Policy::checkException(status2);
			return ret;
		}

		Transaction* validate(Status* status, Attachment* attachment)
		{
			typename Policy::Status status2(status);
			Transaction* ret = static_cast<VTable*>(this->cloopVTable)->validate(this, status2, attachment);
			Policy::checkException(status2);
			return ret;
		}

		Transaction* enterDtc(Status* status)
		{
			typename Policy::Status status2(status);
			Transaction* ret = static_cast<VTable*>(this->cloopVTable)->enterDtc(this, status2);
			Policy::checkException(status2);
			return ret;
		}
	};

	class MessageMetadata : public ReferenceCounted
	{
	public:
		struct VTable : public ReferenceCounted::VTable
		{
			unsigned (CLOOP_CARG *getCount)(MessageMetadata* self, Status* status) throw();
			const char* (CLOOP_CARG *getField)(MessageMetadata* self, Status* status, unsigned index) throw();
			const char* (CLOOP_CARG *getRelation)(MessageMetadata* self, Status* status, unsigned index) throw();
			const char* (CLOOP_CARG *getOwner)(MessageMetadata* self, Status* status, unsigned index) throw();
			const char* (CLOOP_CARG *getAlias)(MessageMetadata* self, Status* status, unsigned index) throw();
			unsigned (CLOOP_CARG *getType)(MessageMetadata* self, Status* status, unsigned index) throw();
			FB_BOOLEAN (CLOOP_CARG *isNullable)(MessageMetadata* self, Status* status, unsigned index) throw();
			int (CLOOP_CARG *getSubType)(MessageMetadata* self, Status* status, unsigned index) throw();
			unsigned (CLOOP_CARG *getLength)(MessageMetadata* self, Status* status, unsigned index) throw();
			int (CLOOP_CARG *getScale)(MessageMetadata* self, Status* status, unsigned index) throw();
			unsigned (CLOOP_CARG *getCharSet)(MessageMetadata* self, Status* status, unsigned index) throw();
			unsigned (CLOOP_CARG *getOffset)(MessageMetadata* self, Status* status, unsigned index) throw();
			unsigned (CLOOP_CARG *getNullOffset)(MessageMetadata* self, Status* status, unsigned index) throw();
			MetadataBuilder* (CLOOP_CARG *getBuilder)(MessageMetadata* self, Status* status) throw();
			unsigned (CLOOP_CARG *getMessageLength)(MessageMetadata* self, Status* status) throw();
		};

	protected:
		MessageMetadata(DoNotInherit)
			: ReferenceCounted(DoNotInherit())
		{
		}

		~MessageMetadata()
		{
		}

	public:
		static const unsigned VERSION = 3;

		unsigned getCount(Status* status)
		{
			typename Policy::Status status2(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getCount(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		const char* getField(Status* status, unsigned index)
		{
			typename Policy::Status status2(status);
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getField(this, status2, index);
			Policy::checkException(status2);
			return ret;
		}

		const char* getRelation(Status* status, unsigned index)
		{
			typename Policy::Status status2(status);
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getRelation(this, status2, index);
			Policy::checkException(status2);
			return ret;
		}

		const char* getOwner(Status* status, unsigned index)
		{
			typename Policy::Status status2(status);
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getOwner(this, status2, index);
			Policy::checkException(status2);
			return ret;
		}

		const char* getAlias(Status* status, unsigned index)
		{
			typename Policy::Status status2(status);
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getAlias(this, status2, index);
			Policy::checkException(status2);
			return ret;
		}

		unsigned getType(Status* status, unsigned index)
		{
			typename Policy::Status status2(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getType(this, status2, index);
			Policy::checkException(status2);
			return ret;
		}

		FB_BOOLEAN isNullable(Status* status, unsigned index)
		{
			typename Policy::Status status2(status);
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->isNullable(this, status2, index);
			Policy::checkException(status2);
			return ret;
		}

		int getSubType(Status* status, unsigned index)
		{
			typename Policy::Status status2(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->getSubType(this, status2, index);
			Policy::checkException(status2);
			return ret;
		}

		unsigned getLength(Status* status, unsigned index)
		{
			typename Policy::Status status2(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getLength(this, status2, index);
			Policy::checkException(status2);
			return ret;
		}

		int getScale(Status* status, unsigned index)
		{
			typename Policy::Status status2(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->getScale(this, status2, index);
			Policy::checkException(status2);
			return ret;
		}

		unsigned getCharSet(Status* status, unsigned index)
		{
			typename Policy::Status status2(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getCharSet(this, status2, index);
			Policy::checkException(status2);
			return ret;
		}

		unsigned getOffset(Status* status, unsigned index)
		{
			typename Policy::Status status2(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getOffset(this, status2, index);
			Policy::checkException(status2);
			return ret;
		}

		unsigned getNullOffset(Status* status, unsigned index)
		{
			typename Policy::Status status2(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getNullOffset(this, status2, index);
			Policy::checkException(status2);
			return ret;
		}

		MetadataBuilder* getBuilder(Status* status)
		{
			typename Policy::Status status2(status);
			MetadataBuilder* ret = static_cast<VTable*>(this->cloopVTable)->getBuilder(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		unsigned getMessageLength(Status* status)
		{
			typename Policy::Status status2(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getMessageLength(this, status2);
			Policy::checkException(status2);
			return ret;
		}
	};

	class MetadataBuilder : public ReferenceCounted
	{
	public:
		struct VTable : public ReferenceCounted::VTable
		{
			void (CLOOP_CARG *setType)(MetadataBuilder* self, Status* status, unsigned index, unsigned type) throw();
			void (CLOOP_CARG *setSubType)(MetadataBuilder* self, Status* status, unsigned index, int subType) throw();
			void (CLOOP_CARG *setLength)(MetadataBuilder* self, Status* status, unsigned index, unsigned length) throw();
			void (CLOOP_CARG *setCharSet)(MetadataBuilder* self, Status* status, unsigned index, unsigned charSet) throw();
			void (CLOOP_CARG *setScale)(MetadataBuilder* self, Status* status, unsigned index, unsigned scale) throw();
			void (CLOOP_CARG *truncate)(MetadataBuilder* self, Status* status, unsigned count) throw();
			void (CLOOP_CARG *moveNameToIndex)(MetadataBuilder* self, Status* status, const char* name, unsigned index) throw();
			void (CLOOP_CARG *remove)(MetadataBuilder* self, Status* status, unsigned index) throw();
			unsigned (CLOOP_CARG *addField)(MetadataBuilder* self, Status* status) throw();
			MessageMetadata* (CLOOP_CARG *getMetadata)(MetadataBuilder* self, Status* status) throw();
		};

	protected:
		MetadataBuilder(DoNotInherit)
			: ReferenceCounted(DoNotInherit())
		{
		}

		~MetadataBuilder()
		{
		}

	public:
		static const unsigned VERSION = 3;

		void setType(Status* status, unsigned index, unsigned type)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->setType(this, status2, index, type);
			Policy::checkException(status2);
		}

		void setSubType(Status* status, unsigned index, int subType)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->setSubType(this, status2, index, subType);
			Policy::checkException(status2);
		}

		void setLength(Status* status, unsigned index, unsigned length)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->setLength(this, status2, index, length);
			Policy::checkException(status2);
		}

		void setCharSet(Status* status, unsigned index, unsigned charSet)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->setCharSet(this, status2, index, charSet);
			Policy::checkException(status2);
		}

		void setScale(Status* status, unsigned index, unsigned scale)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->setScale(this, status2, index, scale);
			Policy::checkException(status2);
		}

		void truncate(Status* status, unsigned count)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->truncate(this, status2, count);
			Policy::checkException(status2);
		}

		void moveNameToIndex(Status* status, const char* name, unsigned index)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->moveNameToIndex(this, status2, name, index);
			Policy::checkException(status2);
		}

		void remove(Status* status, unsigned index)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->remove(this, status2, index);
			Policy::checkException(status2);
		}

		unsigned addField(Status* status)
		{
			typename Policy::Status status2(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->addField(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		MessageMetadata* getMetadata(Status* status)
		{
			typename Policy::Status status2(status);
			MessageMetadata* ret = static_cast<VTable*>(this->cloopVTable)->getMetadata(this, status2);
			Policy::checkException(status2);
			return ret;
		}
	};

	class ResultSet : public ReferenceCounted
	{
	public:
		struct VTable : public ReferenceCounted::VTable
		{
			int (CLOOP_CARG *fetchNext)(ResultSet* self, Status* status, void* message) throw();
			int (CLOOP_CARG *fetchPrior)(ResultSet* self, Status* status, void* message) throw();
			int (CLOOP_CARG *fetchFirst)(ResultSet* self, Status* status, void* message) throw();
			int (CLOOP_CARG *fetchLast)(ResultSet* self, Status* status, void* message) throw();
			int (CLOOP_CARG *fetchAbsolute)(ResultSet* self, Status* status, unsigned position, void* message) throw();
			int (CLOOP_CARG *fetchRelative)(ResultSet* self, Status* status, int offset, void* message) throw();
			FB_BOOLEAN (CLOOP_CARG *isEof)(ResultSet* self, Status* status) throw();
			FB_BOOLEAN (CLOOP_CARG *isBof)(ResultSet* self, Status* status) throw();
			MessageMetadata* (CLOOP_CARG *getMetadata)(ResultSet* self, Status* status) throw();
			void (CLOOP_CARG *close)(ResultSet* self, Status* status) throw();
			void (CLOOP_CARG *setDelayedOutputFormat)(ResultSet* self, Status* status, MessageMetadata* format) throw();
		};

	protected:
		ResultSet(DoNotInherit)
			: ReferenceCounted(DoNotInherit())
		{
		}

		~ResultSet()
		{
		}

	public:
		static const unsigned VERSION = 3;

		int fetchNext(Status* status, void* message)
		{
			typename Policy::Status status2(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->fetchNext(this, status2, message);
			Policy::checkException(status2);
			return ret;
		}

		int fetchPrior(Status* status, void* message)
		{
			typename Policy::Status status2(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->fetchPrior(this, status2, message);
			Policy::checkException(status2);
			return ret;
		}

		int fetchFirst(Status* status, void* message)
		{
			typename Policy::Status status2(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->fetchFirst(this, status2, message);
			Policy::checkException(status2);
			return ret;
		}

		int fetchLast(Status* status, void* message)
		{
			typename Policy::Status status2(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->fetchLast(this, status2, message);
			Policy::checkException(status2);
			return ret;
		}

		int fetchAbsolute(Status* status, unsigned position, void* message)
		{
			typename Policy::Status status2(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->fetchAbsolute(this, status2, position, message);
			Policy::checkException(status2);
			return ret;
		}

		int fetchRelative(Status* status, int offset, void* message)
		{
			typename Policy::Status status2(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->fetchRelative(this, status2, offset, message);
			Policy::checkException(status2);
			return ret;
		}

		FB_BOOLEAN isEof(Status* status)
		{
			typename Policy::Status status2(status);
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->isEof(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		FB_BOOLEAN isBof(Status* status)
		{
			typename Policy::Status status2(status);
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->isBof(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		MessageMetadata* getMetadata(Status* status)
		{
			typename Policy::Status status2(status);
			MessageMetadata* ret = static_cast<VTable*>(this->cloopVTable)->getMetadata(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		void close(Status* status)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->close(this, status2);
			Policy::checkException(status2);
		}

		void setDelayedOutputFormat(Status* status, MessageMetadata* format)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->setDelayedOutputFormat(this, status2, format);
			Policy::checkException(status2);
		}
	};

	class Statement : public ReferenceCounted
	{
	public:
		struct VTable : public ReferenceCounted::VTable
		{
			void (CLOOP_CARG *getInfo)(Statement* self, Status* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) throw();
			unsigned (CLOOP_CARG *getType)(Statement* self, Status* status) throw();
			const char* (CLOOP_CARG *getPlan)(Statement* self, Status* status, FB_BOOLEAN detailed) throw();
			ISC_UINT64 (CLOOP_CARG *getAffectedRecords)(Statement* self, Status* status) throw();
			MessageMetadata* (CLOOP_CARG *getInputMetadata)(Statement* self, Status* status) throw();
			MessageMetadata* (CLOOP_CARG *getOutputMetadata)(Statement* self, Status* status) throw();
			Transaction* (CLOOP_CARG *execute)(Statement* self, Status* status, Transaction* transaction, MessageMetadata* inMetadata, void* inBuffer, MessageMetadata* outMetadata, void* outBuffer) throw();
			ResultSet* (CLOOP_CARG *openCursor)(Statement* self, Status* status, Transaction* transaction, MessageMetadata* inMetadata, void* inBuffer, MessageMetadata* outMetadata) throw();
			void (CLOOP_CARG *setCursorName)(Statement* self, Status* status, const char* name) throw();
			void (CLOOP_CARG *free)(Statement* self, Status* status) throw();
			unsigned (CLOOP_CARG *getFlags)(Statement* self, Status* status) throw();
		};

	protected:
		Statement(DoNotInherit)
			: ReferenceCounted(DoNotInherit())
		{
		}

		~Statement()
		{
		}

	public:
		static const unsigned VERSION = 3;

		static const unsigned PREPARE_PREFETCH_NONE = 0;
		static const unsigned PREPARE_PREFETCH_TYPE = 1;
		static const unsigned PREPARE_PREFETCH_INPUT_PARAMETERS = 2;
		static const unsigned PREPARE_PREFETCH_OUTPUT_PARAMETERS = 4;
		static const unsigned PREPARE_PREFETCH_LEGACY_PLAN = 8;
		static const unsigned PREPARE_PREFETCH_DETAILED_PLAN = 16;
		static const unsigned PREPARE_PREFETCH_AFFECTED_RECORDS = 32;
		static const unsigned PREPARE_PREFETCH_FLAGS = 64;
		static const unsigned PREPARE_PREFETCH_METADATA = Statement::PREPARE_PREFETCH_TYPE | Statement::PREPARE_PREFETCH_FLAGS | Statement::PREPARE_PREFETCH_INPUT_PARAMETERS | Statement::PREPARE_PREFETCH_OUTPUT_PARAMETERS;
		static const unsigned PREPARE_PREFETCH_ALL = Statement::PREPARE_PREFETCH_METADATA | Statement::PREPARE_PREFETCH_LEGACY_PLAN | Statement::PREPARE_PREFETCH_DETAILED_PLAN | Statement::PREPARE_PREFETCH_AFFECTED_RECORDS;
		static const unsigned FLAG_HAS_CURSOR = 1;
		static const unsigned FLAG_REPEAT_EXECUTE = 2;

		void getInfo(Status* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->getInfo(this, status2, itemsLength, items, bufferLength, buffer);
			Policy::checkException(status2);
		}

		unsigned getType(Status* status)
		{
			typename Policy::Status status2(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getType(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		const char* getPlan(Status* status, FB_BOOLEAN detailed)
		{
			typename Policy::Status status2(status);
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getPlan(this, status2, detailed);
			Policy::checkException(status2);
			return ret;
		}

		ISC_UINT64 getAffectedRecords(Status* status)
		{
			typename Policy::Status status2(status);
			ISC_UINT64 ret = static_cast<VTable*>(this->cloopVTable)->getAffectedRecords(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		MessageMetadata* getInputMetadata(Status* status)
		{
			typename Policy::Status status2(status);
			MessageMetadata* ret = static_cast<VTable*>(this->cloopVTable)->getInputMetadata(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		MessageMetadata* getOutputMetadata(Status* status)
		{
			typename Policy::Status status2(status);
			MessageMetadata* ret = static_cast<VTable*>(this->cloopVTable)->getOutputMetadata(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		Transaction* execute(Status* status, Transaction* transaction, MessageMetadata* inMetadata, void* inBuffer, MessageMetadata* outMetadata, void* outBuffer)
		{
			typename Policy::Status status2(status);
			Transaction* ret = static_cast<VTable*>(this->cloopVTable)->execute(this, status2, transaction, inMetadata, inBuffer, outMetadata, outBuffer);
			Policy::checkException(status2);
			return ret;
		}

		ResultSet* openCursor(Status* status, Transaction* transaction, MessageMetadata* inMetadata, void* inBuffer, MessageMetadata* outMetadata)
		{
			typename Policy::Status status2(status);
			ResultSet* ret = static_cast<VTable*>(this->cloopVTable)->openCursor(this, status2, transaction, inMetadata, inBuffer, outMetadata);
			Policy::checkException(status2);
			return ret;
		}

		void setCursorName(Status* status, const char* name)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->setCursorName(this, status2, name);
			Policy::checkException(status2);
		}

		void free(Status* status)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->free(this, status2);
			Policy::checkException(status2);
		}

		unsigned getFlags(Status* status)
		{
			typename Policy::Status status2(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getFlags(this, status2);
			Policy::checkException(status2);
			return ret;
		}
	};

	class Request : public ReferenceCounted
	{
	public:
		struct VTable : public ReferenceCounted::VTable
		{
			void (CLOOP_CARG *receive)(Request* self, Status* status, int level, unsigned msgType, unsigned length, unsigned char* message) throw();
			void (CLOOP_CARG *send)(Request* self, Status* status, int level, unsigned msgType, unsigned length, const unsigned char* message) throw();
			void (CLOOP_CARG *getInfo)(Request* self, Status* status, int level, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) throw();
			void (CLOOP_CARG *start)(Request* self, Status* status, Transaction* tra, int level) throw();
			void (CLOOP_CARG *startAndSend)(Request* self, Status* status, Transaction* tra, int level, unsigned msgType, unsigned length, const unsigned char* message) throw();
			void (CLOOP_CARG *unwind)(Request* self, Status* status, int level) throw();
			void (CLOOP_CARG *free)(Request* self, Status* status) throw();
		};

	protected:
		Request(DoNotInherit)
			: ReferenceCounted(DoNotInherit())
		{
		}

		~Request()
		{
		}

	public:
		static const unsigned VERSION = 3;

		void receive(Status* status, int level, unsigned msgType, unsigned length, unsigned char* message)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->receive(this, status2, level, msgType, length, message);
			Policy::checkException(status2);
		}

		void send(Status* status, int level, unsigned msgType, unsigned length, const unsigned char* message)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->send(this, status2, level, msgType, length, message);
			Policy::checkException(status2);
		}

		void getInfo(Status* status, int level, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->getInfo(this, status2, level, itemsLength, items, bufferLength, buffer);
			Policy::checkException(status2);
		}

		void start(Status* status, Transaction* tra, int level)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->start(this, status2, tra, level);
			Policy::checkException(status2);
		}

		void startAndSend(Status* status, Transaction* tra, int level, unsigned msgType, unsigned length, const unsigned char* message)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->startAndSend(this, status2, tra, level, msgType, length, message);
			Policy::checkException(status2);
		}

		void unwind(Status* status, int level)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->unwind(this, status2, level);
			Policy::checkException(status2);
		}

		void free(Status* status)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->free(this, status2);
			Policy::checkException(status2);
		}
	};

	class Events : public ReferenceCounted
	{
	public:
		struct VTable : public ReferenceCounted::VTable
		{
			void (CLOOP_CARG *cancel)(Events* self, Status* status) throw();
		};

	protected:
		Events(DoNotInherit)
			: ReferenceCounted(DoNotInherit())
		{
		}

		~Events()
		{
		}

	public:
		static const unsigned VERSION = 3;

		void cancel(Status* status)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->cancel(this, status2);
			Policy::checkException(status2);
		}
	};

	class Attachment : public ReferenceCounted
	{
	public:
		struct VTable : public ReferenceCounted::VTable
		{
			void (CLOOP_CARG *getInfo)(Attachment* self, Status* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) throw();
			Transaction* (CLOOP_CARG *startTransaction)(Attachment* self, Status* status, unsigned tpbLength, const unsigned char* tpb) throw();
			Transaction* (CLOOP_CARG *reconnectTransaction)(Attachment* self, Status* status, unsigned length, const unsigned char* id) throw();
			Request* (CLOOP_CARG *compileRequest)(Attachment* self, Status* status, unsigned blrLength, const unsigned char* blr) throw();
			void (CLOOP_CARG *transactRequest)(Attachment* self, Status* status, Transaction* transaction, unsigned blrLength, const unsigned char* blr, unsigned inMsgLength, const unsigned char* inMsg, unsigned outMsgLength, unsigned char* outMsg) throw();
			Blob* (CLOOP_CARG *createBlob)(Attachment* self, Status* status, Transaction* transaction, ISC_QUAD* id, unsigned bpbLength, const unsigned char* bpb) throw();
			Blob* (CLOOP_CARG *openBlob)(Attachment* self, Status* status, Transaction* transaction, ISC_QUAD* id, unsigned bpbLength, const unsigned char* bpb) throw();
			int (CLOOP_CARG *getSlice)(Attachment* self, Status* status, Transaction* transaction, ISC_QUAD* id, unsigned sdlLength, const unsigned char* sdl, unsigned paramLength, const unsigned char* param, int sliceLength, unsigned char* slice) throw();
			void (CLOOP_CARG *putSlice)(Attachment* self, Status* status, Transaction* transaction, ISC_QUAD* id, unsigned sdlLength, const unsigned char* sdl, unsigned paramLength, const unsigned char* param, int sliceLength, unsigned char* slice) throw();
			void (CLOOP_CARG *executeDyn)(Attachment* self, Status* status, Transaction* transaction, unsigned length, const unsigned char* dyn) throw();
			Statement* (CLOOP_CARG *prepare)(Attachment* self, Status* status, Transaction* tra, unsigned stmtLength, const char* sqlStmt, unsigned dialect, unsigned flags) throw();
			Transaction* (CLOOP_CARG *execute)(Attachment* self, Status* status, Transaction* transaction, unsigned stmtLength, const char* sqlStmt, unsigned dialect, MessageMetadata* inMetadata, void* inBuffer, MessageMetadata* outMetadata, void* outBuffer) throw();
			ResultSet* (CLOOP_CARG *openCursor)(Attachment* self, Status* status, Transaction* transaction, unsigned stmtLength, const char* sqlStmt, unsigned dialect, MessageMetadata* inMetadata, void* inBuffer, MessageMetadata* outMetadata, const char* cursorName) throw();
			Events* (CLOOP_CARG *queEvents)(Attachment* self, Status* status, EventCallback* callback, unsigned length, const unsigned char* events) throw();
			void (CLOOP_CARG *cancelOperation)(Attachment* self, Status* status, int option) throw();
			void (CLOOP_CARG *ping)(Attachment* self, Status* status) throw();
			void (CLOOP_CARG *detach)(Attachment* self, Status* status) throw();
			void (CLOOP_CARG *dropDatabase)(Attachment* self, Status* status) throw();
		};

	protected:
		Attachment(DoNotInherit)
			: ReferenceCounted(DoNotInherit())
		{
		}

		~Attachment()
		{
		}

	public:
		static const unsigned VERSION = 3;

		void getInfo(Status* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->getInfo(this, status2, itemsLength, items, bufferLength, buffer);
			Policy::checkException(status2);
		}

		Transaction* startTransaction(Status* status, unsigned tpbLength, const unsigned char* tpb)
		{
			typename Policy::Status status2(status);
			Transaction* ret = static_cast<VTable*>(this->cloopVTable)->startTransaction(this, status2, tpbLength, tpb);
			Policy::checkException(status2);
			return ret;
		}

		Transaction* reconnectTransaction(Status* status, unsigned length, const unsigned char* id)
		{
			typename Policy::Status status2(status);
			Transaction* ret = static_cast<VTable*>(this->cloopVTable)->reconnectTransaction(this, status2, length, id);
			Policy::checkException(status2);
			return ret;
		}

		Request* compileRequest(Status* status, unsigned blrLength, const unsigned char* blr)
		{
			typename Policy::Status status2(status);
			Request* ret = static_cast<VTable*>(this->cloopVTable)->compileRequest(this, status2, blrLength, blr);
			Policy::checkException(status2);
			return ret;
		}

		void transactRequest(Status* status, Transaction* transaction, unsigned blrLength, const unsigned char* blr, unsigned inMsgLength, const unsigned char* inMsg, unsigned outMsgLength, unsigned char* outMsg)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->transactRequest(this, status2, transaction, blrLength, blr, inMsgLength, inMsg, outMsgLength, outMsg);
			Policy::checkException(status2);
		}

		Blob* createBlob(Status* status, Transaction* transaction, ISC_QUAD* id, unsigned bpbLength, const unsigned char* bpb)
		{
			typename Policy::Status status2(status);
			Blob* ret = static_cast<VTable*>(this->cloopVTable)->createBlob(this, status2, transaction, id, bpbLength, bpb);
			Policy::checkException(status2);
			return ret;
		}

		Blob* openBlob(Status* status, Transaction* transaction, ISC_QUAD* id, unsigned bpbLength, const unsigned char* bpb)
		{
			typename Policy::Status status2(status);
			Blob* ret = static_cast<VTable*>(this->cloopVTable)->openBlob(this, status2, transaction, id, bpbLength, bpb);
			Policy::checkException(status2);
			return ret;
		}

		int getSlice(Status* status, Transaction* transaction, ISC_QUAD* id, unsigned sdlLength, const unsigned char* sdl, unsigned paramLength, const unsigned char* param, int sliceLength, unsigned char* slice)
		{
			typename Policy::Status status2(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->getSlice(this, status2, transaction, id, sdlLength, sdl, paramLength, param, sliceLength, slice);
			Policy::checkException(status2);
			return ret;
		}

		void putSlice(Status* status, Transaction* transaction, ISC_QUAD* id, unsigned sdlLength, const unsigned char* sdl, unsigned paramLength, const unsigned char* param, int sliceLength, unsigned char* slice)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->putSlice(this, status2, transaction, id, sdlLength, sdl, paramLength, param, sliceLength, slice);
			Policy::checkException(status2);
		}

		void executeDyn(Status* status, Transaction* transaction, unsigned length, const unsigned char* dyn)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->executeDyn(this, status2, transaction, length, dyn);
			Policy::checkException(status2);
		}

		Statement* prepare(Status* status, Transaction* tra, unsigned stmtLength, const char* sqlStmt, unsigned dialect, unsigned flags)
		{
			typename Policy::Status status2(status);
			Statement* ret = static_cast<VTable*>(this->cloopVTable)->prepare(this, status2, tra, stmtLength, sqlStmt, dialect, flags);
			Policy::checkException(status2);
			return ret;
		}

		Transaction* execute(Status* status, Transaction* transaction, unsigned stmtLength, const char* sqlStmt, unsigned dialect, MessageMetadata* inMetadata, void* inBuffer, MessageMetadata* outMetadata, void* outBuffer)
		{
			typename Policy::Status status2(status);
			Transaction* ret = static_cast<VTable*>(this->cloopVTable)->execute(this, status2, transaction, stmtLength, sqlStmt, dialect, inMetadata, inBuffer, outMetadata, outBuffer);
			Policy::checkException(status2);
			return ret;
		}

		ResultSet* openCursor(Status* status, Transaction* transaction, unsigned stmtLength, const char* sqlStmt, unsigned dialect, MessageMetadata* inMetadata, void* inBuffer, MessageMetadata* outMetadata, const char* cursorName)
		{
			typename Policy::Status status2(status);
			ResultSet* ret = static_cast<VTable*>(this->cloopVTable)->openCursor(this, status2, transaction, stmtLength, sqlStmt, dialect, inMetadata, inBuffer, outMetadata, cursorName);
			Policy::checkException(status2);
			return ret;
		}

		Events* queEvents(Status* status, EventCallback* callback, unsigned length, const unsigned char* events)
		{
			typename Policy::Status status2(status);
			Events* ret = static_cast<VTable*>(this->cloopVTable)->queEvents(this, status2, callback, length, events);
			Policy::checkException(status2);
			return ret;
		}

		void cancelOperation(Status* status, int option)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->cancelOperation(this, status2, option);
			Policy::checkException(status2);
		}

		void ping(Status* status)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->ping(this, status2);
			Policy::checkException(status2);
		}

		void detach(Status* status)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->detach(this, status2);
			Policy::checkException(status2);
		}

		void dropDatabase(Status* status)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->dropDatabase(this, status2);
			Policy::checkException(status2);
		}
	};

	class Service : public ReferenceCounted
	{
	public:
		struct VTable : public ReferenceCounted::VTable
		{
			void (CLOOP_CARG *detach)(Service* self, Status* status) throw();
			void (CLOOP_CARG *query)(Service* self, Status* status, unsigned sendLength, const unsigned char* sendItems, unsigned receiveLength, const unsigned char* receiveItems, unsigned bufferLength, unsigned char* buffer) throw();
			void (CLOOP_CARG *start)(Service* self, Status* status, unsigned spbLength, const unsigned char* spb) throw();
		};

	protected:
		Service(DoNotInherit)
			: ReferenceCounted(DoNotInherit())
		{
		}

		~Service()
		{
		}

	public:
		static const unsigned VERSION = 3;

		void detach(Status* status)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->detach(this, status2);
			Policy::checkException(status2);
		}

		void query(Status* status, unsigned sendLength, const unsigned char* sendItems, unsigned receiveLength, const unsigned char* receiveItems, unsigned bufferLength, unsigned char* buffer)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->query(this, status2, sendLength, sendItems, receiveLength, receiveItems, bufferLength, buffer);
			Policy::checkException(status2);
		}

		void start(Status* status, unsigned spbLength, const unsigned char* spb)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->start(this, status2, spbLength, spb);
			Policy::checkException(status2);
		}
	};

	class Provider : public PluginBase
	{
	public:
		struct VTable : public PluginBase::VTable
		{
			Attachment* (CLOOP_CARG *attachDatabase)(Provider* self, Status* status, const char* fileName, unsigned dpbLength, const unsigned char* dpb) throw();
			Attachment* (CLOOP_CARG *createDatabase)(Provider* self, Status* status, const char* fileName, unsigned dpbLength, const unsigned char* dpb) throw();
			Service* (CLOOP_CARG *attachServiceManager)(Provider* self, Status* status, const char* service, unsigned spbLength, const unsigned char* spb) throw();
			void (CLOOP_CARG *shutdown)(Provider* self, Status* status, unsigned timeout, const int reason) throw();
			void (CLOOP_CARG *setDbCryptCallback)(Provider* self, Status* status, CryptKeyCallback* cryptCallback) throw();
		};

	protected:
		Provider(DoNotInherit)
			: PluginBase(DoNotInherit())
		{
		}

		~Provider()
		{
		}

	public:
		static const unsigned VERSION = 4;

		Attachment* attachDatabase(Status* status, const char* fileName, unsigned dpbLength, const unsigned char* dpb)
		{
			typename Policy::Status status2(status);
			Attachment* ret = static_cast<VTable*>(this->cloopVTable)->attachDatabase(this, status2, fileName, dpbLength, dpb);
			Policy::checkException(status2);
			return ret;
		}

		Attachment* createDatabase(Status* status, const char* fileName, unsigned dpbLength, const unsigned char* dpb)
		{
			typename Policy::Status status2(status);
			Attachment* ret = static_cast<VTable*>(this->cloopVTable)->createDatabase(this, status2, fileName, dpbLength, dpb);
			Policy::checkException(status2);
			return ret;
		}

		Service* attachServiceManager(Status* status, const char* service, unsigned spbLength, const unsigned char* spb)
		{
			typename Policy::Status status2(status);
			Service* ret = static_cast<VTable*>(this->cloopVTable)->attachServiceManager(this, status2, service, spbLength, spb);
			Policy::checkException(status2);
			return ret;
		}

		void shutdown(Status* status, unsigned timeout, const int reason)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->shutdown(this, status2, timeout, reason);
			Policy::checkException(status2);
		}

		void setDbCryptCallback(Status* status, CryptKeyCallback* cryptCallback)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->setDbCryptCallback(this, status2, cryptCallback);
			Policy::checkException(status2);
		}
	};

	class DtcStart : public Disposable
	{
	public:
		struct VTable : public Disposable::VTable
		{
			void (CLOOP_CARG *setComponent)(DtcStart* self, Status* status, Attachment* att) throw();
			void (CLOOP_CARG *setWithParam)(DtcStart* self, Status* status, Attachment* att, unsigned length, const unsigned char* tpb) throw();
			unsigned (CLOOP_CARG *getCount)(DtcStart* self, Status* status) throw();
			Attachment* (CLOOP_CARG *getAttachment)(DtcStart* self, Status* status, unsigned pos) throw();
			const unsigned char* (CLOOP_CARG *getTpb)(DtcStart* self, Status* status, unsigned pos, unsigned* length) throw();
		};

	protected:
		DtcStart(DoNotInherit)
			: Disposable(DoNotInherit())
		{
		}

		~DtcStart()
		{
		}

	public:
		static const unsigned VERSION = 3;

		void setComponent(Status* status, Attachment* att)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->setComponent(this, status2, att);
			Policy::checkException(status2);
		}

		void setWithParam(Status* status, Attachment* att, unsigned length, const unsigned char* tpb)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->setWithParam(this, status2, att, length, tpb);
			Policy::checkException(status2);
		}

		unsigned getCount(Status* status)
		{
			typename Policy::Status status2(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getCount(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		Attachment* getAttachment(Status* status, unsigned pos)
		{
			typename Policy::Status status2(status);
			Attachment* ret = static_cast<VTable*>(this->cloopVTable)->getAttachment(this, status2, pos);
			Policy::checkException(status2);
			return ret;
		}

		const unsigned char* getTpb(Status* status, unsigned pos, unsigned* length)
		{
			typename Policy::Status status2(status);
			const unsigned char* ret = static_cast<VTable*>(this->cloopVTable)->getTpb(this, status2, pos, length);
			Policy::checkException(status2);
			return ret;
		}
	};

	class Dtc : public Versioned
	{
	public:
		struct VTable : public Versioned::VTable
		{
			Transaction* (CLOOP_CARG *start)(Dtc* self, Status* status, DtcStart* components) throw();
			Transaction* (CLOOP_CARG *join)(Dtc* self, Status* status, Transaction* one, Transaction* two) throw();
			DtcStart* (CLOOP_CARG *startBuilder)(Dtc* self, Status* status) throw();
		};

	protected:
		Dtc(DoNotInherit)
			: Versioned(DoNotInherit())
		{
		}

		~Dtc()
		{
		}

	public:
		static const unsigned VERSION = 2;

		Transaction* start(Status* status, DtcStart* components)
		{
			typename Policy::Status status2(status);
			Transaction* ret = static_cast<VTable*>(this->cloopVTable)->start(this, status2, components);
			Policy::checkException(status2);
			return ret;
		}

		Transaction* join(Status* status, Transaction* one, Transaction* two)
		{
			typename Policy::Status status2(status);
			Transaction* ret = static_cast<VTable*>(this->cloopVTable)->join(this, status2, one, two);
			Policy::checkException(status2);
			return ret;
		}

		DtcStart* startBuilder(Status* status)
		{
			typename Policy::Status status2(status);
			DtcStart* ret = static_cast<VTable*>(this->cloopVTable)->startBuilder(this, status2);
			Policy::checkException(status2);
			return ret;
		}
	};

	class Auth : public PluginBase
	{
	public:
		struct VTable : public PluginBase::VTable
		{
		};

	protected:
		Auth(DoNotInherit)
			: PluginBase(DoNotInherit())
		{
		}

		~Auth()
		{
		}

	public:
		static const unsigned VERSION = 4;

		static const int AUTH_FAILED = -1;
		static const int AUTH_SUCCESS = 0;
		static const int AUTH_MORE_DATA = 1;
		static const int AUTH_CONTINUE = 2;
	};

	class Writer : public Versioned
	{
	public:
		struct VTable : public Versioned::VTable
		{
			void (CLOOP_CARG *reset)(Writer* self) throw();
			void (CLOOP_CARG *add)(Writer* self, Status* status, const char* name) throw();
			void (CLOOP_CARG *setType)(Writer* self, Status* status, const char* value) throw();
			void (CLOOP_CARG *setDb)(Writer* self, Status* status, const char* value) throw();
		};

	protected:
		Writer(DoNotInherit)
			: Versioned(DoNotInherit())
		{
		}

		~Writer()
		{
		}

	public:
		static const unsigned VERSION = 2;

		void reset()
		{
			static_cast<VTable*>(this->cloopVTable)->reset(this);
		}

		void add(Status* status, const char* name)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->add(this, status2, name);
			Policy::checkException(status2);
		}

		void setType(Status* status, const char* value)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->setType(this, status2, value);
			Policy::checkException(status2);
		}

		void setDb(Status* status, const char* value)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->setDb(this, status2, value);
			Policy::checkException(status2);
		}
	};

	class ServerBlock : public Versioned
	{
	public:
		struct VTable : public Versioned::VTable
		{
			const char* (CLOOP_CARG *getLogin)(ServerBlock* self) throw();
			const unsigned char* (CLOOP_CARG *getData)(ServerBlock* self, unsigned* length) throw();
			void (CLOOP_CARG *putData)(ServerBlock* self, Status* status, unsigned length, const void* data) throw();
			void (CLOOP_CARG *putKey)(ServerBlock* self, Status* status, FbCryptKey* cryptKey) throw();
		};

	protected:
		ServerBlock(DoNotInherit)
			: Versioned(DoNotInherit())
		{
		}

		~ServerBlock()
		{
		}

	public:
		static const unsigned VERSION = 2;

		const char* getLogin()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getLogin(this);
			return ret;
		}

		const unsigned char* getData(unsigned* length)
		{
			const unsigned char* ret = static_cast<VTable*>(this->cloopVTable)->getData(this, length);
			return ret;
		}

		void putData(Status* status, unsigned length, const void* data)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->putData(this, status2, length, data);
			Policy::checkException(status2);
		}

		void putKey(Status* status, FbCryptKey* cryptKey)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->putKey(this, status2, cryptKey);
			Policy::checkException(status2);
		}
	};

	class ClientBlock : public ReferenceCounted
	{
	public:
		struct VTable : public ReferenceCounted::VTable
		{
			const char* (CLOOP_CARG *getLogin)(ClientBlock* self) throw();
			const char* (CLOOP_CARG *getPassword)(ClientBlock* self) throw();
			const unsigned char* (CLOOP_CARG *getData)(ClientBlock* self, unsigned* length) throw();
			void (CLOOP_CARG *putData)(ClientBlock* self, Status* status, unsigned length, const void* data) throw();
			void (CLOOP_CARG *putKey)(ClientBlock* self, Status* status, FbCryptKey* cryptKey) throw();
		};

	protected:
		ClientBlock(DoNotInherit)
			: ReferenceCounted(DoNotInherit())
		{
		}

		~ClientBlock()
		{
		}

	public:
		static const unsigned VERSION = 3;

		const char* getLogin()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getLogin(this);
			return ret;
		}

		const char* getPassword()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getPassword(this);
			return ret;
		}

		const unsigned char* getData(unsigned* length)
		{
			const unsigned char* ret = static_cast<VTable*>(this->cloopVTable)->getData(this, length);
			return ret;
		}

		void putData(Status* status, unsigned length, const void* data)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->putData(this, status2, length, data);
			Policy::checkException(status2);
		}

		void putKey(Status* status, FbCryptKey* cryptKey)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->putKey(this, status2, cryptKey);
			Policy::checkException(status2);
		}
	};

	class Server : public Auth
	{
	public:
		struct VTable : public Auth::VTable
		{
			int (CLOOP_CARG *authenticate)(Server* self, Status* status, ServerBlock* sBlock, Writer* writerInterface) throw();
		};

	protected:
		Server(DoNotInherit)
			: Auth(DoNotInherit())
		{
		}

		~Server()
		{
		}

	public:
		static const unsigned VERSION = 5;

		int authenticate(Status* status, ServerBlock* sBlock, Writer* writerInterface)
		{
			typename Policy::Status status2(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->authenticate(this, status2, sBlock, writerInterface);
			Policy::checkException(status2);
			return ret;
		}
	};

	class Client : public Auth
	{
	public:
		struct VTable : public Auth::VTable
		{
			int (CLOOP_CARG *authenticate)(Client* self, Status* status, ClientBlock* cBlock) throw();
		};

	protected:
		Client(DoNotInherit)
			: Auth(DoNotInherit())
		{
		}

		~Client()
		{
		}

	public:
		static const unsigned VERSION = 5;

		int authenticate(Status* status, ClientBlock* cBlock)
		{
			typename Policy::Status status2(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->authenticate(this, status2, cBlock);
			Policy::checkException(status2);
			return ret;
		}
	};

	class UserField : public Versioned
	{
	public:
		struct VTable : public Versioned::VTable
		{
			int (CLOOP_CARG *entered)(UserField* self) throw();
			int (CLOOP_CARG *specified)(UserField* self) throw();
			void (CLOOP_CARG *setEntered)(UserField* self, Status* status, int newValue) throw();
		};

	protected:
		UserField(DoNotInherit)
			: Versioned(DoNotInherit())
		{
		}

		~UserField()
		{
		}

	public:
		static const unsigned VERSION = 2;

		int entered()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->entered(this);
			return ret;
		}

		int specified()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->specified(this);
			return ret;
		}

		void setEntered(Status* status, int newValue)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->setEntered(this, status2, newValue);
			Policy::checkException(status2);
		}
	};

	class CharUserField : public UserField
	{
	public:
		struct VTable : public UserField::VTable
		{
			const char* (CLOOP_CARG *get)(CharUserField* self) throw();
			void (CLOOP_CARG *set)(CharUserField* self, Status* status, const char* newValue) throw();
		};

	protected:
		CharUserField(DoNotInherit)
			: UserField(DoNotInherit())
		{
		}

		~CharUserField()
		{
		}

	public:
		static const unsigned VERSION = 3;

		const char* get()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->get(this);
			return ret;
		}

		void set(Status* status, const char* newValue)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->set(this, status2, newValue);
			Policy::checkException(status2);
		}
	};

	class IntUserField : public UserField
	{
	public:
		struct VTable : public UserField::VTable
		{
			int (CLOOP_CARG *get)(IntUserField* self) throw();
			void (CLOOP_CARG *set)(IntUserField* self, Status* status, int newValue) throw();
		};

	protected:
		IntUserField(DoNotInherit)
			: UserField(DoNotInherit())
		{
		}

		~IntUserField()
		{
		}

	public:
		static const unsigned VERSION = 3;

		int get()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->get(this);
			return ret;
		}

		void set(Status* status, int newValue)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->set(this, status2, newValue);
			Policy::checkException(status2);
		}
	};

	class User : public Versioned
	{
	public:
		struct VTable : public Versioned::VTable
		{
			int (CLOOP_CARG *operation)(User* self) throw();
			CharUserField* (CLOOP_CARG *userName)(User* self) throw();
			CharUserField* (CLOOP_CARG *password)(User* self) throw();
			CharUserField* (CLOOP_CARG *firstName)(User* self) throw();
			CharUserField* (CLOOP_CARG *lastName)(User* self) throw();
			CharUserField* (CLOOP_CARG *middleName)(User* self) throw();
			CharUserField* (CLOOP_CARG *comment)(User* self) throw();
			CharUserField* (CLOOP_CARG *attributes)(User* self) throw();
			IntUserField* (CLOOP_CARG *active)(User* self) throw();
			IntUserField* (CLOOP_CARG *admin)(User* self) throw();
			void (CLOOP_CARG *clear)(User* self, Status* status) throw();
		};

	protected:
		User(DoNotInherit)
			: Versioned(DoNotInherit())
		{
		}

		~User()
		{
		}

	public:
		static const unsigned VERSION = 2;

		int operation()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->operation(this);
			return ret;
		}

		CharUserField* userName()
		{
			CharUserField* ret = static_cast<VTable*>(this->cloopVTable)->userName(this);
			return ret;
		}

		CharUserField* password()
		{
			CharUserField* ret = static_cast<VTable*>(this->cloopVTable)->password(this);
			return ret;
		}

		CharUserField* firstName()
		{
			CharUserField* ret = static_cast<VTable*>(this->cloopVTable)->firstName(this);
			return ret;
		}

		CharUserField* lastName()
		{
			CharUserField* ret = static_cast<VTable*>(this->cloopVTable)->lastName(this);
			return ret;
		}

		CharUserField* middleName()
		{
			CharUserField* ret = static_cast<VTable*>(this->cloopVTable)->middleName(this);
			return ret;
		}

		CharUserField* comment()
		{
			CharUserField* ret = static_cast<VTable*>(this->cloopVTable)->comment(this);
			return ret;
		}

		CharUserField* attributes()
		{
			CharUserField* ret = static_cast<VTable*>(this->cloopVTable)->attributes(this);
			return ret;
		}

		IntUserField* active()
		{
			IntUserField* ret = static_cast<VTable*>(this->cloopVTable)->active(this);
			return ret;
		}

		IntUserField* admin()
		{
			IntUserField* ret = static_cast<VTable*>(this->cloopVTable)->admin(this);
			return ret;
		}

		void clear(Status* status)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->clear(this, status2);
			Policy::checkException(status2);
		}
	};

	class ListUsers : public Versioned
	{
	public:
		struct VTable : public Versioned::VTable
		{
			void (CLOOP_CARG *list)(ListUsers* self, Status* status, User* user) throw();
		};

	protected:
		ListUsers(DoNotInherit)
			: Versioned(DoNotInherit())
		{
		}

		~ListUsers()
		{
		}

	public:
		static const unsigned VERSION = 2;

		void list(Status* status, User* user)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->list(this, status2, user);
			Policy::checkException(status2);
		}
	};

	class LogonInfo : public Versioned
	{
	public:
		struct VTable : public Versioned::VTable
		{
			const char* (CLOOP_CARG *name)(LogonInfo* self) throw();
			const char* (CLOOP_CARG *role)(LogonInfo* self) throw();
			const char* (CLOOP_CARG *networkProtocol)(LogonInfo* self) throw();
			const char* (CLOOP_CARG *remoteAddress)(LogonInfo* self) throw();
			const unsigned char* (CLOOP_CARG *authBlock)(LogonInfo* self, unsigned* length) throw();
		};

	protected:
		LogonInfo(DoNotInherit)
			: Versioned(DoNotInherit())
		{
		}

		~LogonInfo()
		{
		}

	public:
		static const unsigned VERSION = 2;

		const char* name()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->name(this);
			return ret;
		}

		const char* role()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->role(this);
			return ret;
		}

		const char* networkProtocol()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->networkProtocol(this);
			return ret;
		}

		const char* remoteAddress()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->remoteAddress(this);
			return ret;
		}

		const unsigned char* authBlock(unsigned* length)
		{
			const unsigned char* ret = static_cast<VTable*>(this->cloopVTable)->authBlock(this, length);
			return ret;
		}
	};

	class Management : public PluginBase
	{
	public:
		struct VTable : public PluginBase::VTable
		{
			void (CLOOP_CARG *start)(Management* self, Status* status, LogonInfo* logonInfo) throw();
			int (CLOOP_CARG *execute)(Management* self, Status* status, User* user, ListUsers* callback) throw();
			void (CLOOP_CARG *commit)(Management* self, Status* status) throw();
			void (CLOOP_CARG *rollback)(Management* self, Status* status) throw();
		};

	protected:
		Management(DoNotInherit)
			: PluginBase(DoNotInherit())
		{
		}

		~Management()
		{
		}

	public:
		static const unsigned VERSION = 4;

		void start(Status* status, LogonInfo* logonInfo)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->start(this, status2, logonInfo);
			Policy::checkException(status2);
		}

		int execute(Status* status, User* user, ListUsers* callback)
		{
			typename Policy::Status status2(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->execute(this, status2, user, callback);
			Policy::checkException(status2);
			return ret;
		}

		void commit(Status* status)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->commit(this, status2);
			Policy::checkException(status2);
		}

		void rollback(Status* status)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->rollback(this, status2);
			Policy::checkException(status2);
		}
	};

	class WireCryptPlugin : public PluginBase
	{
	public:
		struct VTable : public PluginBase::VTable
		{
			const char* (CLOOP_CARG *getKnownTypes)(WireCryptPlugin* self, Status* status) throw();
			void (CLOOP_CARG *setKey)(WireCryptPlugin* self, Status* status, FbCryptKey* key) throw();
			void (CLOOP_CARG *encrypt)(WireCryptPlugin* self, Status* status, unsigned length, const void* from, void* to) throw();
			void (CLOOP_CARG *decrypt)(WireCryptPlugin* self, Status* status, unsigned length, const void* from, void* to) throw();
		};

	protected:
		WireCryptPlugin(DoNotInherit)
			: PluginBase(DoNotInherit())
		{
		}

		~WireCryptPlugin()
		{
		}

	public:
		static const unsigned VERSION = 4;

		const char* getKnownTypes(Status* status)
		{
			typename Policy::Status status2(status);
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getKnownTypes(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		void setKey(Status* status, FbCryptKey* key)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->setKey(this, status2, key);
			Policy::checkException(status2);
		}

		void encrypt(Status* status, unsigned length, const void* from, void* to)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->encrypt(this, status2, length, from, to);
			Policy::checkException(status2);
		}

		void decrypt(Status* status, unsigned length, const void* from, void* to)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->decrypt(this, status2, length, from, to);
			Policy::checkException(status2);
		}
	};

	class CryptKeyCallback : public Versioned
	{
	public:
		struct VTable : public Versioned::VTable
		{
			unsigned (CLOOP_CARG *callback)(CryptKeyCallback* self, unsigned dataLength, const void* data, unsigned bufferLength, void* buffer) throw();
		};

	protected:
		CryptKeyCallback(DoNotInherit)
			: Versioned(DoNotInherit())
		{
		}

		~CryptKeyCallback()
		{
		}

	public:
		static const unsigned VERSION = 2;

		unsigned callback(unsigned dataLength, const void* data, unsigned bufferLength, void* buffer)
		{
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->callback(this, dataLength, data, bufferLength, buffer);
			return ret;
		}
	};

	class KeyHolderPlugin : public PluginBase
	{
	public:
		struct VTable : public PluginBase::VTable
		{
			int (CLOOP_CARG *keyCallback)(KeyHolderPlugin* self, Status* status, CryptKeyCallback* callback) throw();
			CryptKeyCallback* (CLOOP_CARG *keyHandle)(KeyHolderPlugin* self, Status* status, const char* keyName) throw();
		};

	protected:
		KeyHolderPlugin(DoNotInherit)
			: PluginBase(DoNotInherit())
		{
		}

		~KeyHolderPlugin()
		{
		}

	public:
		static const unsigned VERSION = 4;

		int keyCallback(Status* status, CryptKeyCallback* callback)
		{
			typename Policy::Status status2(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->keyCallback(this, status2, callback);
			Policy::checkException(status2);
			return ret;
		}

		CryptKeyCallback* keyHandle(Status* status, const char* keyName)
		{
			typename Policy::Status status2(status);
			CryptKeyCallback* ret = static_cast<VTable*>(this->cloopVTable)->keyHandle(this, status2, keyName);
			Policy::checkException(status2);
			return ret;
		}
	};

	class DbCryptPlugin : public PluginBase
	{
	public:
		struct VTable : public PluginBase::VTable
		{
			void (CLOOP_CARG *setKey)(DbCryptPlugin* self, Status* status, unsigned length, KeyHolderPlugin** sources) throw();
			void (CLOOP_CARG *encrypt)(DbCryptPlugin* self, Status* status, unsigned length, const void* from, void* to) throw();
			void (CLOOP_CARG *decrypt)(DbCryptPlugin* self, Status* status, unsigned length, const void* from, void* to) throw();
		};

	protected:
		DbCryptPlugin(DoNotInherit)
			: PluginBase(DoNotInherit())
		{
		}

		~DbCryptPlugin()
		{
		}

	public:
		static const unsigned VERSION = 4;

		void setKey(Status* status, unsigned length, KeyHolderPlugin** sources)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->setKey(this, status2, length, sources);
			Policy::checkException(status2);
		}

		void encrypt(Status* status, unsigned length, const void* from, void* to)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->encrypt(this, status2, length, from, to);
			Policy::checkException(status2);
		}

		void decrypt(Status* status, unsigned length, const void* from, void* to)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->decrypt(this, status2, length, from, to);
			Policy::checkException(status2);
		}
	};

	class ExternalContext : public Versioned
	{
	public:
		struct VTable : public Versioned::VTable
		{
			Master* (CLOOP_CARG *getMaster)(ExternalContext* self) throw();
			ExternalEngine* (CLOOP_CARG *getEngine)(ExternalContext* self, Status* status) throw();
			Attachment* (CLOOP_CARG *getAttachment)(ExternalContext* self, Status* status) throw();
			Transaction* (CLOOP_CARG *getTransaction)(ExternalContext* self, Status* status) throw();
			const char* (CLOOP_CARG *getUserName)(ExternalContext* self) throw();
			const char* (CLOOP_CARG *getDatabaseName)(ExternalContext* self) throw();
			const char* (CLOOP_CARG *getClientCharSet)(ExternalContext* self) throw();
			int (CLOOP_CARG *obtainInfoCode)(ExternalContext* self) throw();
			void* (CLOOP_CARG *getInfo)(ExternalContext* self, int code) throw();
			void* (CLOOP_CARG *setInfo)(ExternalContext* self, int code, void* value) throw();
		};

	protected:
		ExternalContext(DoNotInherit)
			: Versioned(DoNotInherit())
		{
		}

		~ExternalContext()
		{
		}

	public:
		static const unsigned VERSION = 2;

		Master* getMaster()
		{
			Master* ret = static_cast<VTable*>(this->cloopVTable)->getMaster(this);
			return ret;
		}

		ExternalEngine* getEngine(Status* status)
		{
			typename Policy::Status status2(status);
			ExternalEngine* ret = static_cast<VTable*>(this->cloopVTable)->getEngine(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		Attachment* getAttachment(Status* status)
		{
			typename Policy::Status status2(status);
			Attachment* ret = static_cast<VTable*>(this->cloopVTable)->getAttachment(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		Transaction* getTransaction(Status* status)
		{
			typename Policy::Status status2(status);
			Transaction* ret = static_cast<VTable*>(this->cloopVTable)->getTransaction(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		const char* getUserName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getUserName(this);
			return ret;
		}

		const char* getDatabaseName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getDatabaseName(this);
			return ret;
		}

		const char* getClientCharSet()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getClientCharSet(this);
			return ret;
		}

		int obtainInfoCode()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->obtainInfoCode(this);
			return ret;
		}

		void* getInfo(int code)
		{
			void* ret = static_cast<VTable*>(this->cloopVTable)->getInfo(this, code);
			return ret;
		}

		void* setInfo(int code, void* value)
		{
			void* ret = static_cast<VTable*>(this->cloopVTable)->setInfo(this, code, value);
			return ret;
		}
	};

	class ExternalResultSet : public Disposable
	{
	public:
		struct VTable : public Disposable::VTable
		{
			FB_BOOLEAN (CLOOP_CARG *fetch)(ExternalResultSet* self, Status* status) throw();
		};

	protected:
		ExternalResultSet(DoNotInherit)
			: Disposable(DoNotInherit())
		{
		}

		~ExternalResultSet()
		{
		}

	public:
		static const unsigned VERSION = 3;

		FB_BOOLEAN fetch(Status* status)
		{
			typename Policy::Status status2(status);
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->fetch(this, status2);
			Policy::checkException(status2);
			return ret;
		}
	};

	class ExternalFunction : public Disposable
	{
	public:
		struct VTable : public Disposable::VTable
		{
			void (CLOOP_CARG *getCharSet)(ExternalFunction* self, Status* status, ExternalContext* context, char* name, unsigned nameSize) throw();
			void (CLOOP_CARG *execute)(ExternalFunction* self, Status* status, ExternalContext* context, void* inMsg, void* outMsg) throw();
		};

	protected:
		ExternalFunction(DoNotInherit)
			: Disposable(DoNotInherit())
		{
		}

		~ExternalFunction()
		{
		}

	public:
		static const unsigned VERSION = 3;

		void getCharSet(Status* status, ExternalContext* context, char* name, unsigned nameSize)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->getCharSet(this, status2, context, name, nameSize);
			Policy::checkException(status2);
		}

		void execute(Status* status, ExternalContext* context, void* inMsg, void* outMsg)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->execute(this, status2, context, inMsg, outMsg);
			Policy::checkException(status2);
		}
	};

	class ExternalProcedure : public Disposable
	{
	public:
		struct VTable : public Disposable::VTable
		{
			void (CLOOP_CARG *getCharSet)(ExternalProcedure* self, Status* status, ExternalContext* context, char* name, unsigned nameSize) throw();
			ExternalResultSet* (CLOOP_CARG *open)(ExternalProcedure* self, Status* status, ExternalContext* context, void* inMsg, void* outMsg) throw();
		};

	protected:
		ExternalProcedure(DoNotInherit)
			: Disposable(DoNotInherit())
		{
		}

		~ExternalProcedure()
		{
		}

	public:
		static const unsigned VERSION = 3;

		void getCharSet(Status* status, ExternalContext* context, char* name, unsigned nameSize)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->getCharSet(this, status2, context, name, nameSize);
			Policy::checkException(status2);
		}

		ExternalResultSet* open(Status* status, ExternalContext* context, void* inMsg, void* outMsg)
		{
			typename Policy::Status status2(status);
			ExternalResultSet* ret = static_cast<VTable*>(this->cloopVTable)->open(this, status2, context, inMsg, outMsg);
			Policy::checkException(status2);
			return ret;
		}
	};

	class ExternalTrigger : public Disposable
	{
	public:
		struct VTable : public Disposable::VTable
		{
			void (CLOOP_CARG *getCharSet)(ExternalTrigger* self, Status* status, ExternalContext* context, char* name, unsigned nameSize) throw();
			void (CLOOP_CARG *execute)(ExternalTrigger* self, Status* status, ExternalContext* context, unsigned action, void* oldMsg, void* newMsg) throw();
		};

	protected:
		ExternalTrigger(DoNotInherit)
			: Disposable(DoNotInherit())
		{
		}

		~ExternalTrigger()
		{
		}

	public:
		static const unsigned VERSION = 3;

		static const unsigned TYPE_BEFORE = 1;
		static const unsigned TYPE_AFTER = 2;
		static const unsigned TYPE_DATABASE = 3;
		static const unsigned ACTION_INSERT = 1;
		static const unsigned ACTION_UPDATE = 2;
		static const unsigned ACTION_DELETE = 3;
		static const unsigned ACTION_CONNECT = 4;
		static const unsigned ACTION_DISCONNECT = 5;
		static const unsigned ACTION_TRANS_START = 6;
		static const unsigned ACTION_TRANS_COMMIT = 7;
		static const unsigned ACTION_TRANS_ROLLBACK = 8;
		static const unsigned ACTION_DDL = 9;

		void getCharSet(Status* status, ExternalContext* context, char* name, unsigned nameSize)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->getCharSet(this, status2, context, name, nameSize);
			Policy::checkException(status2);
		}

		void execute(Status* status, ExternalContext* context, unsigned action, void* oldMsg, void* newMsg)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->execute(this, status2, context, action, oldMsg, newMsg);
			Policy::checkException(status2);
		}
	};

	class RoutineMetadata : public Versioned
	{
	public:
		struct VTable : public Versioned::VTable
		{
			const char* (CLOOP_CARG *getPackage)(const RoutineMetadata* self, Status* status) throw();
			const char* (CLOOP_CARG *getName)(const RoutineMetadata* self, Status* status) throw();
			const char* (CLOOP_CARG *getEntryPoint)(const RoutineMetadata* self, Status* status) throw();
			const char* (CLOOP_CARG *getBody)(const RoutineMetadata* self, Status* status) throw();
			MessageMetadata* (CLOOP_CARG *getInputMetadata)(const RoutineMetadata* self, Status* status) throw();
			MessageMetadata* (CLOOP_CARG *getOutputMetadata)(const RoutineMetadata* self, Status* status) throw();
			MessageMetadata* (CLOOP_CARG *getTriggerMetadata)(const RoutineMetadata* self, Status* status) throw();
			const char* (CLOOP_CARG *getTriggerTable)(const RoutineMetadata* self, Status* status) throw();
			unsigned (CLOOP_CARG *getTriggerType)(const RoutineMetadata* self, Status* status) throw();
		};

	protected:
		RoutineMetadata(DoNotInherit)
			: Versioned(DoNotInherit())
		{
		}

		~RoutineMetadata()
		{
		}

	public:
		static const unsigned VERSION = 2;

		const char* getPackage(Status* status) const
		{
			typename Policy::Status status2(status);
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getPackage(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		const char* getName(Status* status) const
		{
			typename Policy::Status status2(status);
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getName(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		const char* getEntryPoint(Status* status) const
		{
			typename Policy::Status status2(status);
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getEntryPoint(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		const char* getBody(Status* status) const
		{
			typename Policy::Status status2(status);
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getBody(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		MessageMetadata* getInputMetadata(Status* status) const
		{
			typename Policy::Status status2(status);
			MessageMetadata* ret = static_cast<VTable*>(this->cloopVTable)->getInputMetadata(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		MessageMetadata* getOutputMetadata(Status* status) const
		{
			typename Policy::Status status2(status);
			MessageMetadata* ret = static_cast<VTable*>(this->cloopVTable)->getOutputMetadata(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		MessageMetadata* getTriggerMetadata(Status* status) const
		{
			typename Policy::Status status2(status);
			MessageMetadata* ret = static_cast<VTable*>(this->cloopVTable)->getTriggerMetadata(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		const char* getTriggerTable(Status* status) const
		{
			typename Policy::Status status2(status);
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getTriggerTable(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		unsigned getTriggerType(Status* status) const
		{
			typename Policy::Status status2(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getTriggerType(this, status2);
			Policy::checkException(status2);
			return ret;
		}
	};

	class ExternalEngine : public PluginBase
	{
	public:
		struct VTable : public PluginBase::VTable
		{
			void (CLOOP_CARG *open)(ExternalEngine* self, Status* status, ExternalContext* context, char* charSet, unsigned charSetSize) throw();
			void (CLOOP_CARG *openAttachment)(ExternalEngine* self, Status* status, ExternalContext* context) throw();
			void (CLOOP_CARG *closeAttachment)(ExternalEngine* self, Status* status, ExternalContext* context) throw();
			ExternalFunction* (CLOOP_CARG *makeFunction)(ExternalEngine* self, Status* status, ExternalContext* context, RoutineMetadata* metadata, MetadataBuilder* inBuilder, MetadataBuilder* outBuilder) throw();
			ExternalProcedure* (CLOOP_CARG *makeProcedure)(ExternalEngine* self, Status* status, ExternalContext* context, RoutineMetadata* metadata, MetadataBuilder* inBuilder, MetadataBuilder* outBuilder) throw();
			ExternalTrigger* (CLOOP_CARG *makeTrigger)(ExternalEngine* self, Status* status, ExternalContext* context, RoutineMetadata* metadata, MetadataBuilder* fieldsBuilder) throw();
		};

	protected:
		ExternalEngine(DoNotInherit)
			: PluginBase(DoNotInherit())
		{
		}

		~ExternalEngine()
		{
		}

	public:
		static const unsigned VERSION = 4;

		void open(Status* status, ExternalContext* context, char* charSet, unsigned charSetSize)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->open(this, status2, context, charSet, charSetSize);
			Policy::checkException(status2);
		}

		void openAttachment(Status* status, ExternalContext* context)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->openAttachment(this, status2, context);
			Policy::checkException(status2);
		}

		void closeAttachment(Status* status, ExternalContext* context)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->closeAttachment(this, status2, context);
			Policy::checkException(status2);
		}

		ExternalFunction* makeFunction(Status* status, ExternalContext* context, RoutineMetadata* metadata, MetadataBuilder* inBuilder, MetadataBuilder* outBuilder)
		{
			typename Policy::Status status2(status);
			ExternalFunction* ret = static_cast<VTable*>(this->cloopVTable)->makeFunction(this, status2, context, metadata, inBuilder, outBuilder);
			Policy::checkException(status2);
			return ret;
		}

		ExternalProcedure* makeProcedure(Status* status, ExternalContext* context, RoutineMetadata* metadata, MetadataBuilder* inBuilder, MetadataBuilder* outBuilder)
		{
			typename Policy::Status status2(status);
			ExternalProcedure* ret = static_cast<VTable*>(this->cloopVTable)->makeProcedure(this, status2, context, metadata, inBuilder, outBuilder);
			Policy::checkException(status2);
			return ret;
		}

		ExternalTrigger* makeTrigger(Status* status, ExternalContext* context, RoutineMetadata* metadata, MetadataBuilder* fieldsBuilder)
		{
			typename Policy::Status status2(status);
			ExternalTrigger* ret = static_cast<VTable*>(this->cloopVTable)->makeTrigger(this, status2, context, metadata, fieldsBuilder);
			Policy::checkException(status2);
			return ret;
		}
	};

	class Timer : public ReferenceCounted
	{
	public:
		struct VTable : public ReferenceCounted::VTable
		{
			void (CLOOP_CARG *handler)(Timer* self) throw();
		};

	protected:
		Timer(DoNotInherit)
			: ReferenceCounted(DoNotInherit())
		{
		}

		~Timer()
		{
		}

	public:
		static const unsigned VERSION = 3;

		void handler()
		{
			static_cast<VTable*>(this->cloopVTable)->handler(this);
		}
	};

	class TimerControl : public Versioned
	{
	public:
		struct VTable : public Versioned::VTable
		{
			void (CLOOP_CARG *start)(TimerControl* self, Status* status, Timer* timer, ISC_UINT64 microSeconds) throw();
			void (CLOOP_CARG *stop)(TimerControl* self, Status* status, Timer* timer) throw();
		};

	protected:
		TimerControl(DoNotInherit)
			: Versioned(DoNotInherit())
		{
		}

		~TimerControl()
		{
		}

	public:
		static const unsigned VERSION = 2;

		void start(Status* status, Timer* timer, ISC_UINT64 microSeconds)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->start(this, status2, timer, microSeconds);
			Policy::checkException(status2);
		}

		void stop(Status* status, Timer* timer)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->stop(this, status2, timer);
			Policy::checkException(status2);
		}
	};

	class VersionCallback : public Versioned
	{
	public:
		struct VTable : public Versioned::VTable
		{
			void (CLOOP_CARG *callback)(VersionCallback* self, Status* status, const char* text) throw();
		};

	protected:
		VersionCallback(DoNotInherit)
			: Versioned(DoNotInherit())
		{
		}

		~VersionCallback()
		{
		}

	public:
		static const unsigned VERSION = 2;

		void callback(Status* status, const char* text)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->callback(this, status2, text);
			Policy::checkException(status2);
		}
	};

	class Utl : public Versioned
	{
	public:
		struct VTable : public Versioned::VTable
		{
			void (CLOOP_CARG *getFbVersion)(Utl* self, Status* status, Attachment* att, VersionCallback* callback) throw();
			void (CLOOP_CARG *loadBlob)(Utl* self, Status* status, ISC_QUAD* blobId, Attachment* att, Transaction* tra, const char* file, FB_BOOLEAN txt) throw();
			void (CLOOP_CARG *dumpBlob)(Utl* self, Status* status, ISC_QUAD* blobId, Attachment* att, Transaction* tra, const char* file, FB_BOOLEAN txt) throw();
			void (CLOOP_CARG *getPerfCounters)(Utl* self, Status* status, Attachment* att, const char* countersSet, ISC_INT64* counters) throw();
			Attachment* (CLOOP_CARG *executeCreateDatabase)(Utl* self, Status* status, unsigned stmtLength, const char* creatDBstatement, unsigned dialect, FB_BOOLEAN* stmtIsCreateDb) throw();
		};

	protected:
		Utl(DoNotInherit)
			: Versioned(DoNotInherit())
		{
		}

		~Utl()
		{
		}

	public:
		static const unsigned VERSION = 2;

		void getFbVersion(Status* status, Attachment* att, VersionCallback* callback)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->getFbVersion(this, status2, att, callback);
			Policy::checkException(status2);
		}

		void loadBlob(Status* status, ISC_QUAD* blobId, Attachment* att, Transaction* tra, const char* file, FB_BOOLEAN txt)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->loadBlob(this, status2, blobId, att, tra, file, txt);
			Policy::checkException(status2);
		}

		void dumpBlob(Status* status, ISC_QUAD* blobId, Attachment* att, Transaction* tra, const char* file, FB_BOOLEAN txt)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->dumpBlob(this, status2, blobId, att, tra, file, txt);
			Policy::checkException(status2);
		}

		void getPerfCounters(Status* status, Attachment* att, const char* countersSet, ISC_INT64* counters)
		{
			typename Policy::Status status2(status);
			static_cast<VTable*>(this->cloopVTable)->getPerfCounters(this, status2, att, countersSet, counters);
			Policy::checkException(status2);
		}

		Attachment* executeCreateDatabase(Status* status, unsigned stmtLength, const char* creatDBstatement, unsigned dialect, FB_BOOLEAN* stmtIsCreateDb)
		{
			typename Policy::Status status2(status);
			Attachment* ret = static_cast<VTable*>(this->cloopVTable)->executeCreateDatabase(this, status2, stmtLength, creatDBstatement, dialect, stmtIsCreateDb);
			Policy::checkException(status2);
			return ret;
		}
	};

	class TraceConnection : public Versioned
	{
	public:
		struct VTable : public Versioned::VTable
		{
			unsigned (CLOOP_CARG *getKind)(TraceConnection* self) throw();
			int (CLOOP_CARG *getProcessID)(TraceConnection* self) throw();
			const char* (CLOOP_CARG *getUserName)(TraceConnection* self) throw();
			const char* (CLOOP_CARG *getRoleName)(TraceConnection* self) throw();
			const char* (CLOOP_CARG *getCharSet)(TraceConnection* self) throw();
			const char* (CLOOP_CARG *getRemoteProtocol)(TraceConnection* self) throw();
			const char* (CLOOP_CARG *getRemoteAddress)(TraceConnection* self) throw();
			int (CLOOP_CARG *getRemoteProcessID)(TraceConnection* self) throw();
			const char* (CLOOP_CARG *getRemoteProcessName)(TraceConnection* self) throw();
		};

	protected:
		TraceConnection(DoNotInherit)
			: Versioned(DoNotInherit())
		{
		}

		~TraceConnection()
		{
		}

	public:
		static const unsigned VERSION = 2;

		static const unsigned TRACE_CONNECTION_DATABASE = 1;
		static const unsigned TRACE_CONNECTION_SERVICE = 2;

		unsigned getKind()
		{
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getKind(this);
			return ret;
		}

		int getProcessID()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->getProcessID(this);
			return ret;
		}

		const char* getUserName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getUserName(this);
			return ret;
		}

		const char* getRoleName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getRoleName(this);
			return ret;
		}

		const char* getCharSet()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getCharSet(this);
			return ret;
		}

		const char* getRemoteProtocol()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getRemoteProtocol(this);
			return ret;
		}

		const char* getRemoteAddress()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getRemoteAddress(this);
			return ret;
		}

		int getRemoteProcessID()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->getRemoteProcessID(this);
			return ret;
		}

		const char* getRemoteProcessName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getRemoteProcessName(this);
			return ret;
		}
	};

	class TraceDatabaseConnection : public TraceConnection
	{
	public:
		struct VTable : public TraceConnection::VTable
		{
			int (CLOOP_CARG *getConnectionID)(TraceDatabaseConnection* self) throw();
			const char* (CLOOP_CARG *getDatabaseName)(TraceDatabaseConnection* self) throw();
		};

	protected:
		TraceDatabaseConnection(DoNotInherit)
			: TraceConnection(DoNotInherit())
		{
		}

		~TraceDatabaseConnection()
		{
		}

	public:
		static const unsigned VERSION = 3;

		int getConnectionID()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->getConnectionID(this);
			return ret;
		}

		const char* getDatabaseName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getDatabaseName(this);
			return ret;
		}
	};

	class TraceTransaction : public Versioned
	{
	public:
		struct VTable : public Versioned::VTable
		{
			unsigned (CLOOP_CARG *getTransactionID)(TraceTransaction* self) throw();
			FB_BOOLEAN (CLOOP_CARG *getReadOnly)(TraceTransaction* self) throw();
			int (CLOOP_CARG *getWait)(TraceTransaction* self) throw();
			unsigned (CLOOP_CARG *getIsolation)(TraceTransaction* self) throw();
			PerformanceInfo* (CLOOP_CARG *getPerf)(TraceTransaction* self) throw();
		};

	protected:
		TraceTransaction(DoNotInherit)
			: Versioned(DoNotInherit())
		{
		}

		~TraceTransaction()
		{
		}

	public:
		static const unsigned VERSION = 2;

		static const unsigned TRA_ISO_CONSISTENCY = 1;
		static const unsigned TRA_ISO_CONCURRENCY = 2;
		static const unsigned TRA_ISO_READ_COMMITTED_RECVER = 3;
		static const unsigned TRA_ISO_READ_COMMITTED_NORECVER = 4;

		unsigned getTransactionID()
		{
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getTransactionID(this);
			return ret;
		}

		FB_BOOLEAN getReadOnly()
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->getReadOnly(this);
			return ret;
		}

		int getWait()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->getWait(this);
			return ret;
		}

		unsigned getIsolation()
		{
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getIsolation(this);
			return ret;
		}

		PerformanceInfo* getPerf()
		{
			PerformanceInfo* ret = static_cast<VTable*>(this->cloopVTable)->getPerf(this);
			return ret;
		}
	};

	class TraceParams : public Versioned
	{
	public:
		struct VTable : public Versioned::VTable
		{
			unsigned (CLOOP_CARG *getCount)(TraceParams* self) throw();
			const dsc* (CLOOP_CARG *getParam)(TraceParams* self, unsigned idx) throw();
		};

	protected:
		TraceParams(DoNotInherit)
			: Versioned(DoNotInherit())
		{
		}

		~TraceParams()
		{
		}

	public:
		static const unsigned VERSION = 2;

		unsigned getCount()
		{
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getCount(this);
			return ret;
		}

		const dsc* getParam(unsigned idx)
		{
			const dsc* ret = static_cast<VTable*>(this->cloopVTable)->getParam(this, idx);
			return ret;
		}
	};

	class TraceStatement : public Versioned
	{
	public:
		struct VTable : public Versioned::VTable
		{
			int (CLOOP_CARG *getStmtID)(TraceStatement* self) throw();
			PerformanceInfo* (CLOOP_CARG *getPerf)(TraceStatement* self) throw();
		};

	protected:
		TraceStatement(DoNotInherit)
			: Versioned(DoNotInherit())
		{
		}

		~TraceStatement()
		{
		}

	public:
		static const unsigned VERSION = 2;

		int getStmtID()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->getStmtID(this);
			return ret;
		}

		PerformanceInfo* getPerf()
		{
			PerformanceInfo* ret = static_cast<VTable*>(this->cloopVTable)->getPerf(this);
			return ret;
		}
	};

	class TraceSQLStatement : public TraceStatement
	{
	public:
		struct VTable : public TraceStatement::VTable
		{
			const char* (CLOOP_CARG *getText)(TraceSQLStatement* self) throw();
			const char* (CLOOP_CARG *getPlan)(TraceSQLStatement* self) throw();
			TraceParams* (CLOOP_CARG *getInputs)(TraceSQLStatement* self) throw();
			const char* (CLOOP_CARG *getTextUTF8)(TraceSQLStatement* self) throw();
			const char* (CLOOP_CARG *getExplainedPlan)(TraceSQLStatement* self) throw();
		};

	protected:
		TraceSQLStatement(DoNotInherit)
			: TraceStatement(DoNotInherit())
		{
		}

		~TraceSQLStatement()
		{
		}

	public:
		static const unsigned VERSION = 3;

		const char* getText()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getText(this);
			return ret;
		}

		const char* getPlan()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getPlan(this);
			return ret;
		}

		TraceParams* getInputs()
		{
			TraceParams* ret = static_cast<VTable*>(this->cloopVTable)->getInputs(this);
			return ret;
		}

		const char* getTextUTF8()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getTextUTF8(this);
			return ret;
		}

		const char* getExplainedPlan()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getExplainedPlan(this);
			return ret;
		}
	};

	class TraceBLRStatement : public TraceStatement
	{
	public:
		struct VTable : public TraceStatement::VTable
		{
			const unsigned char* (CLOOP_CARG *getData)(TraceBLRStatement* self) throw();
			unsigned (CLOOP_CARG *getDataLength)(TraceBLRStatement* self) throw();
			const char* (CLOOP_CARG *getText)(TraceBLRStatement* self) throw();
		};

	protected:
		TraceBLRStatement(DoNotInherit)
			: TraceStatement(DoNotInherit())
		{
		}

		~TraceBLRStatement()
		{
		}

	public:
		static const unsigned VERSION = 3;

		const unsigned char* getData()
		{
			const unsigned char* ret = static_cast<VTable*>(this->cloopVTable)->getData(this);
			return ret;
		}

		unsigned getDataLength()
		{
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getDataLength(this);
			return ret;
		}

		const char* getText()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getText(this);
			return ret;
		}
	};

	class TraceDYNRequest : public Versioned
	{
	public:
		struct VTable : public Versioned::VTable
		{
			const unsigned char* (CLOOP_CARG *getData)(TraceDYNRequest* self) throw();
			unsigned (CLOOP_CARG *getDataLength)(TraceDYNRequest* self) throw();
			const char* (CLOOP_CARG *getText)(TraceDYNRequest* self) throw();
		};

	protected:
		TraceDYNRequest(DoNotInherit)
			: Versioned(DoNotInherit())
		{
		}

		~TraceDYNRequest()
		{
		}

	public:
		static const unsigned VERSION = 2;

		const unsigned char* getData()
		{
			const unsigned char* ret = static_cast<VTable*>(this->cloopVTable)->getData(this);
			return ret;
		}

		unsigned getDataLength()
		{
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getDataLength(this);
			return ret;
		}

		const char* getText()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getText(this);
			return ret;
		}
	};

	class TraceContextVariable : public Versioned
	{
	public:
		struct VTable : public Versioned::VTable
		{
			const char* (CLOOP_CARG *getNameSpace)(TraceContextVariable* self) throw();
			const char* (CLOOP_CARG *getVarName)(TraceContextVariable* self) throw();
			const char* (CLOOP_CARG *getVarValue)(TraceContextVariable* self) throw();
		};

	protected:
		TraceContextVariable(DoNotInherit)
			: Versioned(DoNotInherit())
		{
		}

		~TraceContextVariable()
		{
		}

	public:
		static const unsigned VERSION = 2;

		const char* getNameSpace()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getNameSpace(this);
			return ret;
		}

		const char* getVarName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getVarName(this);
			return ret;
		}

		const char* getVarValue()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getVarValue(this);
			return ret;
		}
	};

	class TraceProcedure : public Versioned
	{
	public:
		struct VTable : public Versioned::VTable
		{
			const char* (CLOOP_CARG *getProcName)(TraceProcedure* self) throw();
			TraceParams* (CLOOP_CARG *getInputs)(TraceProcedure* self) throw();
			PerformanceInfo* (CLOOP_CARG *getPerf)(TraceProcedure* self) throw();
		};

	protected:
		TraceProcedure(DoNotInherit)
			: Versioned(DoNotInherit())
		{
		}

		~TraceProcedure()
		{
		}

	public:
		static const unsigned VERSION = 2;

		const char* getProcName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getProcName(this);
			return ret;
		}

		TraceParams* getInputs()
		{
			TraceParams* ret = static_cast<VTable*>(this->cloopVTable)->getInputs(this);
			return ret;
		}

		PerformanceInfo* getPerf()
		{
			PerformanceInfo* ret = static_cast<VTable*>(this->cloopVTable)->getPerf(this);
			return ret;
		}
	};

	class TraceFunction : public Versioned
	{
	public:
		struct VTable : public Versioned::VTable
		{
			const char* (CLOOP_CARG *getFuncName)(TraceFunction* self) throw();
			TraceParams* (CLOOP_CARG *getInputs)(TraceFunction* self) throw();
			TraceParams* (CLOOP_CARG *getResult)(TraceFunction* self) throw();
			PerformanceInfo* (CLOOP_CARG *getPerf)(TraceFunction* self) throw();
		};

	protected:
		TraceFunction(DoNotInherit)
			: Versioned(DoNotInherit())
		{
		}

		~TraceFunction()
		{
		}

	public:
		static const unsigned VERSION = 2;

		const char* getFuncName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getFuncName(this);
			return ret;
		}

		TraceParams* getInputs()
		{
			TraceParams* ret = static_cast<VTable*>(this->cloopVTable)->getInputs(this);
			return ret;
		}

		TraceParams* getResult()
		{
			TraceParams* ret = static_cast<VTable*>(this->cloopVTable)->getResult(this);
			return ret;
		}

		PerformanceInfo* getPerf()
		{
			PerformanceInfo* ret = static_cast<VTable*>(this->cloopVTable)->getPerf(this);
			return ret;
		}
	};

	class TraceTrigger : public Versioned
	{
	public:
		struct VTable : public Versioned::VTable
		{
			const char* (CLOOP_CARG *getTriggerName)(TraceTrigger* self) throw();
			const char* (CLOOP_CARG *getRelationName)(TraceTrigger* self) throw();
			int (CLOOP_CARG *getAction)(TraceTrigger* self) throw();
			int (CLOOP_CARG *getWhich)(TraceTrigger* self) throw();
			PerformanceInfo* (CLOOP_CARG *getPerf)(TraceTrigger* self) throw();
		};

	protected:
		TraceTrigger(DoNotInherit)
			: Versioned(DoNotInherit())
		{
		}

		~TraceTrigger()
		{
		}

	public:
		static const unsigned VERSION = 2;

		static const unsigned TRACE_ALL = 0;
		static const unsigned TRACE_BEFORE = 1;
		static const unsigned TRACE_AFTER = 2;

		const char* getTriggerName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getTriggerName(this);
			return ret;
		}

		const char* getRelationName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getRelationName(this);
			return ret;
		}

		int getAction()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->getAction(this);
			return ret;
		}

		int getWhich()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->getWhich(this);
			return ret;
		}

		PerformanceInfo* getPerf()
		{
			PerformanceInfo* ret = static_cast<VTable*>(this->cloopVTable)->getPerf(this);
			return ret;
		}
	};

	class TraceServiceConnection : public TraceConnection
	{
	public:
		struct VTable : public TraceConnection::VTable
		{
			void* (CLOOP_CARG *getServiceID)(TraceServiceConnection* self) throw();
			const char* (CLOOP_CARG *getServiceMgr)(TraceServiceConnection* self) throw();
			const char* (CLOOP_CARG *getServiceName)(TraceServiceConnection* self) throw();
		};

	protected:
		TraceServiceConnection(DoNotInherit)
			: TraceConnection(DoNotInherit())
		{
		}

		~TraceServiceConnection()
		{
		}

	public:
		static const unsigned VERSION = 3;

		void* getServiceID()
		{
			void* ret = static_cast<VTable*>(this->cloopVTable)->getServiceID(this);
			return ret;
		}

		const char* getServiceMgr()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getServiceMgr(this);
			return ret;
		}

		const char* getServiceName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getServiceName(this);
			return ret;
		}
	};

	class TraceStatusVector : public Versioned
	{
	public:
		struct VTable : public Versioned::VTable
		{
			FB_BOOLEAN (CLOOP_CARG *hasError)(TraceStatusVector* self) throw();
			FB_BOOLEAN (CLOOP_CARG *hasWarning)(TraceStatusVector* self) throw();
			const intptr_t* (CLOOP_CARG *getStatus)(TraceStatusVector* self) throw();
			const char* (CLOOP_CARG *getText)(TraceStatusVector* self) throw();
		};

	protected:
		TraceStatusVector(DoNotInherit)
			: Versioned(DoNotInherit())
		{
		}

		~TraceStatusVector()
		{
		}

	public:
		static const unsigned VERSION = 2;

		FB_BOOLEAN hasError()
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->hasError(this);
			return ret;
		}

		FB_BOOLEAN hasWarning()
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->hasWarning(this);
			return ret;
		}

		const intptr_t* getStatus()
		{
			const intptr_t* ret = static_cast<VTable*>(this->cloopVTable)->getStatus(this);
			return ret;
		}

		const char* getText()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getText(this);
			return ret;
		}
	};

	class TraceSweepInfo : public Versioned
	{
	public:
		struct VTable : public Versioned::VTable
		{
			ISC_UINT64 (CLOOP_CARG *getOIT)(TraceSweepInfo* self) throw();
			ISC_UINT64 (CLOOP_CARG *getOST)(TraceSweepInfo* self) throw();
			ISC_UINT64 (CLOOP_CARG *getOAT)(TraceSweepInfo* self) throw();
			ISC_UINT64 (CLOOP_CARG *getNext)(TraceSweepInfo* self) throw();
			PerformanceInfo* (CLOOP_CARG *getPerf)(TraceSweepInfo* self) throw();
		};

	protected:
		TraceSweepInfo(DoNotInherit)
			: Versioned(DoNotInherit())
		{
		}

		~TraceSweepInfo()
		{
		}

	public:
		static const unsigned VERSION = 2;

		ISC_UINT64 getOIT()
		{
			ISC_UINT64 ret = static_cast<VTable*>(this->cloopVTable)->getOIT(this);
			return ret;
		}

		ISC_UINT64 getOST()
		{
			ISC_UINT64 ret = static_cast<VTable*>(this->cloopVTable)->getOST(this);
			return ret;
		}

		ISC_UINT64 getOAT()
		{
			ISC_UINT64 ret = static_cast<VTable*>(this->cloopVTable)->getOAT(this);
			return ret;
		}

		ISC_UINT64 getNext()
		{
			ISC_UINT64 ret = static_cast<VTable*>(this->cloopVTable)->getNext(this);
			return ret;
		}

		PerformanceInfo* getPerf()
		{
			PerformanceInfo* ret = static_cast<VTable*>(this->cloopVTable)->getPerf(this);
			return ret;
		}
	};

	class TraceLogWriter : public ReferenceCounted
	{
	public:
		struct VTable : public ReferenceCounted::VTable
		{
			unsigned (CLOOP_CARG *write)(TraceLogWriter* self, const void* buf, unsigned size) throw();
		};

	protected:
		TraceLogWriter(DoNotInherit)
			: ReferenceCounted(DoNotInherit())
		{
		}

		~TraceLogWriter()
		{
		}

	public:
		static const unsigned VERSION = 3;

		unsigned write(const void* buf, unsigned size)
		{
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->write(this, buf, size);
			return ret;
		}
	};

	class TraceInitInfo : public Versioned
	{
	public:
		struct VTable : public Versioned::VTable
		{
			const char* (CLOOP_CARG *getConfigText)(TraceInitInfo* self) throw();
			int (CLOOP_CARG *getTraceSessionID)(TraceInitInfo* self) throw();
			const char* (CLOOP_CARG *getTraceSessionName)(TraceInitInfo* self) throw();
			const char* (CLOOP_CARG *getFirebirdRootDirectory)(TraceInitInfo* self) throw();
			const char* (CLOOP_CARG *getDatabaseName)(TraceInitInfo* self) throw();
			TraceDatabaseConnection* (CLOOP_CARG *getConnection)(TraceInitInfo* self) throw();
			TraceLogWriter* (CLOOP_CARG *getLogWriter)(TraceInitInfo* self) throw();
		};

	protected:
		TraceInitInfo(DoNotInherit)
			: Versioned(DoNotInherit())
		{
		}

		~TraceInitInfo()
		{
		}

	public:
		static const unsigned VERSION = 2;

		const char* getConfigText()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getConfigText(this);
			return ret;
		}

		int getTraceSessionID()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->getTraceSessionID(this);
			return ret;
		}

		const char* getTraceSessionName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getTraceSessionName(this);
			return ret;
		}

		const char* getFirebirdRootDirectory()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getFirebirdRootDirectory(this);
			return ret;
		}

		const char* getDatabaseName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getDatabaseName(this);
			return ret;
		}

		TraceDatabaseConnection* getConnection()
		{
			TraceDatabaseConnection* ret = static_cast<VTable*>(this->cloopVTable)->getConnection(this);
			return ret;
		}

		TraceLogWriter* getLogWriter()
		{
			TraceLogWriter* ret = static_cast<VTable*>(this->cloopVTable)->getLogWriter(this);
			return ret;
		}
	};

	class TracePlugin : public ReferenceCounted
	{
	public:
		struct VTable : public ReferenceCounted::VTable
		{
			const char* (CLOOP_CARG *trace_get_error)(TracePlugin* self) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_attach)(TracePlugin* self, TraceDatabaseConnection* connection, FB_BOOLEAN create_db, unsigned att_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_detach)(TracePlugin* self, TraceDatabaseConnection* connection, FB_BOOLEAN drop_db) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_transaction_start)(TracePlugin* self, TraceDatabaseConnection* connection, TraceTransaction* transaction, unsigned tpb_length, const unsigned char* tpb, unsigned tra_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_transaction_end)(TracePlugin* self, TraceDatabaseConnection* connection, TraceTransaction* transaction, FB_BOOLEAN commit, FB_BOOLEAN retain_context, unsigned tra_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_proc_execute)(TracePlugin* self, TraceDatabaseConnection* connection, TraceTransaction* transaction, TraceProcedure* procedure, FB_BOOLEAN started, unsigned proc_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_trigger_execute)(TracePlugin* self, TraceDatabaseConnection* connection, TraceTransaction* transaction, TraceTrigger* trigger, FB_BOOLEAN started, unsigned trig_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_set_context)(TracePlugin* self, TraceDatabaseConnection* connection, TraceTransaction* transaction, TraceContextVariable* variable) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_dsql_prepare)(TracePlugin* self, TraceDatabaseConnection* connection, TraceTransaction* transaction, TraceSQLStatement* statement, ISC_INT64 time_millis, unsigned req_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_dsql_free)(TracePlugin* self, TraceDatabaseConnection* connection, TraceSQLStatement* statement, unsigned option) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_dsql_execute)(TracePlugin* self, TraceDatabaseConnection* connection, TraceTransaction* transaction, TraceSQLStatement* statement, FB_BOOLEAN started, unsigned req_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_blr_compile)(TracePlugin* self, TraceDatabaseConnection* connection, TraceTransaction* transaction, TraceBLRStatement* statement, ISC_INT64 time_millis, unsigned req_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_blr_execute)(TracePlugin* self, TraceDatabaseConnection* connection, TraceTransaction* transaction, TraceBLRStatement* statement, unsigned req_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_dyn_execute)(TracePlugin* self, TraceDatabaseConnection* connection, TraceTransaction* transaction, TraceDYNRequest* request, ISC_INT64 time_millis, unsigned req_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_service_attach)(TracePlugin* self, TraceServiceConnection* service, unsigned att_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_service_start)(TracePlugin* self, TraceServiceConnection* service, unsigned switches_length, const char* switches, unsigned start_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_service_query)(TracePlugin* self, TraceServiceConnection* service, unsigned send_item_length, const unsigned char* send_items, unsigned recv_item_length, const unsigned char* recv_items, unsigned query_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_service_detach)(TracePlugin* self, TraceServiceConnection* service, unsigned detach_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_event_error)(TracePlugin* self, TraceConnection* connection, TraceStatusVector* status, const char* function) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_event_sweep)(TracePlugin* self, TraceDatabaseConnection* connection, TraceSweepInfo* sweep, unsigned sweep_state) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_func_execute)(TracePlugin* self, TraceDatabaseConnection* connection, TraceTransaction* transaction, TraceFunction* function, FB_BOOLEAN started, unsigned func_result) throw();
		};

	protected:
		TracePlugin(DoNotInherit)
			: ReferenceCounted(DoNotInherit())
		{
		}

		~TracePlugin()
		{
		}

	public:
		static const unsigned VERSION = 3;

		static const unsigned TRACE_RESULT_SUCCESS = 0;
		static const unsigned TRACE_RESULT_FAILED = 1;
		static const unsigned TRACE_RESULT_UNAUTHORIZED = 2;
		static const unsigned SWEEP_STATE_STARTED = 1;
		static const unsigned SWEEP_STATE_FINISHED = 2;
		static const unsigned SWEEP_STATE_FAILED = 3;
		static const unsigned SWEEP_STATE_PROGRESS = 4;

		const char* trace_get_error()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->trace_get_error(this);
			return ret;
		}

		FB_BOOLEAN trace_attach(TraceDatabaseConnection* connection, FB_BOOLEAN create_db, unsigned att_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_attach(this, connection, create_db, att_result);
			return ret;
		}

		FB_BOOLEAN trace_detach(TraceDatabaseConnection* connection, FB_BOOLEAN drop_db)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_detach(this, connection, drop_db);
			return ret;
		}

		FB_BOOLEAN trace_transaction_start(TraceDatabaseConnection* connection, TraceTransaction* transaction, unsigned tpb_length, const unsigned char* tpb, unsigned tra_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_transaction_start(this, connection, transaction, tpb_length, tpb, tra_result);
			return ret;
		}

		FB_BOOLEAN trace_transaction_end(TraceDatabaseConnection* connection, TraceTransaction* transaction, FB_BOOLEAN commit, FB_BOOLEAN retain_context, unsigned tra_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_transaction_end(this, connection, transaction, commit, retain_context, tra_result);
			return ret;
		}

		FB_BOOLEAN trace_proc_execute(TraceDatabaseConnection* connection, TraceTransaction* transaction, TraceProcedure* procedure, FB_BOOLEAN started, unsigned proc_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_proc_execute(this, connection, transaction, procedure, started, proc_result);
			return ret;
		}

		FB_BOOLEAN trace_trigger_execute(TraceDatabaseConnection* connection, TraceTransaction* transaction, TraceTrigger* trigger, FB_BOOLEAN started, unsigned trig_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_trigger_execute(this, connection, transaction, trigger, started, trig_result);
			return ret;
		}

		FB_BOOLEAN trace_set_context(TraceDatabaseConnection* connection, TraceTransaction* transaction, TraceContextVariable* variable)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_set_context(this, connection, transaction, variable);
			return ret;
		}

		FB_BOOLEAN trace_dsql_prepare(TraceDatabaseConnection* connection, TraceTransaction* transaction, TraceSQLStatement* statement, ISC_INT64 time_millis, unsigned req_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_dsql_prepare(this, connection, transaction, statement, time_millis, req_result);
			return ret;
		}

		FB_BOOLEAN trace_dsql_free(TraceDatabaseConnection* connection, TraceSQLStatement* statement, unsigned option)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_dsql_free(this, connection, statement, option);
			return ret;
		}

		FB_BOOLEAN trace_dsql_execute(TraceDatabaseConnection* connection, TraceTransaction* transaction, TraceSQLStatement* statement, FB_BOOLEAN started, unsigned req_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_dsql_execute(this, connection, transaction, statement, started, req_result);
			return ret;
		}

		FB_BOOLEAN trace_blr_compile(TraceDatabaseConnection* connection, TraceTransaction* transaction, TraceBLRStatement* statement, ISC_INT64 time_millis, unsigned req_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_blr_compile(this, connection, transaction, statement, time_millis, req_result);
			return ret;
		}

		FB_BOOLEAN trace_blr_execute(TraceDatabaseConnection* connection, TraceTransaction* transaction, TraceBLRStatement* statement, unsigned req_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_blr_execute(this, connection, transaction, statement, req_result);
			return ret;
		}

		FB_BOOLEAN trace_dyn_execute(TraceDatabaseConnection* connection, TraceTransaction* transaction, TraceDYNRequest* request, ISC_INT64 time_millis, unsigned req_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_dyn_execute(this, connection, transaction, request, time_millis, req_result);
			return ret;
		}

		FB_BOOLEAN trace_service_attach(TraceServiceConnection* service, unsigned att_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_service_attach(this, service, att_result);
			return ret;
		}

		FB_BOOLEAN trace_service_start(TraceServiceConnection* service, unsigned switches_length, const char* switches, unsigned start_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_service_start(this, service, switches_length, switches, start_result);
			return ret;
		}

		FB_BOOLEAN trace_service_query(TraceServiceConnection* service, unsigned send_item_length, const unsigned char* send_items, unsigned recv_item_length, const unsigned char* recv_items, unsigned query_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_service_query(this, service, send_item_length, send_items, recv_item_length, recv_items, query_result);
			return ret;
		}

		FB_BOOLEAN trace_service_detach(TraceServiceConnection* service, unsigned detach_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_service_detach(this, service, detach_result);
			return ret;
		}

		FB_BOOLEAN trace_event_error(TraceConnection* connection, TraceStatusVector* status, const char* function)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_event_error(this, connection, status, function);
			return ret;
		}

		FB_BOOLEAN trace_event_sweep(TraceDatabaseConnection* connection, TraceSweepInfo* sweep, unsigned sweep_state)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_event_sweep(this, connection, sweep, sweep_state);
			return ret;
		}

		FB_BOOLEAN trace_func_execute(TraceDatabaseConnection* connection, TraceTransaction* transaction, TraceFunction* function, FB_BOOLEAN started, unsigned func_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_func_execute(this, connection, transaction, function, started, func_result);
			return ret;
		}
	};

	class TraceFactory : public PluginBase
	{
	public:
		struct VTable : public PluginBase::VTable
		{
			ISC_UINT64 (CLOOP_CARG *trace_needs)(TraceFactory* self) throw();
			TracePlugin* (CLOOP_CARG *trace_create)(TraceFactory* self, Status* status, TraceInitInfo* init_info) throw();
		};

	protected:
		TraceFactory(DoNotInherit)
			: PluginBase(DoNotInherit())
		{
		}

		~TraceFactory()
		{
		}

	public:
		static const unsigned VERSION = 4;

		static const unsigned TRACE_EVENT_ATTACH = 0;
		static const unsigned TRACE_EVENT_DETACH = 1;
		static const unsigned TRACE_EVENT_TRANSACTION_START = 2;
		static const unsigned TRACE_EVENT_TRANSACTION_END = 3;
		static const unsigned TRACE_EVENT_SET_CONTEXT = 4;
		static const unsigned TRACE_EVENT_PROC_EXECUTE = 5;
		static const unsigned TRACE_EVENT_TRIGGER_EXECUTE = 6;
		static const unsigned TRACE_EVENT_DSQL_PREPARE = 7;
		static const unsigned TRACE_EVENT_DSQL_FREE = 8;
		static const unsigned TRACE_EVENT_DSQL_EXECUTE = 9;
		static const unsigned TRACE_EVENT_BLR_COMPILE = 10;
		static const unsigned TRACE_EVENT_BLR_EXECUTE = 11;
		static const unsigned TRACE_EVENT_DYN_EXECUTE = 12;
		static const unsigned TRACE_EVENT_SERVICE_ATTACH = 13;
		static const unsigned TRACE_EVENT_SERVICE_START = 14;
		static const unsigned TRACE_EVENT_SERVICE_QUERY = 15;
		static const unsigned TRACE_EVENT_SERVICE_DETACH = 16;
		static const unsigned TRACE_EVENT_ERROR = 17;
		static const unsigned TRACE_EVENT_SWEEP = 18;
		static const unsigned TRACE_EVENT_FUNC_EXECUTE = 19;
		static const unsigned TRACE_EVENT_MAX = 20;

		ISC_UINT64 trace_needs()
		{
			ISC_UINT64 ret = static_cast<VTable*>(this->cloopVTable)->trace_needs(this);
			return ret;
		}

		TracePlugin* trace_create(Status* status, TraceInitInfo* init_info)
		{
			typename Policy::Status status2(status);
			TracePlugin* ret = static_cast<VTable*>(this->cloopVTable)->trace_create(this, status2, init_info);
			Policy::checkException(status2);
			return ret;
		}
	};

	// Interfaces implementations

	template <typename Name, typename Base>
	class VersionedBaseImpl : public Base
	{
	public:
		typedef Versioned Declaration;

		VersionedBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = Inherit<Versioned> >
	class VersionedImpl : public VersionedBaseImpl<Name, Base>
	{
	protected:
		VersionedImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~VersionedImpl()
		{
		}

		virtual PluginModule* getModule() = 0;
	};

	template <typename Name, typename Base>
	class ReferenceCountedBaseImpl : public Base
	{
	public:
		typedef ReferenceCounted Declaration;

		ReferenceCountedBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopaddRefDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = VersionedImpl<Name, Inherit<ReferenceCounted> > >
	class ReferenceCountedImpl : public ReferenceCountedBaseImpl<Name, Base>
	{
	protected:
		ReferenceCountedImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ReferenceCountedImpl()
		{
		}

		virtual void addRef() = 0;
		virtual int release() = 0;
	};

	template <typename Name, typename Base>
	class DisposableBaseImpl : public Base
	{
	public:
		typedef Disposable Declaration;

		DisposableBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->dispose = &Name::cloopdisposeDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopdisposeDispatcher(Disposable* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::dispose();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = VersionedImpl<Name, Inherit<Disposable> > >
	class DisposableImpl : public DisposableBaseImpl<Name, Base>
	{
	protected:
		DisposableImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~DisposableImpl()
		{
		}

		virtual void dispose() = 0;
	};

	template <typename Name, typename Base>
	class StatusBaseImpl : public Base
	{
	public:
		typedef Status Declaration;

		StatusBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->dispose = &Name::cloopdisposeDispatcher;
					this->init = &Name::cloopinitDispatcher;
					this->getStatus = &Name::cloopgetStatusDispatcher;
					this->setErrors2 = &Name::cloopsetErrors2Dispatcher;
					this->setWarnings2 = &Name::cloopsetWarnings2Dispatcher;
					this->setErrors = &Name::cloopsetErrorsDispatcher;
					this->setWarnings = &Name::cloopsetWarningsDispatcher;
					this->getErrors = &Name::cloopgetErrorsDispatcher;
					this->getWarnings = &Name::cloopgetWarningsDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopinitDispatcher(Status* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::init();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetStatusDispatcher(const Status* self) throw()
		{
			try
			{
				return static_cast<const Name*>(self)->Name::getStatus();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static void CLOOP_CARG cloopsetErrors2Dispatcher(Status* self, unsigned length, const intptr_t* value) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setErrors2(length, value);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static void CLOOP_CARG cloopsetWarnings2Dispatcher(Status* self, unsigned length, const intptr_t* value) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setWarnings2(length, value);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static void CLOOP_CARG cloopsetErrorsDispatcher(Status* self, const intptr_t* value) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setErrors(value);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static void CLOOP_CARG cloopsetWarningsDispatcher(Status* self, const intptr_t* value) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setWarnings(value);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static const intptr_t* CLOOP_CARG cloopgetErrorsDispatcher(const Status* self) throw()
		{
			try
			{
				return static_cast<const Name*>(self)->Name::getErrors();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const intptr_t*>(0);
			}
		}

		static const intptr_t* CLOOP_CARG cloopgetWarningsDispatcher(const Status* self) throw()
		{
			try
			{
				return static_cast<const Name*>(self)->Name::getWarnings();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const intptr_t*>(0);
			}
		}

		static void CLOOP_CARG cloopdisposeDispatcher(Disposable* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::dispose();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = DisposableImpl<Name, Inherit<VersionedImpl<Name, Inherit<Status> > > > >
	class StatusImpl : public StatusBaseImpl<Name, Base>
	{
	protected:
		StatusImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~StatusImpl()
		{
		}

		virtual void init() = 0;
		virtual unsigned getStatus() const = 0;
		virtual void setErrors2(unsigned length, const intptr_t* value) = 0;
		virtual void setWarnings2(unsigned length, const intptr_t* value) = 0;
		virtual void setErrors(const intptr_t* value) = 0;
		virtual void setWarnings(const intptr_t* value) = 0;
		virtual const intptr_t* getErrors() const = 0;
		virtual const intptr_t* getWarnings() const = 0;
	};

	template <typename Name, typename Base>
	class MasterBaseImpl : public Base
	{
	public:
		typedef Master Declaration;

		MasterBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getStatus = &Name::cloopgetStatusDispatcher;
					this->getDispatcher = &Name::cloopgetDispatcherDispatcher;
					this->getPluginManager = &Name::cloopgetPluginManagerDispatcher;
					this->circularAlloc = &Name::cloopcircularAllocDispatcher;
					this->getTimerControl = &Name::cloopgetTimerControlDispatcher;
					this->getDtc = &Name::cloopgetDtcDispatcher;
					this->registerAttachment = &Name::cloopregisterAttachmentDispatcher;
					this->registerTransaction = &Name::cloopregisterTransactionDispatcher;
					this->same = &Name::cloopsameDispatcher;
					this->getMetadataBuilder = &Name::cloopgetMetadataBuilderDispatcher;
					this->serverMode = &Name::cloopserverModeDispatcher;
					this->getUtlInterface = &Name::cloopgetUtlInterfaceDispatcher;
					this->getConfigManager = &Name::cloopgetConfigManagerDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static Status* CLOOP_CARG cloopgetStatusDispatcher(Master* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getStatus();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<Status*>(0);
			}
		}

		static Provider* CLOOP_CARG cloopgetDispatcherDispatcher(Master* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getDispatcher();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<Provider*>(0);
			}
		}

		static PluginManager* CLOOP_CARG cloopgetPluginManagerDispatcher(Master* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPluginManager();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginManager*>(0);
			}
		}

		static const char* CLOOP_CARG cloopcircularAllocDispatcher(Master* self, const char* s, unsigned len, intptr_t thr) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::circularAlloc(s, len, thr);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static TimerControl* CLOOP_CARG cloopgetTimerControlDispatcher(Master* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getTimerControl();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<TimerControl*>(0);
			}
		}

		static Dtc* CLOOP_CARG cloopgetDtcDispatcher(Master* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getDtc();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<Dtc*>(0);
			}
		}

		static Attachment* CLOOP_CARG cloopregisterAttachmentDispatcher(Master* self, Provider* provider, Attachment* attachment) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::registerAttachment(provider, attachment);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<Attachment*>(0);
			}
		}

		static Transaction* CLOOP_CARG cloopregisterTransactionDispatcher(Master* self, Attachment* attachment, Transaction* transaction) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::registerTransaction(attachment, transaction);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<Transaction*>(0);
			}
		}

		static int CLOOP_CARG cloopsameDispatcher(Master* self, Versioned* first, Versioned* second) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::same(first, second);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static MetadataBuilder* CLOOP_CARG cloopgetMetadataBuilderDispatcher(Master* self, Status* status, unsigned fieldCount) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getMetadataBuilder(status, fieldCount);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<MetadataBuilder*>(0);
			}
		}

		static int CLOOP_CARG cloopserverModeDispatcher(Master* self, int mode) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::serverMode(mode);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static Utl* CLOOP_CARG cloopgetUtlInterfaceDispatcher(Master* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getUtlInterface();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<Utl*>(0);
			}
		}

		static ConfigManager* CLOOP_CARG cloopgetConfigManagerDispatcher(Master* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getConfigManager();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ConfigManager*>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = VersionedImpl<Name, Inherit<Master> > >
	class MasterImpl : public MasterBaseImpl<Name, Base>
	{
	protected:
		MasterImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~MasterImpl()
		{
		}

		virtual Status* getStatus() = 0;
		virtual Provider* getDispatcher() = 0;
		virtual PluginManager* getPluginManager() = 0;
		virtual const char* circularAlloc(const char* s, unsigned len, intptr_t thr) = 0;
		virtual TimerControl* getTimerControl() = 0;
		virtual Dtc* getDtc() = 0;
		virtual Attachment* registerAttachment(Provider* provider, Attachment* attachment) = 0;
		virtual Transaction* registerTransaction(Attachment* attachment, Transaction* transaction) = 0;
		virtual int same(Versioned* first, Versioned* second) = 0;
		virtual MetadataBuilder* getMetadataBuilder(Status* status, unsigned fieldCount) = 0;
		virtual int serverMode(int mode) = 0;
		virtual Utl* getUtlInterface() = 0;
		virtual ConfigManager* getConfigManager() = 0;
	};

	template <typename Name, typename Base>
	class PluginBaseBaseImpl : public Base
	{
	public:
		typedef PluginBase Declaration;

		PluginBaseBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->setOwner = &Name::cloopsetOwnerDispatcher;
					this->getOwner = &Name::cloopgetOwnerDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopsetOwnerDispatcher(PluginBase* self, ReferenceCounted* r) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setOwner(r);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static ReferenceCounted* CLOOP_CARG cloopgetOwnerDispatcher(PluginBase* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOwner();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ReferenceCounted*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = ReferenceCountedImpl<Name, Inherit<VersionedImpl<Name, Inherit<PluginBase> > > > >
	class PluginBaseImpl : public PluginBaseBaseImpl<Name, Base>
	{
	protected:
		PluginBaseImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~PluginBaseImpl()
		{
		}

		virtual void setOwner(ReferenceCounted* r) = 0;
		virtual ReferenceCounted* getOwner() = 0;
	};

	template <typename Name, typename Base>
	class PluginSetBaseImpl : public Base
	{
	public:
		typedef PluginSet Declaration;

		PluginSetBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->getName = &Name::cloopgetNameDispatcher;
					this->getModuleName = &Name::cloopgetModuleNameDispatcher;
					this->getPlugin = &Name::cloopgetPluginDispatcher;
					this->next = &Name::cloopnextDispatcher;
					this->set = &Name::cloopsetDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetNameDispatcher(const PluginSet* self) throw()
		{
			try
			{
				return static_cast<const Name*>(self)->Name::getName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetModuleNameDispatcher(const PluginSet* self) throw()
		{
			try
			{
				return static_cast<const Name*>(self)->Name::getModuleName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static PluginBase* CLOOP_CARG cloopgetPluginDispatcher(PluginSet* self, Status* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPlugin(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<PluginBase*>(0);
			}
		}

		static void CLOOP_CARG cloopnextDispatcher(PluginSet* self, Status* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::next(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopsetDispatcher(PluginSet* self, Status* status, const char* s) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::set(status, s);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = ReferenceCountedImpl<Name, Inherit<VersionedImpl<Name, Inherit<PluginSet> > > > >
	class PluginSetImpl : public PluginSetBaseImpl<Name, Base>
	{
	protected:
		PluginSetImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~PluginSetImpl()
		{
		}

		virtual const char* getName() const = 0;
		virtual const char* getModuleName() const = 0;
		virtual PluginBase* getPlugin(Status* status) = 0;
		virtual void next(Status* status) = 0;
		virtual void set(Status* status, const char* s) = 0;
	};

	template <typename Name, typename Base>
	class ConfigEntryBaseImpl : public Base
	{
	public:
		typedef ConfigEntry Declaration;

		ConfigEntryBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->getName = &Name::cloopgetNameDispatcher;
					this->getValue = &Name::cloopgetValueDispatcher;
					this->getIntValue = &Name::cloopgetIntValueDispatcher;
					this->getBoolValue = &Name::cloopgetBoolValueDispatcher;
					this->getSubConfig = &Name::cloopgetSubConfigDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetNameDispatcher(ConfigEntry* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetValueDispatcher(ConfigEntry* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getValue();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static ISC_INT64 CLOOP_CARG cloopgetIntValueDispatcher(ConfigEntry* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getIntValue();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ISC_INT64>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG cloopgetBoolValueDispatcher(ConfigEntry* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getBoolValue();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static Config* CLOOP_CARG cloopgetSubConfigDispatcher(ConfigEntry* self, Status* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getSubConfig(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<Config*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = ReferenceCountedImpl<Name, Inherit<VersionedImpl<Name, Inherit<ConfigEntry> > > > >
	class ConfigEntryImpl : public ConfigEntryBaseImpl<Name, Base>
	{
	protected:
		ConfigEntryImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ConfigEntryImpl()
		{
		}

		virtual const char* getName() = 0;
		virtual const char* getValue() = 0;
		virtual ISC_INT64 getIntValue() = 0;
		virtual FB_BOOLEAN getBoolValue() = 0;
		virtual Config* getSubConfig(Status* status) = 0;
	};

	template <typename Name, typename Base>
	class ConfigBaseImpl : public Base
	{
	public:
		typedef Config Declaration;

		ConfigBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->find = &Name::cloopfindDispatcher;
					this->findValue = &Name::cloopfindValueDispatcher;
					this->findPos = &Name::cloopfindPosDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static ConfigEntry* CLOOP_CARG cloopfindDispatcher(Config* self, Status* status, const char* name) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::find(status, name);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<ConfigEntry*>(0);
			}
		}

		static ConfigEntry* CLOOP_CARG cloopfindValueDispatcher(Config* self, Status* status, const char* name, const char* value) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::findValue(status, name, value);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<ConfigEntry*>(0);
			}
		}

		static ConfigEntry* CLOOP_CARG cloopfindPosDispatcher(Config* self, Status* status, const char* name, unsigned pos) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::findPos(status, name, pos);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<ConfigEntry*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = ReferenceCountedImpl<Name, Inherit<VersionedImpl<Name, Inherit<Config> > > > >
	class ConfigImpl : public ConfigBaseImpl<Name, Base>
	{
	protected:
		ConfigImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ConfigImpl()
		{
		}

		virtual ConfigEntry* find(Status* status, const char* name) = 0;
		virtual ConfigEntry* findValue(Status* status, const char* name, const char* value) = 0;
		virtual ConfigEntry* findPos(Status* status, const char* name, unsigned pos) = 0;
	};

	template <typename Name, typename Base>
	class FirebirdConfBaseImpl : public Base
	{
	public:
		typedef FirebirdConf Declaration;

		FirebirdConfBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->getKey = &Name::cloopgetKeyDispatcher;
					this->asInteger = &Name::cloopasIntegerDispatcher;
					this->asString = &Name::cloopasStringDispatcher;
					this->asBoolean = &Name::cloopasBooleanDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static unsigned CLOOP_CARG cloopgetKeyDispatcher(FirebirdConf* self, const char* name) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getKey(name);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static ISC_INT64 CLOOP_CARG cloopasIntegerDispatcher(FirebirdConf* self, unsigned key) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::asInteger(key);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ISC_INT64>(0);
			}
		}

		static const char* CLOOP_CARG cloopasStringDispatcher(FirebirdConf* self, unsigned key) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::asString(key);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG cloopasBooleanDispatcher(FirebirdConf* self, unsigned key) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::asBoolean(key);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = ReferenceCountedImpl<Name, Inherit<VersionedImpl<Name, Inherit<FirebirdConf> > > > >
	class FirebirdConfImpl : public FirebirdConfBaseImpl<Name, Base>
	{
	protected:
		FirebirdConfImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~FirebirdConfImpl()
		{
		}

		virtual unsigned getKey(const char* name) = 0;
		virtual ISC_INT64 asInteger(unsigned key) = 0;
		virtual const char* asString(unsigned key) = 0;
		virtual FB_BOOLEAN asBoolean(unsigned key) = 0;
	};

	template <typename Name, typename Base>
	class PluginConfigBaseImpl : public Base
	{
	public:
		typedef PluginConfig Declaration;

		PluginConfigBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->getConfigFileName = &Name::cloopgetConfigFileNameDispatcher;
					this->getDefaultConfig = &Name::cloopgetDefaultConfigDispatcher;
					this->getFirebirdConf = &Name::cloopgetFirebirdConfDispatcher;
					this->setReleaseDelay = &Name::cloopsetReleaseDelayDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetConfigFileNameDispatcher(PluginConfig* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getConfigFileName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static Config* CLOOP_CARG cloopgetDefaultConfigDispatcher(PluginConfig* self, Status* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getDefaultConfig(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<Config*>(0);
			}
		}

		static FirebirdConf* CLOOP_CARG cloopgetFirebirdConfDispatcher(PluginConfig* self, Status* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getFirebirdConf(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<FirebirdConf*>(0);
			}
		}

		static void CLOOP_CARG cloopsetReleaseDelayDispatcher(PluginConfig* self, Status* status, ISC_UINT64 microSeconds) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setReleaseDelay(status, microSeconds);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = ReferenceCountedImpl<Name, Inherit<VersionedImpl<Name, Inherit<PluginConfig> > > > >
	class PluginConfigImpl : public PluginConfigBaseImpl<Name, Base>
	{
	protected:
		PluginConfigImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~PluginConfigImpl()
		{
		}

		virtual const char* getConfigFileName() = 0;
		virtual Config* getDefaultConfig(Status* status) = 0;
		virtual FirebirdConf* getFirebirdConf(Status* status) = 0;
		virtual void setReleaseDelay(Status* status, ISC_UINT64 microSeconds) = 0;
	};

	template <typename Name, typename Base>
	class PluginFactoryBaseImpl : public Base
	{
	public:
		typedef PluginFactory Declaration;

		PluginFactoryBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->createPlugin = &Name::cloopcreatePluginDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static PluginBase* CLOOP_CARG cloopcreatePluginDispatcher(PluginFactory* self, Status* status, PluginConfig* factoryParameter) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::createPlugin(status, factoryParameter);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<PluginBase*>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = VersionedImpl<Name, Inherit<PluginFactory> > >
	class PluginFactoryImpl : public PluginFactoryBaseImpl<Name, Base>
	{
	protected:
		PluginFactoryImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~PluginFactoryImpl()
		{
		}

		virtual PluginBase* createPlugin(Status* status, PluginConfig* factoryParameter) = 0;
	};

	template <typename Name, typename Base>
	class PluginModuleBaseImpl : public Base
	{
	public:
		typedef PluginModule Declaration;

		PluginModuleBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->doClean = &Name::cloopdoCleanDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopdoCleanDispatcher(PluginModule* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::doClean();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = VersionedImpl<Name, Inherit<PluginModule> > >
	class PluginModuleImpl : public PluginModuleBaseImpl<Name, Base>
	{
	protected:
		PluginModuleImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~PluginModuleImpl()
		{
		}

		virtual void doClean() = 0;
	};

	template <typename Name, typename Base>
	class PluginManagerBaseImpl : public Base
	{
	public:
		typedef PluginManager Declaration;

		PluginManagerBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->registerPluginFactory = &Name::cloopregisterPluginFactoryDispatcher;
					this->registerModule = &Name::cloopregisterModuleDispatcher;
					this->unregisterModule = &Name::cloopunregisterModuleDispatcher;
					this->getPlugins = &Name::cloopgetPluginsDispatcher;
					this->getConfig = &Name::cloopgetConfigDispatcher;
					this->releasePlugin = &Name::cloopreleasePluginDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopregisterPluginFactoryDispatcher(PluginManager* self, unsigned pluginType, const char* defaultName, PluginFactory* factory) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::registerPluginFactory(pluginType, defaultName, factory);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static void CLOOP_CARG cloopregisterModuleDispatcher(PluginManager* self, PluginModule* cleanup) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::registerModule(cleanup);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static void CLOOP_CARG cloopunregisterModuleDispatcher(PluginManager* self, PluginModule* cleanup) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::unregisterModule(cleanup);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static PluginSet* CLOOP_CARG cloopgetPluginsDispatcher(PluginManager* self, Status* status, unsigned pluginType, const char* namesList, FirebirdConf* firebirdConf) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPlugins(status, pluginType, namesList, firebirdConf);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<PluginSet*>(0);
			}
		}

		static Config* CLOOP_CARG cloopgetConfigDispatcher(PluginManager* self, Status* status, const char* filename) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getConfig(status, filename);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<Config*>(0);
			}
		}

		static void CLOOP_CARG cloopreleasePluginDispatcher(PluginManager* self, PluginBase* plugin) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::releasePlugin(plugin);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = VersionedImpl<Name, Inherit<PluginManager> > >
	class PluginManagerImpl : public PluginManagerBaseImpl<Name, Base>
	{
	protected:
		PluginManagerImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~PluginManagerImpl()
		{
		}

		virtual void registerPluginFactory(unsigned pluginType, const char* defaultName, PluginFactory* factory) = 0;
		virtual void registerModule(PluginModule* cleanup) = 0;
		virtual void unregisterModule(PluginModule* cleanup) = 0;
		virtual PluginSet* getPlugins(Status* status, unsigned pluginType, const char* namesList, FirebirdConf* firebirdConf) = 0;
		virtual Config* getConfig(Status* status, const char* filename) = 0;
		virtual void releasePlugin(PluginBase* plugin) = 0;
	};

	template <typename Name, typename Base>
	class ConfigManagerBaseImpl : public Base
	{
	public:
		typedef ConfigManager Declaration;

		ConfigManagerBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getDirectory = &Name::cloopgetDirectoryDispatcher;
					this->getFirebirdConf = &Name::cloopgetFirebirdConfDispatcher;
					this->getDatabaseConf = &Name::cloopgetDatabaseConfDispatcher;
					this->getPluginConfig = &Name::cloopgetPluginConfigDispatcher;
					this->getInstallDirectory = &Name::cloopgetInstallDirectoryDispatcher;
					this->getRootDirectory = &Name::cloopgetRootDirectoryDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetDirectoryDispatcher(ConfigManager* self, unsigned code) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getDirectory(code);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static FirebirdConf* CLOOP_CARG cloopgetFirebirdConfDispatcher(ConfigManager* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getFirebirdConf();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FirebirdConf*>(0);
			}
		}

		static FirebirdConf* CLOOP_CARG cloopgetDatabaseConfDispatcher(ConfigManager* self, const char* dbName) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getDatabaseConf(dbName);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FirebirdConf*>(0);
			}
		}

		static Config* CLOOP_CARG cloopgetPluginConfigDispatcher(ConfigManager* self, const char* configuredPlugin) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPluginConfig(configuredPlugin);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<Config*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetInstallDirectoryDispatcher(ConfigManager* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getInstallDirectory();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRootDirectoryDispatcher(ConfigManager* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRootDirectory();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = VersionedImpl<Name, Inherit<ConfigManager> > >
	class ConfigManagerImpl : public ConfigManagerBaseImpl<Name, Base>
	{
	protected:
		ConfigManagerImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ConfigManagerImpl()
		{
		}

		virtual const char* getDirectory(unsigned code) = 0;
		virtual FirebirdConf* getFirebirdConf() = 0;
		virtual FirebirdConf* getDatabaseConf(const char* dbName) = 0;
		virtual Config* getPluginConfig(const char* configuredPlugin) = 0;
		virtual const char* getInstallDirectory() = 0;
		virtual const char* getRootDirectory() = 0;
	};

	template <typename Name, typename Base>
	class EventCallbackBaseImpl : public Base
	{
	public:
		typedef EventCallback Declaration;

		EventCallbackBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->eventCallbackFunction = &Name::cloopeventCallbackFunctionDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopeventCallbackFunctionDispatcher(EventCallback* self, unsigned length, const unsigned char* events) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::eventCallbackFunction(length, events);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = ReferenceCountedImpl<Name, Inherit<VersionedImpl<Name, Inherit<EventCallback> > > > >
	class EventCallbackImpl : public EventCallbackBaseImpl<Name, Base>
	{
	protected:
		EventCallbackImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~EventCallbackImpl()
		{
		}

		virtual void eventCallbackFunction(unsigned length, const unsigned char* events) = 0;
	};

	template <typename Name, typename Base>
	class BlobBaseImpl : public Base
	{
	public:
		typedef Blob Declaration;

		BlobBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->getInfo = &Name::cloopgetInfoDispatcher;
					this->getSegment = &Name::cloopgetSegmentDispatcher;
					this->putSegment = &Name::cloopputSegmentDispatcher;
					this->cancel = &Name::cloopcancelDispatcher;
					this->close = &Name::cloopcloseDispatcher;
					this->seek = &Name::cloopseekDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopgetInfoDispatcher(Blob* self, Status* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::getInfo(status, itemsLength, items, bufferLength, buffer);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static int CLOOP_CARG cloopgetSegmentDispatcher(Blob* self, Status* status, unsigned bufferLength, void* buffer, unsigned* segmentLength) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getSegment(status, bufferLength, buffer, segmentLength);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<int>(0);
			}
		}

		static void CLOOP_CARG cloopputSegmentDispatcher(Blob* self, Status* status, unsigned length, const void* buffer) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::putSegment(status, length, buffer);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopcancelDispatcher(Blob* self, Status* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::cancel(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopcloseDispatcher(Blob* self, Status* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::close(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static int CLOOP_CARG cloopseekDispatcher(Blob* self, Status* status, int mode, int offset) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::seek(status, mode, offset);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<int>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = ReferenceCountedImpl<Name, Inherit<VersionedImpl<Name, Inherit<Blob> > > > >
	class BlobImpl : public BlobBaseImpl<Name, Base>
	{
	protected:
		BlobImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~BlobImpl()
		{
		}

		virtual void getInfo(Status* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) = 0;
		virtual int getSegment(Status* status, unsigned bufferLength, void* buffer, unsigned* segmentLength) = 0;
		virtual void putSegment(Status* status, unsigned length, const void* buffer) = 0;
		virtual void cancel(Status* status) = 0;
		virtual void close(Status* status) = 0;
		virtual int seek(Status* status, int mode, int offset) = 0;
	};

	template <typename Name, typename Base>
	class TransactionBaseImpl : public Base
	{
	public:
		typedef Transaction Declaration;

		TransactionBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->getInfo = &Name::cloopgetInfoDispatcher;
					this->prepare = &Name::cloopprepareDispatcher;
					this->commit = &Name::cloopcommitDispatcher;
					this->commitRetaining = &Name::cloopcommitRetainingDispatcher;
					this->rollback = &Name::clooprollbackDispatcher;
					this->rollbackRetaining = &Name::clooprollbackRetainingDispatcher;
					this->disconnect = &Name::cloopdisconnectDispatcher;
					this->join = &Name::cloopjoinDispatcher;
					this->validate = &Name::cloopvalidateDispatcher;
					this->enterDtc = &Name::cloopenterDtcDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopgetInfoDispatcher(Transaction* self, Status* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::getInfo(status, itemsLength, items, bufferLength, buffer);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopprepareDispatcher(Transaction* self, Status* status, unsigned msgLength, const unsigned char* message) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::prepare(status, msgLength, message);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopcommitDispatcher(Transaction* self, Status* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::commit(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopcommitRetainingDispatcher(Transaction* self, Status* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::commitRetaining(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG clooprollbackDispatcher(Transaction* self, Status* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::rollback(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG clooprollbackRetainingDispatcher(Transaction* self, Status* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::rollbackRetaining(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopdisconnectDispatcher(Transaction* self, Status* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::disconnect(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static Transaction* CLOOP_CARG cloopjoinDispatcher(Transaction* self, Status* status, Transaction* transaction) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::join(status, transaction);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<Transaction*>(0);
			}
		}

		static Transaction* CLOOP_CARG cloopvalidateDispatcher(Transaction* self, Status* status, Attachment* attachment) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::validate(status, attachment);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<Transaction*>(0);
			}
		}

		static Transaction* CLOOP_CARG cloopenterDtcDispatcher(Transaction* self, Status* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::enterDtc(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<Transaction*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = ReferenceCountedImpl<Name, Inherit<VersionedImpl<Name, Inherit<Transaction> > > > >
	class TransactionImpl : public TransactionBaseImpl<Name, Base>
	{
	protected:
		TransactionImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~TransactionImpl()
		{
		}

		virtual void getInfo(Status* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) = 0;
		virtual void prepare(Status* status, unsigned msgLength, const unsigned char* message) = 0;
		virtual void commit(Status* status) = 0;
		virtual void commitRetaining(Status* status) = 0;
		virtual void rollback(Status* status) = 0;
		virtual void rollbackRetaining(Status* status) = 0;
		virtual void disconnect(Status* status) = 0;
		virtual Transaction* join(Status* status, Transaction* transaction) = 0;
		virtual Transaction* validate(Status* status, Attachment* attachment) = 0;
		virtual Transaction* enterDtc(Status* status) = 0;
	};

	template <typename Name, typename Base>
	class MessageMetadataBaseImpl : public Base
	{
	public:
		typedef MessageMetadata Declaration;

		MessageMetadataBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->getCount = &Name::cloopgetCountDispatcher;
					this->getField = &Name::cloopgetFieldDispatcher;
					this->getRelation = &Name::cloopgetRelationDispatcher;
					this->getOwner = &Name::cloopgetOwnerDispatcher;
					this->getAlias = &Name::cloopgetAliasDispatcher;
					this->getType = &Name::cloopgetTypeDispatcher;
					this->isNullable = &Name::cloopisNullableDispatcher;
					this->getSubType = &Name::cloopgetSubTypeDispatcher;
					this->getLength = &Name::cloopgetLengthDispatcher;
					this->getScale = &Name::cloopgetScaleDispatcher;
					this->getCharSet = &Name::cloopgetCharSetDispatcher;
					this->getOffset = &Name::cloopgetOffsetDispatcher;
					this->getNullOffset = &Name::cloopgetNullOffsetDispatcher;
					this->getBuilder = &Name::cloopgetBuilderDispatcher;
					this->getMessageLength = &Name::cloopgetMessageLengthDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static unsigned CLOOP_CARG cloopgetCountDispatcher(MessageMetadata* self, Status* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getCount(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<unsigned>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetFieldDispatcher(MessageMetadata* self, Status* status, unsigned index) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getField(status, index);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRelationDispatcher(MessageMetadata* self, Status* status, unsigned index) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRelation(status, index);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetOwnerDispatcher(MessageMetadata* self, Status* status, unsigned index) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOwner(status, index);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetAliasDispatcher(MessageMetadata* self, Status* status, unsigned index) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getAlias(status, index);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<const char*>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetTypeDispatcher(MessageMetadata* self, Status* status, unsigned index) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getType(status, index);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<unsigned>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG cloopisNullableDispatcher(MessageMetadata* self, Status* status, unsigned index) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::isNullable(status, index);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static int CLOOP_CARG cloopgetSubTypeDispatcher(MessageMetadata* self, Status* status, unsigned index) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getSubType(status, index);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<int>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetLengthDispatcher(MessageMetadata* self, Status* status, unsigned index) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getLength(status, index);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<unsigned>(0);
			}
		}

		static int CLOOP_CARG cloopgetScaleDispatcher(MessageMetadata* self, Status* status, unsigned index) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getScale(status, index);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<int>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetCharSetDispatcher(MessageMetadata* self, Status* status, unsigned index) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getCharSet(status, index);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<unsigned>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetOffsetDispatcher(MessageMetadata* self, Status* status, unsigned index) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOffset(status, index);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<unsigned>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetNullOffsetDispatcher(MessageMetadata* self, Status* status, unsigned index) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getNullOffset(status, index);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<unsigned>(0);
			}
		}

		static MetadataBuilder* CLOOP_CARG cloopgetBuilderDispatcher(MessageMetadata* self, Status* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getBuilder(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<MetadataBuilder*>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetMessageLengthDispatcher(MessageMetadata* self, Status* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getMessageLength(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<unsigned>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = ReferenceCountedImpl<Name, Inherit<VersionedImpl<Name, Inherit<MessageMetadata> > > > >
	class MessageMetadataImpl : public MessageMetadataBaseImpl<Name, Base>
	{
	protected:
		MessageMetadataImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~MessageMetadataImpl()
		{
		}

		virtual unsigned getCount(Status* status) = 0;
		virtual const char* getField(Status* status, unsigned index) = 0;
		virtual const char* getRelation(Status* status, unsigned index) = 0;
		virtual const char* getOwner(Status* status, unsigned index) = 0;
		virtual const char* getAlias(Status* status, unsigned index) = 0;
		virtual unsigned getType(Status* status, unsigned index) = 0;
		virtual FB_BOOLEAN isNullable(Status* status, unsigned index) = 0;
		virtual int getSubType(Status* status, unsigned index) = 0;
		virtual unsigned getLength(Status* status, unsigned index) = 0;
		virtual int getScale(Status* status, unsigned index) = 0;
		virtual unsigned getCharSet(Status* status, unsigned index) = 0;
		virtual unsigned getOffset(Status* status, unsigned index) = 0;
		virtual unsigned getNullOffset(Status* status, unsigned index) = 0;
		virtual MetadataBuilder* getBuilder(Status* status) = 0;
		virtual unsigned getMessageLength(Status* status) = 0;
	};

	template <typename Name, typename Base>
	class MetadataBuilderBaseImpl : public Base
	{
	public:
		typedef MetadataBuilder Declaration;

		MetadataBuilderBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->setType = &Name::cloopsetTypeDispatcher;
					this->setSubType = &Name::cloopsetSubTypeDispatcher;
					this->setLength = &Name::cloopsetLengthDispatcher;
					this->setCharSet = &Name::cloopsetCharSetDispatcher;
					this->setScale = &Name::cloopsetScaleDispatcher;
					this->truncate = &Name::clooptruncateDispatcher;
					this->moveNameToIndex = &Name::cloopmoveNameToIndexDispatcher;
					this->remove = &Name::cloopremoveDispatcher;
					this->addField = &Name::cloopaddFieldDispatcher;
					this->getMetadata = &Name::cloopgetMetadataDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopsetTypeDispatcher(MetadataBuilder* self, Status* status, unsigned index, unsigned type) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setType(status, index, type);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopsetSubTypeDispatcher(MetadataBuilder* self, Status* status, unsigned index, int subType) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setSubType(status, index, subType);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopsetLengthDispatcher(MetadataBuilder* self, Status* status, unsigned index, unsigned length) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setLength(status, index, length);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopsetCharSetDispatcher(MetadataBuilder* self, Status* status, unsigned index, unsigned charSet) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setCharSet(status, index, charSet);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopsetScaleDispatcher(MetadataBuilder* self, Status* status, unsigned index, unsigned scale) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setScale(status, index, scale);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG clooptruncateDispatcher(MetadataBuilder* self, Status* status, unsigned count) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::truncate(status, count);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopmoveNameToIndexDispatcher(MetadataBuilder* self, Status* status, const char* name, unsigned index) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::moveNameToIndex(status, name, index);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopremoveDispatcher(MetadataBuilder* self, Status* status, unsigned index) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::remove(status, index);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static unsigned CLOOP_CARG cloopaddFieldDispatcher(MetadataBuilder* self, Status* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::addField(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<unsigned>(0);
			}
		}

		static MessageMetadata* CLOOP_CARG cloopgetMetadataDispatcher(MetadataBuilder* self, Status* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getMetadata(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<MessageMetadata*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = ReferenceCountedImpl<Name, Inherit<VersionedImpl<Name, Inherit<MetadataBuilder> > > > >
	class MetadataBuilderImpl : public MetadataBuilderBaseImpl<Name, Base>
	{
	protected:
		MetadataBuilderImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~MetadataBuilderImpl()
		{
		}

		virtual void setType(Status* status, unsigned index, unsigned type) = 0;
		virtual void setSubType(Status* status, unsigned index, int subType) = 0;
		virtual void setLength(Status* status, unsigned index, unsigned length) = 0;
		virtual void setCharSet(Status* status, unsigned index, unsigned charSet) = 0;
		virtual void setScale(Status* status, unsigned index, unsigned scale) = 0;
		virtual void truncate(Status* status, unsigned count) = 0;
		virtual void moveNameToIndex(Status* status, const char* name, unsigned index) = 0;
		virtual void remove(Status* status, unsigned index) = 0;
		virtual unsigned addField(Status* status) = 0;
		virtual MessageMetadata* getMetadata(Status* status) = 0;
	};

	template <typename Name, typename Base>
	class ResultSetBaseImpl : public Base
	{
	public:
		typedef ResultSet Declaration;

		ResultSetBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->fetchNext = &Name::cloopfetchNextDispatcher;
					this->fetchPrior = &Name::cloopfetchPriorDispatcher;
					this->fetchFirst = &Name::cloopfetchFirstDispatcher;
					this->fetchLast = &Name::cloopfetchLastDispatcher;
					this->fetchAbsolute = &Name::cloopfetchAbsoluteDispatcher;
					this->fetchRelative = &Name::cloopfetchRelativeDispatcher;
					this->isEof = &Name::cloopisEofDispatcher;
					this->isBof = &Name::cloopisBofDispatcher;
					this->getMetadata = &Name::cloopgetMetadataDispatcher;
					this->close = &Name::cloopcloseDispatcher;
					this->setDelayedOutputFormat = &Name::cloopsetDelayedOutputFormatDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static int CLOOP_CARG cloopfetchNextDispatcher(ResultSet* self, Status* status, void* message) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::fetchNext(status, message);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<int>(0);
			}
		}

		static int CLOOP_CARG cloopfetchPriorDispatcher(ResultSet* self, Status* status, void* message) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::fetchPrior(status, message);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<int>(0);
			}
		}

		static int CLOOP_CARG cloopfetchFirstDispatcher(ResultSet* self, Status* status, void* message) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::fetchFirst(status, message);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<int>(0);
			}
		}

		static int CLOOP_CARG cloopfetchLastDispatcher(ResultSet* self, Status* status, void* message) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::fetchLast(status, message);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<int>(0);
			}
		}

		static int CLOOP_CARG cloopfetchAbsoluteDispatcher(ResultSet* self, Status* status, unsigned position, void* message) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::fetchAbsolute(status, position, message);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<int>(0);
			}
		}

		static int CLOOP_CARG cloopfetchRelativeDispatcher(ResultSet* self, Status* status, int offset, void* message) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::fetchRelative(status, offset, message);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<int>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG cloopisEofDispatcher(ResultSet* self, Status* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::isEof(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG cloopisBofDispatcher(ResultSet* self, Status* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::isBof(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static MessageMetadata* CLOOP_CARG cloopgetMetadataDispatcher(ResultSet* self, Status* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getMetadata(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<MessageMetadata*>(0);
			}
		}

		static void CLOOP_CARG cloopcloseDispatcher(ResultSet* self, Status* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::close(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopsetDelayedOutputFormatDispatcher(ResultSet* self, Status* status, MessageMetadata* format) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setDelayedOutputFormat(status, format);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = ReferenceCountedImpl<Name, Inherit<VersionedImpl<Name, Inherit<ResultSet> > > > >
	class ResultSetImpl : public ResultSetBaseImpl<Name, Base>
	{
	protected:
		ResultSetImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ResultSetImpl()
		{
		}

		virtual int fetchNext(Status* status, void* message) = 0;
		virtual int fetchPrior(Status* status, void* message) = 0;
		virtual int fetchFirst(Status* status, void* message) = 0;
		virtual int fetchLast(Status* status, void* message) = 0;
		virtual int fetchAbsolute(Status* status, unsigned position, void* message) = 0;
		virtual int fetchRelative(Status* status, int offset, void* message) = 0;
		virtual FB_BOOLEAN isEof(Status* status) = 0;
		virtual FB_BOOLEAN isBof(Status* status) = 0;
		virtual MessageMetadata* getMetadata(Status* status) = 0;
		virtual void close(Status* status) = 0;
		virtual void setDelayedOutputFormat(Status* status, MessageMetadata* format) = 0;
	};

	template <typename Name, typename Base>
	class StatementBaseImpl : public Base
	{
	public:
		typedef Statement Declaration;

		StatementBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->getInfo = &Name::cloopgetInfoDispatcher;
					this->getType = &Name::cloopgetTypeDispatcher;
					this->getPlan = &Name::cloopgetPlanDispatcher;
					this->getAffectedRecords = &Name::cloopgetAffectedRecordsDispatcher;
					this->getInputMetadata = &Name::cloopgetInputMetadataDispatcher;
					this->getOutputMetadata = &Name::cloopgetOutputMetadataDispatcher;
					this->execute = &Name::cloopexecuteDispatcher;
					this->openCursor = &Name::cloopopenCursorDispatcher;
					this->setCursorName = &Name::cloopsetCursorNameDispatcher;
					this->free = &Name::cloopfreeDispatcher;
					this->getFlags = &Name::cloopgetFlagsDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopgetInfoDispatcher(Statement* self, Status* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::getInfo(status, itemsLength, items, bufferLength, buffer);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static unsigned CLOOP_CARG cloopgetTypeDispatcher(Statement* self, Status* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getType(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<unsigned>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetPlanDispatcher(Statement* self, Status* status, FB_BOOLEAN detailed) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPlan(status, detailed);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<const char*>(0);
			}
		}

		static ISC_UINT64 CLOOP_CARG cloopgetAffectedRecordsDispatcher(Statement* self, Status* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getAffectedRecords(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<ISC_UINT64>(0);
			}
		}

		static MessageMetadata* CLOOP_CARG cloopgetInputMetadataDispatcher(Statement* self, Status* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getInputMetadata(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<MessageMetadata*>(0);
			}
		}

		static MessageMetadata* CLOOP_CARG cloopgetOutputMetadataDispatcher(Statement* self, Status* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOutputMetadata(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<MessageMetadata*>(0);
			}
		}

		static Transaction* CLOOP_CARG cloopexecuteDispatcher(Statement* self, Status* status, Transaction* transaction, MessageMetadata* inMetadata, void* inBuffer, MessageMetadata* outMetadata, void* outBuffer) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::execute(status, transaction, inMetadata, inBuffer, outMetadata, outBuffer);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<Transaction*>(0);
			}
		}

		static ResultSet* CLOOP_CARG cloopopenCursorDispatcher(Statement* self, Status* status, Transaction* transaction, MessageMetadata* inMetadata, void* inBuffer, MessageMetadata* outMetadata) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::openCursor(status, transaction, inMetadata, inBuffer, outMetadata);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<ResultSet*>(0);
			}
		}

		static void CLOOP_CARG cloopsetCursorNameDispatcher(Statement* self, Status* status, const char* name) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setCursorName(status, name);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopfreeDispatcher(Statement* self, Status* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::free(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static unsigned CLOOP_CARG cloopgetFlagsDispatcher(Statement* self, Status* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getFlags(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<unsigned>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = ReferenceCountedImpl<Name, Inherit<VersionedImpl<Name, Inherit<Statement> > > > >
	class StatementImpl : public StatementBaseImpl<Name, Base>
	{
	protected:
		StatementImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~StatementImpl()
		{
		}

		virtual void getInfo(Status* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) = 0;
		virtual unsigned getType(Status* status) = 0;
		virtual const char* getPlan(Status* status, FB_BOOLEAN detailed) = 0;
		virtual ISC_UINT64 getAffectedRecords(Status* status) = 0;
		virtual MessageMetadata* getInputMetadata(Status* status) = 0;
		virtual MessageMetadata* getOutputMetadata(Status* status) = 0;
		virtual Transaction* execute(Status* status, Transaction* transaction, MessageMetadata* inMetadata, void* inBuffer, MessageMetadata* outMetadata, void* outBuffer) = 0;
		virtual ResultSet* openCursor(Status* status, Transaction* transaction, MessageMetadata* inMetadata, void* inBuffer, MessageMetadata* outMetadata) = 0;
		virtual void setCursorName(Status* status, const char* name) = 0;
		virtual void free(Status* status) = 0;
		virtual unsigned getFlags(Status* status) = 0;
	};

	template <typename Name, typename Base>
	class RequestBaseImpl : public Base
	{
	public:
		typedef Request Declaration;

		RequestBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->receive = &Name::cloopreceiveDispatcher;
					this->send = &Name::cloopsendDispatcher;
					this->getInfo = &Name::cloopgetInfoDispatcher;
					this->start = &Name::cloopstartDispatcher;
					this->startAndSend = &Name::cloopstartAndSendDispatcher;
					this->unwind = &Name::cloopunwindDispatcher;
					this->free = &Name::cloopfreeDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopreceiveDispatcher(Request* self, Status* status, int level, unsigned msgType, unsigned length, unsigned char* message) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::receive(status, level, msgType, length, message);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopsendDispatcher(Request* self, Status* status, int level, unsigned msgType, unsigned length, const unsigned char* message) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::send(status, level, msgType, length, message);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopgetInfoDispatcher(Request* self, Status* status, int level, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::getInfo(status, level, itemsLength, items, bufferLength, buffer);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopstartDispatcher(Request* self, Status* status, Transaction* tra, int level) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::start(status, tra, level);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopstartAndSendDispatcher(Request* self, Status* status, Transaction* tra, int level, unsigned msgType, unsigned length, const unsigned char* message) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::startAndSend(status, tra, level, msgType, length, message);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopunwindDispatcher(Request* self, Status* status, int level) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::unwind(status, level);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopfreeDispatcher(Request* self, Status* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::free(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = ReferenceCountedImpl<Name, Inherit<VersionedImpl<Name, Inherit<Request> > > > >
	class RequestImpl : public RequestBaseImpl<Name, Base>
	{
	protected:
		RequestImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~RequestImpl()
		{
		}

		virtual void receive(Status* status, int level, unsigned msgType, unsigned length, unsigned char* message) = 0;
		virtual void send(Status* status, int level, unsigned msgType, unsigned length, const unsigned char* message) = 0;
		virtual void getInfo(Status* status, int level, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) = 0;
		virtual void start(Status* status, Transaction* tra, int level) = 0;
		virtual void startAndSend(Status* status, Transaction* tra, int level, unsigned msgType, unsigned length, const unsigned char* message) = 0;
		virtual void unwind(Status* status, int level) = 0;
		virtual void free(Status* status) = 0;
	};

	template <typename Name, typename Base>
	class EventsBaseImpl : public Base
	{
	public:
		typedef Events Declaration;

		EventsBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->cancel = &Name::cloopcancelDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopcancelDispatcher(Events* self, Status* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::cancel(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = ReferenceCountedImpl<Name, Inherit<VersionedImpl<Name, Inherit<Events> > > > >
	class EventsImpl : public EventsBaseImpl<Name, Base>
	{
	protected:
		EventsImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~EventsImpl()
		{
		}

		virtual void cancel(Status* status) = 0;
	};

	template <typename Name, typename Base>
	class AttachmentBaseImpl : public Base
	{
	public:
		typedef Attachment Declaration;

		AttachmentBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->getInfo = &Name::cloopgetInfoDispatcher;
					this->startTransaction = &Name::cloopstartTransactionDispatcher;
					this->reconnectTransaction = &Name::cloopreconnectTransactionDispatcher;
					this->compileRequest = &Name::cloopcompileRequestDispatcher;
					this->transactRequest = &Name::clooptransactRequestDispatcher;
					this->createBlob = &Name::cloopcreateBlobDispatcher;
					this->openBlob = &Name::cloopopenBlobDispatcher;
					this->getSlice = &Name::cloopgetSliceDispatcher;
					this->putSlice = &Name::cloopputSliceDispatcher;
					this->executeDyn = &Name::cloopexecuteDynDispatcher;
					this->prepare = &Name::cloopprepareDispatcher;
					this->execute = &Name::cloopexecuteDispatcher;
					this->openCursor = &Name::cloopopenCursorDispatcher;
					this->queEvents = &Name::cloopqueEventsDispatcher;
					this->cancelOperation = &Name::cloopcancelOperationDispatcher;
					this->ping = &Name::clooppingDispatcher;
					this->detach = &Name::cloopdetachDispatcher;
					this->dropDatabase = &Name::cloopdropDatabaseDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopgetInfoDispatcher(Attachment* self, Status* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::getInfo(status, itemsLength, items, bufferLength, buffer);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static Transaction* CLOOP_CARG cloopstartTransactionDispatcher(Attachment* self, Status* status, unsigned tpbLength, const unsigned char* tpb) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::startTransaction(status, tpbLength, tpb);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<Transaction*>(0);
			}
		}

		static Transaction* CLOOP_CARG cloopreconnectTransactionDispatcher(Attachment* self, Status* status, unsigned length, const unsigned char* id) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::reconnectTransaction(status, length, id);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<Transaction*>(0);
			}
		}

		static Request* CLOOP_CARG cloopcompileRequestDispatcher(Attachment* self, Status* status, unsigned blrLength, const unsigned char* blr) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::compileRequest(status, blrLength, blr);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<Request*>(0);
			}
		}

		static void CLOOP_CARG clooptransactRequestDispatcher(Attachment* self, Status* status, Transaction* transaction, unsigned blrLength, const unsigned char* blr, unsigned inMsgLength, const unsigned char* inMsg, unsigned outMsgLength, unsigned char* outMsg) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::transactRequest(status, transaction, blrLength, blr, inMsgLength, inMsg, outMsgLength, outMsg);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static Blob* CLOOP_CARG cloopcreateBlobDispatcher(Attachment* self, Status* status, Transaction* transaction, ISC_QUAD* id, unsigned bpbLength, const unsigned char* bpb) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::createBlob(status, transaction, id, bpbLength, bpb);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<Blob*>(0);
			}
		}

		static Blob* CLOOP_CARG cloopopenBlobDispatcher(Attachment* self, Status* status, Transaction* transaction, ISC_QUAD* id, unsigned bpbLength, const unsigned char* bpb) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::openBlob(status, transaction, id, bpbLength, bpb);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<Blob*>(0);
			}
		}

		static int CLOOP_CARG cloopgetSliceDispatcher(Attachment* self, Status* status, Transaction* transaction, ISC_QUAD* id, unsigned sdlLength, const unsigned char* sdl, unsigned paramLength, const unsigned char* param, int sliceLength, unsigned char* slice) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getSlice(status, transaction, id, sdlLength, sdl, paramLength, param, sliceLength, slice);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<int>(0);
			}
		}

		static void CLOOP_CARG cloopputSliceDispatcher(Attachment* self, Status* status, Transaction* transaction, ISC_QUAD* id, unsigned sdlLength, const unsigned char* sdl, unsigned paramLength, const unsigned char* param, int sliceLength, unsigned char* slice) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::putSlice(status, transaction, id, sdlLength, sdl, paramLength, param, sliceLength, slice);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopexecuteDynDispatcher(Attachment* self, Status* status, Transaction* transaction, unsigned length, const unsigned char* dyn) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::executeDyn(status, transaction, length, dyn);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static Statement* CLOOP_CARG cloopprepareDispatcher(Attachment* self, Status* status, Transaction* tra, unsigned stmtLength, const char* sqlStmt, unsigned dialect, unsigned flags) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::prepare(status, tra, stmtLength, sqlStmt, dialect, flags);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<Statement*>(0);
			}
		}

		static Transaction* CLOOP_CARG cloopexecuteDispatcher(Attachment* self, Status* status, Transaction* transaction, unsigned stmtLength, const char* sqlStmt, unsigned dialect, MessageMetadata* inMetadata, void* inBuffer, MessageMetadata* outMetadata, void* outBuffer) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::execute(status, transaction, stmtLength, sqlStmt, dialect, inMetadata, inBuffer, outMetadata, outBuffer);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<Transaction*>(0);
			}
		}

		static ResultSet* CLOOP_CARG cloopopenCursorDispatcher(Attachment* self, Status* status, Transaction* transaction, unsigned stmtLength, const char* sqlStmt, unsigned dialect, MessageMetadata* inMetadata, void* inBuffer, MessageMetadata* outMetadata, const char* cursorName) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::openCursor(status, transaction, stmtLength, sqlStmt, dialect, inMetadata, inBuffer, outMetadata, cursorName);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<ResultSet*>(0);
			}
		}

		static Events* CLOOP_CARG cloopqueEventsDispatcher(Attachment* self, Status* status, EventCallback* callback, unsigned length, const unsigned char* events) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::queEvents(status, callback, length, events);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<Events*>(0);
			}
		}

		static void CLOOP_CARG cloopcancelOperationDispatcher(Attachment* self, Status* status, int option) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::cancelOperation(status, option);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG clooppingDispatcher(Attachment* self, Status* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::ping(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopdetachDispatcher(Attachment* self, Status* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::detach(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopdropDatabaseDispatcher(Attachment* self, Status* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::dropDatabase(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = ReferenceCountedImpl<Name, Inherit<VersionedImpl<Name, Inherit<Attachment> > > > >
	class AttachmentImpl : public AttachmentBaseImpl<Name, Base>
	{
	protected:
		AttachmentImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~AttachmentImpl()
		{
		}

		virtual void getInfo(Status* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) = 0;
		virtual Transaction* startTransaction(Status* status, unsigned tpbLength, const unsigned char* tpb) = 0;
		virtual Transaction* reconnectTransaction(Status* status, unsigned length, const unsigned char* id) = 0;
		virtual Request* compileRequest(Status* status, unsigned blrLength, const unsigned char* blr) = 0;
		virtual void transactRequest(Status* status, Transaction* transaction, unsigned blrLength, const unsigned char* blr, unsigned inMsgLength, const unsigned char* inMsg, unsigned outMsgLength, unsigned char* outMsg) = 0;
		virtual Blob* createBlob(Status* status, Transaction* transaction, ISC_QUAD* id, unsigned bpbLength, const unsigned char* bpb) = 0;
		virtual Blob* openBlob(Status* status, Transaction* transaction, ISC_QUAD* id, unsigned bpbLength, const unsigned char* bpb) = 0;
		virtual int getSlice(Status* status, Transaction* transaction, ISC_QUAD* id, unsigned sdlLength, const unsigned char* sdl, unsigned paramLength, const unsigned char* param, int sliceLength, unsigned char* slice) = 0;
		virtual void putSlice(Status* status, Transaction* transaction, ISC_QUAD* id, unsigned sdlLength, const unsigned char* sdl, unsigned paramLength, const unsigned char* param, int sliceLength, unsigned char* slice) = 0;
		virtual void executeDyn(Status* status, Transaction* transaction, unsigned length, const unsigned char* dyn) = 0;
		virtual Statement* prepare(Status* status, Transaction* tra, unsigned stmtLength, const char* sqlStmt, unsigned dialect, unsigned flags) = 0;
		virtual Transaction* execute(Status* status, Transaction* transaction, unsigned stmtLength, const char* sqlStmt, unsigned dialect, MessageMetadata* inMetadata, void* inBuffer, MessageMetadata* outMetadata, void* outBuffer) = 0;
		virtual ResultSet* openCursor(Status* status, Transaction* transaction, unsigned stmtLength, const char* sqlStmt, unsigned dialect, MessageMetadata* inMetadata, void* inBuffer, MessageMetadata* outMetadata, const char* cursorName) = 0;
		virtual Events* queEvents(Status* status, EventCallback* callback, unsigned length, const unsigned char* events) = 0;
		virtual void cancelOperation(Status* status, int option) = 0;
		virtual void ping(Status* status) = 0;
		virtual void detach(Status* status) = 0;
		virtual void dropDatabase(Status* status) = 0;
	};

	template <typename Name, typename Base>
	class ServiceBaseImpl : public Base
	{
	public:
		typedef Service Declaration;

		ServiceBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->detach = &Name::cloopdetachDispatcher;
					this->query = &Name::cloopqueryDispatcher;
					this->start = &Name::cloopstartDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopdetachDispatcher(Service* self, Status* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::detach(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopqueryDispatcher(Service* self, Status* status, unsigned sendLength, const unsigned char* sendItems, unsigned receiveLength, const unsigned char* receiveItems, unsigned bufferLength, unsigned char* buffer) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::query(status, sendLength, sendItems, receiveLength, receiveItems, bufferLength, buffer);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopstartDispatcher(Service* self, Status* status, unsigned spbLength, const unsigned char* spb) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::start(status, spbLength, spb);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = ReferenceCountedImpl<Name, Inherit<VersionedImpl<Name, Inherit<Service> > > > >
	class ServiceImpl : public ServiceBaseImpl<Name, Base>
	{
	protected:
		ServiceImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ServiceImpl()
		{
		}

		virtual void detach(Status* status) = 0;
		virtual void query(Status* status, unsigned sendLength, const unsigned char* sendItems, unsigned receiveLength, const unsigned char* receiveItems, unsigned bufferLength, unsigned char* buffer) = 0;
		virtual void start(Status* status, unsigned spbLength, const unsigned char* spb) = 0;
	};

	template <typename Name, typename Base>
	class ProviderBaseImpl : public Base
	{
	public:
		typedef Provider Declaration;

		ProviderBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->setOwner = &Name::cloopsetOwnerDispatcher;
					this->getOwner = &Name::cloopgetOwnerDispatcher;
					this->attachDatabase = &Name::cloopattachDatabaseDispatcher;
					this->createDatabase = &Name::cloopcreateDatabaseDispatcher;
					this->attachServiceManager = &Name::cloopattachServiceManagerDispatcher;
					this->shutdown = &Name::cloopshutdownDispatcher;
					this->setDbCryptCallback = &Name::cloopsetDbCryptCallbackDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static Attachment* CLOOP_CARG cloopattachDatabaseDispatcher(Provider* self, Status* status, const char* fileName, unsigned dpbLength, const unsigned char* dpb) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::attachDatabase(status, fileName, dpbLength, dpb);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<Attachment*>(0);
			}
		}

		static Attachment* CLOOP_CARG cloopcreateDatabaseDispatcher(Provider* self, Status* status, const char* fileName, unsigned dpbLength, const unsigned char* dpb) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::createDatabase(status, fileName, dpbLength, dpb);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<Attachment*>(0);
			}
		}

		static Service* CLOOP_CARG cloopattachServiceManagerDispatcher(Provider* self, Status* status, const char* service, unsigned spbLength, const unsigned char* spb) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::attachServiceManager(status, service, spbLength, spb);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<Service*>(0);
			}
		}

		static void CLOOP_CARG cloopshutdownDispatcher(Provider* self, Status* status, unsigned timeout, const int reason) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::shutdown(status, timeout, reason);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopsetDbCryptCallbackDispatcher(Provider* self, Status* status, CryptKeyCallback* cryptCallback) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setDbCryptCallback(status, cryptCallback);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopsetOwnerDispatcher(PluginBase* self, ReferenceCounted* r) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setOwner(r);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static ReferenceCounted* CLOOP_CARG cloopgetOwnerDispatcher(PluginBase* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOwner();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ReferenceCounted*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = PluginBaseImpl<Name, Inherit<ReferenceCountedImpl<Name, Inherit<VersionedImpl<Name, Inherit<Provider> > > > > > >
	class ProviderImpl : public ProviderBaseImpl<Name, Base>
	{
	protected:
		ProviderImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ProviderImpl()
		{
		}

		virtual Attachment* attachDatabase(Status* status, const char* fileName, unsigned dpbLength, const unsigned char* dpb) = 0;
		virtual Attachment* createDatabase(Status* status, const char* fileName, unsigned dpbLength, const unsigned char* dpb) = 0;
		virtual Service* attachServiceManager(Status* status, const char* service, unsigned spbLength, const unsigned char* spb) = 0;
		virtual void shutdown(Status* status, unsigned timeout, const int reason) = 0;
		virtual void setDbCryptCallback(Status* status, CryptKeyCallback* cryptCallback) = 0;
	};

	template <typename Name, typename Base>
	class DtcStartBaseImpl : public Base
	{
	public:
		typedef DtcStart Declaration;

		DtcStartBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->dispose = &Name::cloopdisposeDispatcher;
					this->setComponent = &Name::cloopsetComponentDispatcher;
					this->setWithParam = &Name::cloopsetWithParamDispatcher;
					this->getCount = &Name::cloopgetCountDispatcher;
					this->getAttachment = &Name::cloopgetAttachmentDispatcher;
					this->getTpb = &Name::cloopgetTpbDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopsetComponentDispatcher(DtcStart* self, Status* status, Attachment* att) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setComponent(status, att);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopsetWithParamDispatcher(DtcStart* self, Status* status, Attachment* att, unsigned length, const unsigned char* tpb) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setWithParam(status, att, length, tpb);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static unsigned CLOOP_CARG cloopgetCountDispatcher(DtcStart* self, Status* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getCount(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<unsigned>(0);
			}
		}

		static Attachment* CLOOP_CARG cloopgetAttachmentDispatcher(DtcStart* self, Status* status, unsigned pos) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getAttachment(status, pos);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<Attachment*>(0);
			}
		}

		static const unsigned char* CLOOP_CARG cloopgetTpbDispatcher(DtcStart* self, Status* status, unsigned pos, unsigned* length) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getTpb(status, pos, length);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<const unsigned char*>(0);
			}
		}

		static void CLOOP_CARG cloopdisposeDispatcher(Disposable* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::dispose();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = DisposableImpl<Name, Inherit<VersionedImpl<Name, Inherit<DtcStart> > > > >
	class DtcStartImpl : public DtcStartBaseImpl<Name, Base>
	{
	protected:
		DtcStartImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~DtcStartImpl()
		{
		}

		virtual void setComponent(Status* status, Attachment* att) = 0;
		virtual void setWithParam(Status* status, Attachment* att, unsigned length, const unsigned char* tpb) = 0;
		virtual unsigned getCount(Status* status) = 0;
		virtual Attachment* getAttachment(Status* status, unsigned pos) = 0;
		virtual const unsigned char* getTpb(Status* status, unsigned pos, unsigned* length) = 0;
	};

	template <typename Name, typename Base>
	class DtcBaseImpl : public Base
	{
	public:
		typedef Dtc Declaration;

		DtcBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->start = &Name::cloopstartDispatcher;
					this->join = &Name::cloopjoinDispatcher;
					this->startBuilder = &Name::cloopstartBuilderDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static Transaction* CLOOP_CARG cloopstartDispatcher(Dtc* self, Status* status, DtcStart* components) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::start(status, components);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<Transaction*>(0);
			}
		}

		static Transaction* CLOOP_CARG cloopjoinDispatcher(Dtc* self, Status* status, Transaction* one, Transaction* two) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::join(status, one, two);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<Transaction*>(0);
			}
		}

		static DtcStart* CLOOP_CARG cloopstartBuilderDispatcher(Dtc* self, Status* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::startBuilder(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<DtcStart*>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = VersionedImpl<Name, Inherit<Dtc> > >
	class DtcImpl : public DtcBaseImpl<Name, Base>
	{
	protected:
		DtcImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~DtcImpl()
		{
		}

		virtual Transaction* start(Status* status, DtcStart* components) = 0;
		virtual Transaction* join(Status* status, Transaction* one, Transaction* two) = 0;
		virtual DtcStart* startBuilder(Status* status) = 0;
	};

	template <typename Name, typename Base>
	class AuthBaseImpl : public Base
	{
	public:
		typedef Auth Declaration;

		AuthBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->setOwner = &Name::cloopsetOwnerDispatcher;
					this->getOwner = &Name::cloopgetOwnerDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopsetOwnerDispatcher(PluginBase* self, ReferenceCounted* r) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setOwner(r);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static ReferenceCounted* CLOOP_CARG cloopgetOwnerDispatcher(PluginBase* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOwner();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ReferenceCounted*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = PluginBaseImpl<Name, Inherit<ReferenceCountedImpl<Name, Inherit<VersionedImpl<Name, Inherit<Auth> > > > > > >
	class AuthImpl : public AuthBaseImpl<Name, Base>
	{
	protected:
		AuthImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~AuthImpl()
		{
		}

	};

	template <typename Name, typename Base>
	class WriterBaseImpl : public Base
	{
	public:
		typedef Writer Declaration;

		WriterBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->reset = &Name::cloopresetDispatcher;
					this->add = &Name::cloopaddDispatcher;
					this->setType = &Name::cloopsetTypeDispatcher;
					this->setDb = &Name::cloopsetDbDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopresetDispatcher(Writer* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::reset();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static void CLOOP_CARG cloopaddDispatcher(Writer* self, Status* status, const char* name) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::add(status, name);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopsetTypeDispatcher(Writer* self, Status* status, const char* value) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setType(status, value);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopsetDbDispatcher(Writer* self, Status* status, const char* value) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setDb(status, value);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = VersionedImpl<Name, Inherit<Writer> > >
	class WriterImpl : public WriterBaseImpl<Name, Base>
	{
	protected:
		WriterImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~WriterImpl()
		{
		}

		virtual void reset() = 0;
		virtual void add(Status* status, const char* name) = 0;
		virtual void setType(Status* status, const char* value) = 0;
		virtual void setDb(Status* status, const char* value) = 0;
	};

	template <typename Name, typename Base>
	class ServerBlockBaseImpl : public Base
	{
	public:
		typedef ServerBlock Declaration;

		ServerBlockBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getLogin = &Name::cloopgetLoginDispatcher;
					this->getData = &Name::cloopgetDataDispatcher;
					this->putData = &Name::cloopputDataDispatcher;
					this->putKey = &Name::cloopputKeyDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetLoginDispatcher(ServerBlock* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getLogin();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const unsigned char* CLOOP_CARG cloopgetDataDispatcher(ServerBlock* self, unsigned* length) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getData(length);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const unsigned char*>(0);
			}
		}

		static void CLOOP_CARG cloopputDataDispatcher(ServerBlock* self, Status* status, unsigned length, const void* data) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::putData(status, length, data);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopputKeyDispatcher(ServerBlock* self, Status* status, FbCryptKey* cryptKey) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::putKey(status, cryptKey);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = VersionedImpl<Name, Inherit<ServerBlock> > >
	class ServerBlockImpl : public ServerBlockBaseImpl<Name, Base>
	{
	protected:
		ServerBlockImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ServerBlockImpl()
		{
		}

		virtual const char* getLogin() = 0;
		virtual const unsigned char* getData(unsigned* length) = 0;
		virtual void putData(Status* status, unsigned length, const void* data) = 0;
		virtual void putKey(Status* status, FbCryptKey* cryptKey) = 0;
	};

	template <typename Name, typename Base>
	class ClientBlockBaseImpl : public Base
	{
	public:
		typedef ClientBlock Declaration;

		ClientBlockBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->getLogin = &Name::cloopgetLoginDispatcher;
					this->getPassword = &Name::cloopgetPasswordDispatcher;
					this->getData = &Name::cloopgetDataDispatcher;
					this->putData = &Name::cloopputDataDispatcher;
					this->putKey = &Name::cloopputKeyDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetLoginDispatcher(ClientBlock* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getLogin();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetPasswordDispatcher(ClientBlock* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPassword();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const unsigned char* CLOOP_CARG cloopgetDataDispatcher(ClientBlock* self, unsigned* length) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getData(length);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const unsigned char*>(0);
			}
		}

		static void CLOOP_CARG cloopputDataDispatcher(ClientBlock* self, Status* status, unsigned length, const void* data) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::putData(status, length, data);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopputKeyDispatcher(ClientBlock* self, Status* status, FbCryptKey* cryptKey) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::putKey(status, cryptKey);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = ReferenceCountedImpl<Name, Inherit<VersionedImpl<Name, Inherit<ClientBlock> > > > >
	class ClientBlockImpl : public ClientBlockBaseImpl<Name, Base>
	{
	protected:
		ClientBlockImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ClientBlockImpl()
		{
		}

		virtual const char* getLogin() = 0;
		virtual const char* getPassword() = 0;
		virtual const unsigned char* getData(unsigned* length) = 0;
		virtual void putData(Status* status, unsigned length, const void* data) = 0;
		virtual void putKey(Status* status, FbCryptKey* cryptKey) = 0;
	};

	template <typename Name, typename Base>
	class ServerBaseImpl : public Base
	{
	public:
		typedef Server Declaration;

		ServerBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->setOwner = &Name::cloopsetOwnerDispatcher;
					this->getOwner = &Name::cloopgetOwnerDispatcher;
					this->authenticate = &Name::cloopauthenticateDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static int CLOOP_CARG cloopauthenticateDispatcher(Server* self, Status* status, ServerBlock* sBlock, Writer* writerInterface) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::authenticate(status, sBlock, writerInterface);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<int>(0);
			}
		}

		static void CLOOP_CARG cloopsetOwnerDispatcher(PluginBase* self, ReferenceCounted* r) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setOwner(r);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static ReferenceCounted* CLOOP_CARG cloopgetOwnerDispatcher(PluginBase* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOwner();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ReferenceCounted*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = AuthImpl<Name, Inherit<PluginBaseImpl<Name, Inherit<ReferenceCountedImpl<Name, Inherit<VersionedImpl<Name, Inherit<Server> > > > > > > > >
	class ServerImpl : public ServerBaseImpl<Name, Base>
	{
	protected:
		ServerImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ServerImpl()
		{
		}

		virtual int authenticate(Status* status, ServerBlock* sBlock, Writer* writerInterface) = 0;
	};

	template <typename Name, typename Base>
	class ClientBaseImpl : public Base
	{
	public:
		typedef Client Declaration;

		ClientBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->setOwner = &Name::cloopsetOwnerDispatcher;
					this->getOwner = &Name::cloopgetOwnerDispatcher;
					this->authenticate = &Name::cloopauthenticateDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static int CLOOP_CARG cloopauthenticateDispatcher(Client* self, Status* status, ClientBlock* cBlock) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::authenticate(status, cBlock);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<int>(0);
			}
		}

		static void CLOOP_CARG cloopsetOwnerDispatcher(PluginBase* self, ReferenceCounted* r) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setOwner(r);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static ReferenceCounted* CLOOP_CARG cloopgetOwnerDispatcher(PluginBase* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOwner();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ReferenceCounted*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = AuthImpl<Name, Inherit<PluginBaseImpl<Name, Inherit<ReferenceCountedImpl<Name, Inherit<VersionedImpl<Name, Inherit<Client> > > > > > > > >
	class ClientImpl : public ClientBaseImpl<Name, Base>
	{
	protected:
		ClientImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ClientImpl()
		{
		}

		virtual int authenticate(Status* status, ClientBlock* cBlock) = 0;
	};

	template <typename Name, typename Base>
	class UserFieldBaseImpl : public Base
	{
	public:
		typedef UserField Declaration;

		UserFieldBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->entered = &Name::cloopenteredDispatcher;
					this->specified = &Name::cloopspecifiedDispatcher;
					this->setEntered = &Name::cloopsetEnteredDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static int CLOOP_CARG cloopenteredDispatcher(UserField* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::entered();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static int CLOOP_CARG cloopspecifiedDispatcher(UserField* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::specified();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static void CLOOP_CARG cloopsetEnteredDispatcher(UserField* self, Status* status, int newValue) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setEntered(status, newValue);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = VersionedImpl<Name, Inherit<UserField> > >
	class UserFieldImpl : public UserFieldBaseImpl<Name, Base>
	{
	protected:
		UserFieldImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~UserFieldImpl()
		{
		}

		virtual int entered() = 0;
		virtual int specified() = 0;
		virtual void setEntered(Status* status, int newValue) = 0;
	};

	template <typename Name, typename Base>
	class CharUserFieldBaseImpl : public Base
	{
	public:
		typedef CharUserField Declaration;

		CharUserFieldBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->entered = &Name::cloopenteredDispatcher;
					this->specified = &Name::cloopspecifiedDispatcher;
					this->setEntered = &Name::cloopsetEnteredDispatcher;
					this->get = &Name::cloopgetDispatcher;
					this->set = &Name::cloopsetDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetDispatcher(CharUserField* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::get();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static void CLOOP_CARG cloopsetDispatcher(CharUserField* self, Status* status, const char* newValue) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::set(status, newValue);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static int CLOOP_CARG cloopenteredDispatcher(UserField* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::entered();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static int CLOOP_CARG cloopspecifiedDispatcher(UserField* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::specified();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static void CLOOP_CARG cloopsetEnteredDispatcher(UserField* self, Status* status, int newValue) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setEntered(status, newValue);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = UserFieldImpl<Name, Inherit<VersionedImpl<Name, Inherit<CharUserField> > > > >
	class CharUserFieldImpl : public CharUserFieldBaseImpl<Name, Base>
	{
	protected:
		CharUserFieldImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~CharUserFieldImpl()
		{
		}

		virtual const char* get() = 0;
		virtual void set(Status* status, const char* newValue) = 0;
	};

	template <typename Name, typename Base>
	class IntUserFieldBaseImpl : public Base
	{
	public:
		typedef IntUserField Declaration;

		IntUserFieldBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->entered = &Name::cloopenteredDispatcher;
					this->specified = &Name::cloopspecifiedDispatcher;
					this->setEntered = &Name::cloopsetEnteredDispatcher;
					this->get = &Name::cloopgetDispatcher;
					this->set = &Name::cloopsetDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static int CLOOP_CARG cloopgetDispatcher(IntUserField* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::get();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static void CLOOP_CARG cloopsetDispatcher(IntUserField* self, Status* status, int newValue) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::set(status, newValue);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static int CLOOP_CARG cloopenteredDispatcher(UserField* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::entered();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static int CLOOP_CARG cloopspecifiedDispatcher(UserField* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::specified();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static void CLOOP_CARG cloopsetEnteredDispatcher(UserField* self, Status* status, int newValue) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setEntered(status, newValue);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = UserFieldImpl<Name, Inherit<VersionedImpl<Name, Inherit<IntUserField> > > > >
	class IntUserFieldImpl : public IntUserFieldBaseImpl<Name, Base>
	{
	protected:
		IntUserFieldImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IntUserFieldImpl()
		{
		}

		virtual int get() = 0;
		virtual void set(Status* status, int newValue) = 0;
	};

	template <typename Name, typename Base>
	class UserBaseImpl : public Base
	{
	public:
		typedef User Declaration;

		UserBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->operation = &Name::cloopoperationDispatcher;
					this->userName = &Name::cloopuserNameDispatcher;
					this->password = &Name::clooppasswordDispatcher;
					this->firstName = &Name::cloopfirstNameDispatcher;
					this->lastName = &Name::clooplastNameDispatcher;
					this->middleName = &Name::cloopmiddleNameDispatcher;
					this->comment = &Name::cloopcommentDispatcher;
					this->attributes = &Name::cloopattributesDispatcher;
					this->active = &Name::cloopactiveDispatcher;
					this->admin = &Name::cloopadminDispatcher;
					this->clear = &Name::cloopclearDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static int CLOOP_CARG cloopoperationDispatcher(User* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::operation();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static CharUserField* CLOOP_CARG cloopuserNameDispatcher(User* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::userName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<CharUserField*>(0);
			}
		}

		static CharUserField* CLOOP_CARG clooppasswordDispatcher(User* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::password();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<CharUserField*>(0);
			}
		}

		static CharUserField* CLOOP_CARG cloopfirstNameDispatcher(User* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::firstName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<CharUserField*>(0);
			}
		}

		static CharUserField* CLOOP_CARG clooplastNameDispatcher(User* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::lastName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<CharUserField*>(0);
			}
		}

		static CharUserField* CLOOP_CARG cloopmiddleNameDispatcher(User* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::middleName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<CharUserField*>(0);
			}
		}

		static CharUserField* CLOOP_CARG cloopcommentDispatcher(User* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::comment();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<CharUserField*>(0);
			}
		}

		static CharUserField* CLOOP_CARG cloopattributesDispatcher(User* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::attributes();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<CharUserField*>(0);
			}
		}

		static IntUserField* CLOOP_CARG cloopactiveDispatcher(User* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::active();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IntUserField*>(0);
			}
		}

		static IntUserField* CLOOP_CARG cloopadminDispatcher(User* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::admin();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IntUserField*>(0);
			}
		}

		static void CLOOP_CARG cloopclearDispatcher(User* self, Status* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::clear(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = VersionedImpl<Name, Inherit<User> > >
	class UserImpl : public UserBaseImpl<Name, Base>
	{
	protected:
		UserImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~UserImpl()
		{
		}

		virtual int operation() = 0;
		virtual CharUserField* userName() = 0;
		virtual CharUserField* password() = 0;
		virtual CharUserField* firstName() = 0;
		virtual CharUserField* lastName() = 0;
		virtual CharUserField* middleName() = 0;
		virtual CharUserField* comment() = 0;
		virtual CharUserField* attributes() = 0;
		virtual IntUserField* active() = 0;
		virtual IntUserField* admin() = 0;
		virtual void clear(Status* status) = 0;
	};

	template <typename Name, typename Base>
	class ListUsersBaseImpl : public Base
	{
	public:
		typedef ListUsers Declaration;

		ListUsersBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->list = &Name::clooplistDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG clooplistDispatcher(ListUsers* self, Status* status, User* user) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::list(status, user);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = VersionedImpl<Name, Inherit<ListUsers> > >
	class ListUsersImpl : public ListUsersBaseImpl<Name, Base>
	{
	protected:
		ListUsersImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ListUsersImpl()
		{
		}

		virtual void list(Status* status, User* user) = 0;
	};

	template <typename Name, typename Base>
	class LogonInfoBaseImpl : public Base
	{
	public:
		typedef LogonInfo Declaration;

		LogonInfoBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->name = &Name::cloopnameDispatcher;
					this->role = &Name::clooproleDispatcher;
					this->networkProtocol = &Name::cloopnetworkProtocolDispatcher;
					this->remoteAddress = &Name::cloopremoteAddressDispatcher;
					this->authBlock = &Name::cloopauthBlockDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopnameDispatcher(LogonInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::name();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG clooproleDispatcher(LogonInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::role();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopnetworkProtocolDispatcher(LogonInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::networkProtocol();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopremoteAddressDispatcher(LogonInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::remoteAddress();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const unsigned char* CLOOP_CARG cloopauthBlockDispatcher(LogonInfo* self, unsigned* length) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::authBlock(length);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const unsigned char*>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = VersionedImpl<Name, Inherit<LogonInfo> > >
	class LogonInfoImpl : public LogonInfoBaseImpl<Name, Base>
	{
	protected:
		LogonInfoImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~LogonInfoImpl()
		{
		}

		virtual const char* name() = 0;
		virtual const char* role() = 0;
		virtual const char* networkProtocol() = 0;
		virtual const char* remoteAddress() = 0;
		virtual const unsigned char* authBlock(unsigned* length) = 0;
	};

	template <typename Name, typename Base>
	class ManagementBaseImpl : public Base
	{
	public:
		typedef Management Declaration;

		ManagementBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->setOwner = &Name::cloopsetOwnerDispatcher;
					this->getOwner = &Name::cloopgetOwnerDispatcher;
					this->start = &Name::cloopstartDispatcher;
					this->execute = &Name::cloopexecuteDispatcher;
					this->commit = &Name::cloopcommitDispatcher;
					this->rollback = &Name::clooprollbackDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopstartDispatcher(Management* self, Status* status, LogonInfo* logonInfo) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::start(status, logonInfo);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static int CLOOP_CARG cloopexecuteDispatcher(Management* self, Status* status, User* user, ListUsers* callback) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::execute(status, user, callback);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<int>(0);
			}
		}

		static void CLOOP_CARG cloopcommitDispatcher(Management* self, Status* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::commit(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG clooprollbackDispatcher(Management* self, Status* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::rollback(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopsetOwnerDispatcher(PluginBase* self, ReferenceCounted* r) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setOwner(r);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static ReferenceCounted* CLOOP_CARG cloopgetOwnerDispatcher(PluginBase* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOwner();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ReferenceCounted*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = PluginBaseImpl<Name, Inherit<ReferenceCountedImpl<Name, Inherit<VersionedImpl<Name, Inherit<Management> > > > > > >
	class ManagementImpl : public ManagementBaseImpl<Name, Base>
	{
	protected:
		ManagementImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ManagementImpl()
		{
		}

		virtual void start(Status* status, LogonInfo* logonInfo) = 0;
		virtual int execute(Status* status, User* user, ListUsers* callback) = 0;
		virtual void commit(Status* status) = 0;
		virtual void rollback(Status* status) = 0;
	};

	template <typename Name, typename Base>
	class WireCryptPluginBaseImpl : public Base
	{
	public:
		typedef WireCryptPlugin Declaration;

		WireCryptPluginBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->setOwner = &Name::cloopsetOwnerDispatcher;
					this->getOwner = &Name::cloopgetOwnerDispatcher;
					this->getKnownTypes = &Name::cloopgetKnownTypesDispatcher;
					this->setKey = &Name::cloopsetKeyDispatcher;
					this->encrypt = &Name::cloopencryptDispatcher;
					this->decrypt = &Name::cloopdecryptDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetKnownTypesDispatcher(WireCryptPlugin* self, Status* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getKnownTypes(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<const char*>(0);
			}
		}

		static void CLOOP_CARG cloopsetKeyDispatcher(WireCryptPlugin* self, Status* status, FbCryptKey* key) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setKey(status, key);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopencryptDispatcher(WireCryptPlugin* self, Status* status, unsigned length, const void* from, void* to) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::encrypt(status, length, from, to);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopdecryptDispatcher(WireCryptPlugin* self, Status* status, unsigned length, const void* from, void* to) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::decrypt(status, length, from, to);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopsetOwnerDispatcher(PluginBase* self, ReferenceCounted* r) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setOwner(r);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static ReferenceCounted* CLOOP_CARG cloopgetOwnerDispatcher(PluginBase* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOwner();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ReferenceCounted*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = PluginBaseImpl<Name, Inherit<ReferenceCountedImpl<Name, Inherit<VersionedImpl<Name, Inherit<WireCryptPlugin> > > > > > >
	class WireCryptPluginImpl : public WireCryptPluginBaseImpl<Name, Base>
	{
	protected:
		WireCryptPluginImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~WireCryptPluginImpl()
		{
		}

		virtual const char* getKnownTypes(Status* status) = 0;
		virtual void setKey(Status* status, FbCryptKey* key) = 0;
		virtual void encrypt(Status* status, unsigned length, const void* from, void* to) = 0;
		virtual void decrypt(Status* status, unsigned length, const void* from, void* to) = 0;
	};

	template <typename Name, typename Base>
	class CryptKeyCallbackBaseImpl : public Base
	{
	public:
		typedef CryptKeyCallback Declaration;

		CryptKeyCallbackBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->callback = &Name::cloopcallbackDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static unsigned CLOOP_CARG cloopcallbackDispatcher(CryptKeyCallback* self, unsigned dataLength, const void* data, unsigned bufferLength, void* buffer) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::callback(dataLength, data, bufferLength, buffer);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = VersionedImpl<Name, Inherit<CryptKeyCallback> > >
	class CryptKeyCallbackImpl : public CryptKeyCallbackBaseImpl<Name, Base>
	{
	protected:
		CryptKeyCallbackImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~CryptKeyCallbackImpl()
		{
		}

		virtual unsigned callback(unsigned dataLength, const void* data, unsigned bufferLength, void* buffer) = 0;
	};

	template <typename Name, typename Base>
	class KeyHolderPluginBaseImpl : public Base
	{
	public:
		typedef KeyHolderPlugin Declaration;

		KeyHolderPluginBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->setOwner = &Name::cloopsetOwnerDispatcher;
					this->getOwner = &Name::cloopgetOwnerDispatcher;
					this->keyCallback = &Name::cloopkeyCallbackDispatcher;
					this->keyHandle = &Name::cloopkeyHandleDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static int CLOOP_CARG cloopkeyCallbackDispatcher(KeyHolderPlugin* self, Status* status, CryptKeyCallback* callback) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::keyCallback(status, callback);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<int>(0);
			}
		}

		static CryptKeyCallback* CLOOP_CARG cloopkeyHandleDispatcher(KeyHolderPlugin* self, Status* status, const char* keyName) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::keyHandle(status, keyName);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<CryptKeyCallback*>(0);
			}
		}

		static void CLOOP_CARG cloopsetOwnerDispatcher(PluginBase* self, ReferenceCounted* r) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setOwner(r);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static ReferenceCounted* CLOOP_CARG cloopgetOwnerDispatcher(PluginBase* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOwner();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ReferenceCounted*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = PluginBaseImpl<Name, Inherit<ReferenceCountedImpl<Name, Inherit<VersionedImpl<Name, Inherit<KeyHolderPlugin> > > > > > >
	class KeyHolderPluginImpl : public KeyHolderPluginBaseImpl<Name, Base>
	{
	protected:
		KeyHolderPluginImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~KeyHolderPluginImpl()
		{
		}

		virtual int keyCallback(Status* status, CryptKeyCallback* callback) = 0;
		virtual CryptKeyCallback* keyHandle(Status* status, const char* keyName) = 0;
	};

	template <typename Name, typename Base>
	class DbCryptPluginBaseImpl : public Base
	{
	public:
		typedef DbCryptPlugin Declaration;

		DbCryptPluginBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->setOwner = &Name::cloopsetOwnerDispatcher;
					this->getOwner = &Name::cloopgetOwnerDispatcher;
					this->setKey = &Name::cloopsetKeyDispatcher;
					this->encrypt = &Name::cloopencryptDispatcher;
					this->decrypt = &Name::cloopdecryptDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopsetKeyDispatcher(DbCryptPlugin* self, Status* status, unsigned length, KeyHolderPlugin** sources) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setKey(status, length, sources);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopencryptDispatcher(DbCryptPlugin* self, Status* status, unsigned length, const void* from, void* to) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::encrypt(status, length, from, to);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopdecryptDispatcher(DbCryptPlugin* self, Status* status, unsigned length, const void* from, void* to) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::decrypt(status, length, from, to);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopsetOwnerDispatcher(PluginBase* self, ReferenceCounted* r) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setOwner(r);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static ReferenceCounted* CLOOP_CARG cloopgetOwnerDispatcher(PluginBase* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOwner();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ReferenceCounted*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = PluginBaseImpl<Name, Inherit<ReferenceCountedImpl<Name, Inherit<VersionedImpl<Name, Inherit<DbCryptPlugin> > > > > > >
	class DbCryptPluginImpl : public DbCryptPluginBaseImpl<Name, Base>
	{
	protected:
		DbCryptPluginImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~DbCryptPluginImpl()
		{
		}

		virtual void setKey(Status* status, unsigned length, KeyHolderPlugin** sources) = 0;
		virtual void encrypt(Status* status, unsigned length, const void* from, void* to) = 0;
		virtual void decrypt(Status* status, unsigned length, const void* from, void* to) = 0;
	};

	template <typename Name, typename Base>
	class ExternalContextBaseImpl : public Base
	{
	public:
		typedef ExternalContext Declaration;

		ExternalContextBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getMaster = &Name::cloopgetMasterDispatcher;
					this->getEngine = &Name::cloopgetEngineDispatcher;
					this->getAttachment = &Name::cloopgetAttachmentDispatcher;
					this->getTransaction = &Name::cloopgetTransactionDispatcher;
					this->getUserName = &Name::cloopgetUserNameDispatcher;
					this->getDatabaseName = &Name::cloopgetDatabaseNameDispatcher;
					this->getClientCharSet = &Name::cloopgetClientCharSetDispatcher;
					this->obtainInfoCode = &Name::cloopobtainInfoCodeDispatcher;
					this->getInfo = &Name::cloopgetInfoDispatcher;
					this->setInfo = &Name::cloopsetInfoDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static Master* CLOOP_CARG cloopgetMasterDispatcher(ExternalContext* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getMaster();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<Master*>(0);
			}
		}

		static ExternalEngine* CLOOP_CARG cloopgetEngineDispatcher(ExternalContext* self, Status* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getEngine(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<ExternalEngine*>(0);
			}
		}

		static Attachment* CLOOP_CARG cloopgetAttachmentDispatcher(ExternalContext* self, Status* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getAttachment(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<Attachment*>(0);
			}
		}

		static Transaction* CLOOP_CARG cloopgetTransactionDispatcher(ExternalContext* self, Status* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getTransaction(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<Transaction*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetUserNameDispatcher(ExternalContext* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getUserName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetDatabaseNameDispatcher(ExternalContext* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getDatabaseName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetClientCharSetDispatcher(ExternalContext* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getClientCharSet();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static int CLOOP_CARG cloopobtainInfoCodeDispatcher(ExternalContext* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::obtainInfoCode();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static void* CLOOP_CARG cloopgetInfoDispatcher(ExternalContext* self, int code) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getInfo(code);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<void*>(0);
			}
		}

		static void* CLOOP_CARG cloopsetInfoDispatcher(ExternalContext* self, int code, void* value) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::setInfo(code, value);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<void*>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = VersionedImpl<Name, Inherit<ExternalContext> > >
	class ExternalContextImpl : public ExternalContextBaseImpl<Name, Base>
	{
	protected:
		ExternalContextImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ExternalContextImpl()
		{
		}

		virtual Master* getMaster() = 0;
		virtual ExternalEngine* getEngine(Status* status) = 0;
		virtual Attachment* getAttachment(Status* status) = 0;
		virtual Transaction* getTransaction(Status* status) = 0;
		virtual const char* getUserName() = 0;
		virtual const char* getDatabaseName() = 0;
		virtual const char* getClientCharSet() = 0;
		virtual int obtainInfoCode() = 0;
		virtual void* getInfo(int code) = 0;
		virtual void* setInfo(int code, void* value) = 0;
	};

	template <typename Name, typename Base>
	class ExternalResultSetBaseImpl : public Base
	{
	public:
		typedef ExternalResultSet Declaration;

		ExternalResultSetBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->dispose = &Name::cloopdisposeDispatcher;
					this->fetch = &Name::cloopfetchDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static FB_BOOLEAN CLOOP_CARG cloopfetchDispatcher(ExternalResultSet* self, Status* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::fetch(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static void CLOOP_CARG cloopdisposeDispatcher(Disposable* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::dispose();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = DisposableImpl<Name, Inherit<VersionedImpl<Name, Inherit<ExternalResultSet> > > > >
	class ExternalResultSetImpl : public ExternalResultSetBaseImpl<Name, Base>
	{
	protected:
		ExternalResultSetImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ExternalResultSetImpl()
		{
		}

		virtual FB_BOOLEAN fetch(Status* status) = 0;
	};

	template <typename Name, typename Base>
	class ExternalFunctionBaseImpl : public Base
	{
	public:
		typedef ExternalFunction Declaration;

		ExternalFunctionBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->dispose = &Name::cloopdisposeDispatcher;
					this->getCharSet = &Name::cloopgetCharSetDispatcher;
					this->execute = &Name::cloopexecuteDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopgetCharSetDispatcher(ExternalFunction* self, Status* status, ExternalContext* context, char* name, unsigned nameSize) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::getCharSet(status, context, name, nameSize);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopexecuteDispatcher(ExternalFunction* self, Status* status, ExternalContext* context, void* inMsg, void* outMsg) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::execute(status, context, inMsg, outMsg);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopdisposeDispatcher(Disposable* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::dispose();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = DisposableImpl<Name, Inherit<VersionedImpl<Name, Inherit<ExternalFunction> > > > >
	class ExternalFunctionImpl : public ExternalFunctionBaseImpl<Name, Base>
	{
	protected:
		ExternalFunctionImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ExternalFunctionImpl()
		{
		}

		virtual void getCharSet(Status* status, ExternalContext* context, char* name, unsigned nameSize) = 0;
		virtual void execute(Status* status, ExternalContext* context, void* inMsg, void* outMsg) = 0;
	};

	template <typename Name, typename Base>
	class ExternalProcedureBaseImpl : public Base
	{
	public:
		typedef ExternalProcedure Declaration;

		ExternalProcedureBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->dispose = &Name::cloopdisposeDispatcher;
					this->getCharSet = &Name::cloopgetCharSetDispatcher;
					this->open = &Name::cloopopenDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopgetCharSetDispatcher(ExternalProcedure* self, Status* status, ExternalContext* context, char* name, unsigned nameSize) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::getCharSet(status, context, name, nameSize);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static ExternalResultSet* CLOOP_CARG cloopopenDispatcher(ExternalProcedure* self, Status* status, ExternalContext* context, void* inMsg, void* outMsg) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::open(status, context, inMsg, outMsg);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<ExternalResultSet*>(0);
			}
		}

		static void CLOOP_CARG cloopdisposeDispatcher(Disposable* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::dispose();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = DisposableImpl<Name, Inherit<VersionedImpl<Name, Inherit<ExternalProcedure> > > > >
	class ExternalProcedureImpl : public ExternalProcedureBaseImpl<Name, Base>
	{
	protected:
		ExternalProcedureImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ExternalProcedureImpl()
		{
		}

		virtual void getCharSet(Status* status, ExternalContext* context, char* name, unsigned nameSize) = 0;
		virtual ExternalResultSet* open(Status* status, ExternalContext* context, void* inMsg, void* outMsg) = 0;
	};

	template <typename Name, typename Base>
	class ExternalTriggerBaseImpl : public Base
	{
	public:
		typedef ExternalTrigger Declaration;

		ExternalTriggerBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->dispose = &Name::cloopdisposeDispatcher;
					this->getCharSet = &Name::cloopgetCharSetDispatcher;
					this->execute = &Name::cloopexecuteDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopgetCharSetDispatcher(ExternalTrigger* self, Status* status, ExternalContext* context, char* name, unsigned nameSize) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::getCharSet(status, context, name, nameSize);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopexecuteDispatcher(ExternalTrigger* self, Status* status, ExternalContext* context, unsigned action, void* oldMsg, void* newMsg) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::execute(status, context, action, oldMsg, newMsg);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopdisposeDispatcher(Disposable* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::dispose();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = DisposableImpl<Name, Inherit<VersionedImpl<Name, Inherit<ExternalTrigger> > > > >
	class ExternalTriggerImpl : public ExternalTriggerBaseImpl<Name, Base>
	{
	protected:
		ExternalTriggerImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ExternalTriggerImpl()
		{
		}

		virtual void getCharSet(Status* status, ExternalContext* context, char* name, unsigned nameSize) = 0;
		virtual void execute(Status* status, ExternalContext* context, unsigned action, void* oldMsg, void* newMsg) = 0;
	};

	template <typename Name, typename Base>
	class RoutineMetadataBaseImpl : public Base
	{
	public:
		typedef RoutineMetadata Declaration;

		RoutineMetadataBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getPackage = &Name::cloopgetPackageDispatcher;
					this->getName = &Name::cloopgetNameDispatcher;
					this->getEntryPoint = &Name::cloopgetEntryPointDispatcher;
					this->getBody = &Name::cloopgetBodyDispatcher;
					this->getInputMetadata = &Name::cloopgetInputMetadataDispatcher;
					this->getOutputMetadata = &Name::cloopgetOutputMetadataDispatcher;
					this->getTriggerMetadata = &Name::cloopgetTriggerMetadataDispatcher;
					this->getTriggerTable = &Name::cloopgetTriggerTableDispatcher;
					this->getTriggerType = &Name::cloopgetTriggerTypeDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetPackageDispatcher(const RoutineMetadata* self, Status* status) throw()
		{
			try
			{
				return static_cast<const Name*>(self)->Name::getPackage(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetNameDispatcher(const RoutineMetadata* self, Status* status) throw()
		{
			try
			{
				return static_cast<const Name*>(self)->Name::getName(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetEntryPointDispatcher(const RoutineMetadata* self, Status* status) throw()
		{
			try
			{
				return static_cast<const Name*>(self)->Name::getEntryPoint(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetBodyDispatcher(const RoutineMetadata* self, Status* status) throw()
		{
			try
			{
				return static_cast<const Name*>(self)->Name::getBody(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<const char*>(0);
			}
		}

		static MessageMetadata* CLOOP_CARG cloopgetInputMetadataDispatcher(const RoutineMetadata* self, Status* status) throw()
		{
			try
			{
				return static_cast<const Name*>(self)->Name::getInputMetadata(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<MessageMetadata*>(0);
			}
		}

		static MessageMetadata* CLOOP_CARG cloopgetOutputMetadataDispatcher(const RoutineMetadata* self, Status* status) throw()
		{
			try
			{
				return static_cast<const Name*>(self)->Name::getOutputMetadata(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<MessageMetadata*>(0);
			}
		}

		static MessageMetadata* CLOOP_CARG cloopgetTriggerMetadataDispatcher(const RoutineMetadata* self, Status* status) throw()
		{
			try
			{
				return static_cast<const Name*>(self)->Name::getTriggerMetadata(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<MessageMetadata*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetTriggerTableDispatcher(const RoutineMetadata* self, Status* status) throw()
		{
			try
			{
				return static_cast<const Name*>(self)->Name::getTriggerTable(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<const char*>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetTriggerTypeDispatcher(const RoutineMetadata* self, Status* status) throw()
		{
			try
			{
				return static_cast<const Name*>(self)->Name::getTriggerType(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<unsigned>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = VersionedImpl<Name, Inherit<RoutineMetadata> > >
	class RoutineMetadataImpl : public RoutineMetadataBaseImpl<Name, Base>
	{
	protected:
		RoutineMetadataImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~RoutineMetadataImpl()
		{
		}

		virtual const char* getPackage(Status* status) const = 0;
		virtual const char* getName(Status* status) const = 0;
		virtual const char* getEntryPoint(Status* status) const = 0;
		virtual const char* getBody(Status* status) const = 0;
		virtual MessageMetadata* getInputMetadata(Status* status) const = 0;
		virtual MessageMetadata* getOutputMetadata(Status* status) const = 0;
		virtual MessageMetadata* getTriggerMetadata(Status* status) const = 0;
		virtual const char* getTriggerTable(Status* status) const = 0;
		virtual unsigned getTriggerType(Status* status) const = 0;
	};

	template <typename Name, typename Base>
	class ExternalEngineBaseImpl : public Base
	{
	public:
		typedef ExternalEngine Declaration;

		ExternalEngineBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->setOwner = &Name::cloopsetOwnerDispatcher;
					this->getOwner = &Name::cloopgetOwnerDispatcher;
					this->open = &Name::cloopopenDispatcher;
					this->openAttachment = &Name::cloopopenAttachmentDispatcher;
					this->closeAttachment = &Name::cloopcloseAttachmentDispatcher;
					this->makeFunction = &Name::cloopmakeFunctionDispatcher;
					this->makeProcedure = &Name::cloopmakeProcedureDispatcher;
					this->makeTrigger = &Name::cloopmakeTriggerDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopopenDispatcher(ExternalEngine* self, Status* status, ExternalContext* context, char* charSet, unsigned charSetSize) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::open(status, context, charSet, charSetSize);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopopenAttachmentDispatcher(ExternalEngine* self, Status* status, ExternalContext* context) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::openAttachment(status, context);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopcloseAttachmentDispatcher(ExternalEngine* self, Status* status, ExternalContext* context) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::closeAttachment(status, context);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static ExternalFunction* CLOOP_CARG cloopmakeFunctionDispatcher(ExternalEngine* self, Status* status, ExternalContext* context, RoutineMetadata* metadata, MetadataBuilder* inBuilder, MetadataBuilder* outBuilder) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::makeFunction(status, context, metadata, inBuilder, outBuilder);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<ExternalFunction*>(0);
			}
		}

		static ExternalProcedure* CLOOP_CARG cloopmakeProcedureDispatcher(ExternalEngine* self, Status* status, ExternalContext* context, RoutineMetadata* metadata, MetadataBuilder* inBuilder, MetadataBuilder* outBuilder) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::makeProcedure(status, context, metadata, inBuilder, outBuilder);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<ExternalProcedure*>(0);
			}
		}

		static ExternalTrigger* CLOOP_CARG cloopmakeTriggerDispatcher(ExternalEngine* self, Status* status, ExternalContext* context, RoutineMetadata* metadata, MetadataBuilder* fieldsBuilder) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::makeTrigger(status, context, metadata, fieldsBuilder);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<ExternalTrigger*>(0);
			}
		}

		static void CLOOP_CARG cloopsetOwnerDispatcher(PluginBase* self, ReferenceCounted* r) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setOwner(r);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static ReferenceCounted* CLOOP_CARG cloopgetOwnerDispatcher(PluginBase* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOwner();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ReferenceCounted*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = PluginBaseImpl<Name, Inherit<ReferenceCountedImpl<Name, Inherit<VersionedImpl<Name, Inherit<ExternalEngine> > > > > > >
	class ExternalEngineImpl : public ExternalEngineBaseImpl<Name, Base>
	{
	protected:
		ExternalEngineImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ExternalEngineImpl()
		{
		}

		virtual void open(Status* status, ExternalContext* context, char* charSet, unsigned charSetSize) = 0;
		virtual void openAttachment(Status* status, ExternalContext* context) = 0;
		virtual void closeAttachment(Status* status, ExternalContext* context) = 0;
		virtual ExternalFunction* makeFunction(Status* status, ExternalContext* context, RoutineMetadata* metadata, MetadataBuilder* inBuilder, MetadataBuilder* outBuilder) = 0;
		virtual ExternalProcedure* makeProcedure(Status* status, ExternalContext* context, RoutineMetadata* metadata, MetadataBuilder* inBuilder, MetadataBuilder* outBuilder) = 0;
		virtual ExternalTrigger* makeTrigger(Status* status, ExternalContext* context, RoutineMetadata* metadata, MetadataBuilder* fieldsBuilder) = 0;
	};

	template <typename Name, typename Base>
	class TimerBaseImpl : public Base
	{
	public:
		typedef Timer Declaration;

		TimerBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->handler = &Name::cloophandlerDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloophandlerDispatcher(Timer* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::handler();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = ReferenceCountedImpl<Name, Inherit<VersionedImpl<Name, Inherit<Timer> > > > >
	class TimerImpl : public TimerBaseImpl<Name, Base>
	{
	protected:
		TimerImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~TimerImpl()
		{
		}

		virtual void handler() = 0;
	};

	template <typename Name, typename Base>
	class TimerControlBaseImpl : public Base
	{
	public:
		typedef TimerControl Declaration;

		TimerControlBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->start = &Name::cloopstartDispatcher;
					this->stop = &Name::cloopstopDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopstartDispatcher(TimerControl* self, Status* status, Timer* timer, ISC_UINT64 microSeconds) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::start(status, timer, microSeconds);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopstopDispatcher(TimerControl* self, Status* status, Timer* timer) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::stop(status, timer);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = VersionedImpl<Name, Inherit<TimerControl> > >
	class TimerControlImpl : public TimerControlBaseImpl<Name, Base>
	{
	protected:
		TimerControlImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~TimerControlImpl()
		{
		}

		virtual void start(Status* status, Timer* timer, ISC_UINT64 microSeconds) = 0;
		virtual void stop(Status* status, Timer* timer) = 0;
	};

	template <typename Name, typename Base>
	class VersionCallbackBaseImpl : public Base
	{
	public:
		typedef VersionCallback Declaration;

		VersionCallbackBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->callback = &Name::cloopcallbackDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopcallbackDispatcher(VersionCallback* self, Status* status, const char* text) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::callback(status, text);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = VersionedImpl<Name, Inherit<VersionCallback> > >
	class VersionCallbackImpl : public VersionCallbackBaseImpl<Name, Base>
	{
	protected:
		VersionCallbackImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~VersionCallbackImpl()
		{
		}

		virtual void callback(Status* status, const char* text) = 0;
	};

	template <typename Name, typename Base>
	class UtlBaseImpl : public Base
	{
	public:
		typedef Utl Declaration;

		UtlBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getFbVersion = &Name::cloopgetFbVersionDispatcher;
					this->loadBlob = &Name::clooploadBlobDispatcher;
					this->dumpBlob = &Name::cloopdumpBlobDispatcher;
					this->getPerfCounters = &Name::cloopgetPerfCountersDispatcher;
					this->executeCreateDatabase = &Name::cloopexecuteCreateDatabaseDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopgetFbVersionDispatcher(Utl* self, Status* status, Attachment* att, VersionCallback* callback) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::getFbVersion(status, att, callback);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG clooploadBlobDispatcher(Utl* self, Status* status, ISC_QUAD* blobId, Attachment* att, Transaction* tra, const char* file, FB_BOOLEAN txt) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::loadBlob(status, blobId, att, tra, file, txt);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopdumpBlobDispatcher(Utl* self, Status* status, ISC_QUAD* blobId, Attachment* att, Transaction* tra, const char* file, FB_BOOLEAN txt) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::dumpBlob(status, blobId, att, tra, file, txt);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopgetPerfCountersDispatcher(Utl* self, Status* status, Attachment* att, const char* countersSet, ISC_INT64* counters) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::getPerfCounters(status, att, countersSet, counters);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static Attachment* CLOOP_CARG cloopexecuteCreateDatabaseDispatcher(Utl* self, Status* status, unsigned stmtLength, const char* creatDBstatement, unsigned dialect, FB_BOOLEAN* stmtIsCreateDb) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::executeCreateDatabase(status, stmtLength, creatDBstatement, dialect, stmtIsCreateDb);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<Attachment*>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = VersionedImpl<Name, Inherit<Utl> > >
	class UtlImpl : public UtlBaseImpl<Name, Base>
	{
	protected:
		UtlImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~UtlImpl()
		{
		}

		virtual void getFbVersion(Status* status, Attachment* att, VersionCallback* callback) = 0;
		virtual void loadBlob(Status* status, ISC_QUAD* blobId, Attachment* att, Transaction* tra, const char* file, FB_BOOLEAN txt) = 0;
		virtual void dumpBlob(Status* status, ISC_QUAD* blobId, Attachment* att, Transaction* tra, const char* file, FB_BOOLEAN txt) = 0;
		virtual void getPerfCounters(Status* status, Attachment* att, const char* countersSet, ISC_INT64* counters) = 0;
		virtual Attachment* executeCreateDatabase(Status* status, unsigned stmtLength, const char* creatDBstatement, unsigned dialect, FB_BOOLEAN* stmtIsCreateDb) = 0;
	};

	template <typename Name, typename Base>
	class TraceConnectionBaseImpl : public Base
	{
	public:
		typedef TraceConnection Declaration;

		TraceConnectionBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getKind = &Name::cloopgetKindDispatcher;
					this->getProcessID = &Name::cloopgetProcessIDDispatcher;
					this->getUserName = &Name::cloopgetUserNameDispatcher;
					this->getRoleName = &Name::cloopgetRoleNameDispatcher;
					this->getCharSet = &Name::cloopgetCharSetDispatcher;
					this->getRemoteProtocol = &Name::cloopgetRemoteProtocolDispatcher;
					this->getRemoteAddress = &Name::cloopgetRemoteAddressDispatcher;
					this->getRemoteProcessID = &Name::cloopgetRemoteProcessIDDispatcher;
					this->getRemoteProcessName = &Name::cloopgetRemoteProcessNameDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static unsigned CLOOP_CARG cloopgetKindDispatcher(TraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getKind();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static int CLOOP_CARG cloopgetProcessIDDispatcher(TraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getProcessID();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetUserNameDispatcher(TraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getUserName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRoleNameDispatcher(TraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRoleName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetCharSetDispatcher(TraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getCharSet();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRemoteProtocolDispatcher(TraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRemoteProtocol();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRemoteAddressDispatcher(TraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRemoteAddress();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static int CLOOP_CARG cloopgetRemoteProcessIDDispatcher(TraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRemoteProcessID();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRemoteProcessNameDispatcher(TraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRemoteProcessName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = VersionedImpl<Name, Inherit<TraceConnection> > >
	class TraceConnectionImpl : public TraceConnectionBaseImpl<Name, Base>
	{
	protected:
		TraceConnectionImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~TraceConnectionImpl()
		{
		}

		virtual unsigned getKind() = 0;
		virtual int getProcessID() = 0;
		virtual const char* getUserName() = 0;
		virtual const char* getRoleName() = 0;
		virtual const char* getCharSet() = 0;
		virtual const char* getRemoteProtocol() = 0;
		virtual const char* getRemoteAddress() = 0;
		virtual int getRemoteProcessID() = 0;
		virtual const char* getRemoteProcessName() = 0;
	};

	template <typename Name, typename Base>
	class TraceDatabaseConnectionBaseImpl : public Base
	{
	public:
		typedef TraceDatabaseConnection Declaration;

		TraceDatabaseConnectionBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getKind = &Name::cloopgetKindDispatcher;
					this->getProcessID = &Name::cloopgetProcessIDDispatcher;
					this->getUserName = &Name::cloopgetUserNameDispatcher;
					this->getRoleName = &Name::cloopgetRoleNameDispatcher;
					this->getCharSet = &Name::cloopgetCharSetDispatcher;
					this->getRemoteProtocol = &Name::cloopgetRemoteProtocolDispatcher;
					this->getRemoteAddress = &Name::cloopgetRemoteAddressDispatcher;
					this->getRemoteProcessID = &Name::cloopgetRemoteProcessIDDispatcher;
					this->getRemoteProcessName = &Name::cloopgetRemoteProcessNameDispatcher;
					this->getConnectionID = &Name::cloopgetConnectionIDDispatcher;
					this->getDatabaseName = &Name::cloopgetDatabaseNameDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static int CLOOP_CARG cloopgetConnectionIDDispatcher(TraceDatabaseConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getConnectionID();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetDatabaseNameDispatcher(TraceDatabaseConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getDatabaseName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetKindDispatcher(TraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getKind();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static int CLOOP_CARG cloopgetProcessIDDispatcher(TraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getProcessID();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetUserNameDispatcher(TraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getUserName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRoleNameDispatcher(TraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRoleName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetCharSetDispatcher(TraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getCharSet();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRemoteProtocolDispatcher(TraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRemoteProtocol();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRemoteAddressDispatcher(TraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRemoteAddress();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static int CLOOP_CARG cloopgetRemoteProcessIDDispatcher(TraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRemoteProcessID();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRemoteProcessNameDispatcher(TraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRemoteProcessName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = TraceConnectionImpl<Name, Inherit<VersionedImpl<Name, Inherit<TraceDatabaseConnection> > > > >
	class TraceDatabaseConnectionImpl : public TraceDatabaseConnectionBaseImpl<Name, Base>
	{
	protected:
		TraceDatabaseConnectionImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~TraceDatabaseConnectionImpl()
		{
		}

		virtual int getConnectionID() = 0;
		virtual const char* getDatabaseName() = 0;
	};

	template <typename Name, typename Base>
	class TraceTransactionBaseImpl : public Base
	{
	public:
		typedef TraceTransaction Declaration;

		TraceTransactionBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getTransactionID = &Name::cloopgetTransactionIDDispatcher;
					this->getReadOnly = &Name::cloopgetReadOnlyDispatcher;
					this->getWait = &Name::cloopgetWaitDispatcher;
					this->getIsolation = &Name::cloopgetIsolationDispatcher;
					this->getPerf = &Name::cloopgetPerfDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static unsigned CLOOP_CARG cloopgetTransactionIDDispatcher(TraceTransaction* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getTransactionID();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG cloopgetReadOnlyDispatcher(TraceTransaction* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getReadOnly();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static int CLOOP_CARG cloopgetWaitDispatcher(TraceTransaction* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getWait();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetIsolationDispatcher(TraceTransaction* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getIsolation();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static PerformanceInfo* CLOOP_CARG cloopgetPerfDispatcher(TraceTransaction* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPerf();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PerformanceInfo*>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = VersionedImpl<Name, Inherit<TraceTransaction> > >
	class TraceTransactionImpl : public TraceTransactionBaseImpl<Name, Base>
	{
	protected:
		TraceTransactionImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~TraceTransactionImpl()
		{
		}

		virtual unsigned getTransactionID() = 0;
		virtual FB_BOOLEAN getReadOnly() = 0;
		virtual int getWait() = 0;
		virtual unsigned getIsolation() = 0;
		virtual PerformanceInfo* getPerf() = 0;
	};

	template <typename Name, typename Base>
	class TraceParamsBaseImpl : public Base
	{
	public:
		typedef TraceParams Declaration;

		TraceParamsBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getCount = &Name::cloopgetCountDispatcher;
					this->getParam = &Name::cloopgetParamDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static unsigned CLOOP_CARG cloopgetCountDispatcher(TraceParams* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getCount();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static const dsc* CLOOP_CARG cloopgetParamDispatcher(TraceParams* self, unsigned idx) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getParam(idx);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const dsc*>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = VersionedImpl<Name, Inherit<TraceParams> > >
	class TraceParamsImpl : public TraceParamsBaseImpl<Name, Base>
	{
	protected:
		TraceParamsImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~TraceParamsImpl()
		{
		}

		virtual unsigned getCount() = 0;
		virtual const dsc* getParam(unsigned idx) = 0;
	};

	template <typename Name, typename Base>
	class TraceStatementBaseImpl : public Base
	{
	public:
		typedef TraceStatement Declaration;

		TraceStatementBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getStmtID = &Name::cloopgetStmtIDDispatcher;
					this->getPerf = &Name::cloopgetPerfDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static int CLOOP_CARG cloopgetStmtIDDispatcher(TraceStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getStmtID();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PerformanceInfo* CLOOP_CARG cloopgetPerfDispatcher(TraceStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPerf();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PerformanceInfo*>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = VersionedImpl<Name, Inherit<TraceStatement> > >
	class TraceStatementImpl : public TraceStatementBaseImpl<Name, Base>
	{
	protected:
		TraceStatementImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~TraceStatementImpl()
		{
		}

		virtual int getStmtID() = 0;
		virtual PerformanceInfo* getPerf() = 0;
	};

	template <typename Name, typename Base>
	class TraceSQLStatementBaseImpl : public Base
	{
	public:
		typedef TraceSQLStatement Declaration;

		TraceSQLStatementBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getStmtID = &Name::cloopgetStmtIDDispatcher;
					this->getPerf = &Name::cloopgetPerfDispatcher;
					this->getText = &Name::cloopgetTextDispatcher;
					this->getPlan = &Name::cloopgetPlanDispatcher;
					this->getInputs = &Name::cloopgetInputsDispatcher;
					this->getTextUTF8 = &Name::cloopgetTextUTF8Dispatcher;
					this->getExplainedPlan = &Name::cloopgetExplainedPlanDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetTextDispatcher(TraceSQLStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getText();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetPlanDispatcher(TraceSQLStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPlan();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static TraceParams* CLOOP_CARG cloopgetInputsDispatcher(TraceSQLStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getInputs();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<TraceParams*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetTextUTF8Dispatcher(TraceSQLStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getTextUTF8();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetExplainedPlanDispatcher(TraceSQLStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getExplainedPlan();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static int CLOOP_CARG cloopgetStmtIDDispatcher(TraceStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getStmtID();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PerformanceInfo* CLOOP_CARG cloopgetPerfDispatcher(TraceStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPerf();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PerformanceInfo*>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = TraceStatementImpl<Name, Inherit<VersionedImpl<Name, Inherit<TraceSQLStatement> > > > >
	class TraceSQLStatementImpl : public TraceSQLStatementBaseImpl<Name, Base>
	{
	protected:
		TraceSQLStatementImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~TraceSQLStatementImpl()
		{
		}

		virtual const char* getText() = 0;
		virtual const char* getPlan() = 0;
		virtual TraceParams* getInputs() = 0;
		virtual const char* getTextUTF8() = 0;
		virtual const char* getExplainedPlan() = 0;
	};

	template <typename Name, typename Base>
	class TraceBLRStatementBaseImpl : public Base
	{
	public:
		typedef TraceBLRStatement Declaration;

		TraceBLRStatementBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getStmtID = &Name::cloopgetStmtIDDispatcher;
					this->getPerf = &Name::cloopgetPerfDispatcher;
					this->getData = &Name::cloopgetDataDispatcher;
					this->getDataLength = &Name::cloopgetDataLengthDispatcher;
					this->getText = &Name::cloopgetTextDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const unsigned char* CLOOP_CARG cloopgetDataDispatcher(TraceBLRStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getData();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const unsigned char*>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetDataLengthDispatcher(TraceBLRStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getDataLength();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetTextDispatcher(TraceBLRStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getText();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static int CLOOP_CARG cloopgetStmtIDDispatcher(TraceStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getStmtID();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PerformanceInfo* CLOOP_CARG cloopgetPerfDispatcher(TraceStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPerf();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PerformanceInfo*>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = TraceStatementImpl<Name, Inherit<VersionedImpl<Name, Inherit<TraceBLRStatement> > > > >
	class TraceBLRStatementImpl : public TraceBLRStatementBaseImpl<Name, Base>
	{
	protected:
		TraceBLRStatementImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~TraceBLRStatementImpl()
		{
		}

		virtual const unsigned char* getData() = 0;
		virtual unsigned getDataLength() = 0;
		virtual const char* getText() = 0;
	};

	template <typename Name, typename Base>
	class TraceDYNRequestBaseImpl : public Base
	{
	public:
		typedef TraceDYNRequest Declaration;

		TraceDYNRequestBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getData = &Name::cloopgetDataDispatcher;
					this->getDataLength = &Name::cloopgetDataLengthDispatcher;
					this->getText = &Name::cloopgetTextDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const unsigned char* CLOOP_CARG cloopgetDataDispatcher(TraceDYNRequest* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getData();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const unsigned char*>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetDataLengthDispatcher(TraceDYNRequest* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getDataLength();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetTextDispatcher(TraceDYNRequest* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getText();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = VersionedImpl<Name, Inherit<TraceDYNRequest> > >
	class TraceDYNRequestImpl : public TraceDYNRequestBaseImpl<Name, Base>
	{
	protected:
		TraceDYNRequestImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~TraceDYNRequestImpl()
		{
		}

		virtual const unsigned char* getData() = 0;
		virtual unsigned getDataLength() = 0;
		virtual const char* getText() = 0;
	};

	template <typename Name, typename Base>
	class TraceContextVariableBaseImpl : public Base
	{
	public:
		typedef TraceContextVariable Declaration;

		TraceContextVariableBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getNameSpace = &Name::cloopgetNameSpaceDispatcher;
					this->getVarName = &Name::cloopgetVarNameDispatcher;
					this->getVarValue = &Name::cloopgetVarValueDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetNameSpaceDispatcher(TraceContextVariable* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getNameSpace();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetVarNameDispatcher(TraceContextVariable* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getVarName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetVarValueDispatcher(TraceContextVariable* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getVarValue();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = VersionedImpl<Name, Inherit<TraceContextVariable> > >
	class TraceContextVariableImpl : public TraceContextVariableBaseImpl<Name, Base>
	{
	protected:
		TraceContextVariableImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~TraceContextVariableImpl()
		{
		}

		virtual const char* getNameSpace() = 0;
		virtual const char* getVarName() = 0;
		virtual const char* getVarValue() = 0;
	};

	template <typename Name, typename Base>
	class TraceProcedureBaseImpl : public Base
	{
	public:
		typedef TraceProcedure Declaration;

		TraceProcedureBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getProcName = &Name::cloopgetProcNameDispatcher;
					this->getInputs = &Name::cloopgetInputsDispatcher;
					this->getPerf = &Name::cloopgetPerfDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetProcNameDispatcher(TraceProcedure* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getProcName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static TraceParams* CLOOP_CARG cloopgetInputsDispatcher(TraceProcedure* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getInputs();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<TraceParams*>(0);
			}
		}

		static PerformanceInfo* CLOOP_CARG cloopgetPerfDispatcher(TraceProcedure* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPerf();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PerformanceInfo*>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = VersionedImpl<Name, Inherit<TraceProcedure> > >
	class TraceProcedureImpl : public TraceProcedureBaseImpl<Name, Base>
	{
	protected:
		TraceProcedureImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~TraceProcedureImpl()
		{
		}

		virtual const char* getProcName() = 0;
		virtual TraceParams* getInputs() = 0;
		virtual PerformanceInfo* getPerf() = 0;
	};

	template <typename Name, typename Base>
	class TraceFunctionBaseImpl : public Base
	{
	public:
		typedef TraceFunction Declaration;

		TraceFunctionBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getFuncName = &Name::cloopgetFuncNameDispatcher;
					this->getInputs = &Name::cloopgetInputsDispatcher;
					this->getResult = &Name::cloopgetResultDispatcher;
					this->getPerf = &Name::cloopgetPerfDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetFuncNameDispatcher(TraceFunction* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getFuncName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static TraceParams* CLOOP_CARG cloopgetInputsDispatcher(TraceFunction* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getInputs();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<TraceParams*>(0);
			}
		}

		static TraceParams* CLOOP_CARG cloopgetResultDispatcher(TraceFunction* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getResult();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<TraceParams*>(0);
			}
		}

		static PerformanceInfo* CLOOP_CARG cloopgetPerfDispatcher(TraceFunction* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPerf();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PerformanceInfo*>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = VersionedImpl<Name, Inherit<TraceFunction> > >
	class TraceFunctionImpl : public TraceFunctionBaseImpl<Name, Base>
	{
	protected:
		TraceFunctionImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~TraceFunctionImpl()
		{
		}

		virtual const char* getFuncName() = 0;
		virtual TraceParams* getInputs() = 0;
		virtual TraceParams* getResult() = 0;
		virtual PerformanceInfo* getPerf() = 0;
	};

	template <typename Name, typename Base>
	class TraceTriggerBaseImpl : public Base
	{
	public:
		typedef TraceTrigger Declaration;

		TraceTriggerBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getTriggerName = &Name::cloopgetTriggerNameDispatcher;
					this->getRelationName = &Name::cloopgetRelationNameDispatcher;
					this->getAction = &Name::cloopgetActionDispatcher;
					this->getWhich = &Name::cloopgetWhichDispatcher;
					this->getPerf = &Name::cloopgetPerfDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetTriggerNameDispatcher(TraceTrigger* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getTriggerName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRelationNameDispatcher(TraceTrigger* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRelationName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static int CLOOP_CARG cloopgetActionDispatcher(TraceTrigger* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getAction();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static int CLOOP_CARG cloopgetWhichDispatcher(TraceTrigger* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getWhich();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PerformanceInfo* CLOOP_CARG cloopgetPerfDispatcher(TraceTrigger* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPerf();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PerformanceInfo*>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = VersionedImpl<Name, Inherit<TraceTrigger> > >
	class TraceTriggerImpl : public TraceTriggerBaseImpl<Name, Base>
	{
	protected:
		TraceTriggerImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~TraceTriggerImpl()
		{
		}

		virtual const char* getTriggerName() = 0;
		virtual const char* getRelationName() = 0;
		virtual int getAction() = 0;
		virtual int getWhich() = 0;
		virtual PerformanceInfo* getPerf() = 0;
	};

	template <typename Name, typename Base>
	class TraceServiceConnectionBaseImpl : public Base
	{
	public:
		typedef TraceServiceConnection Declaration;

		TraceServiceConnectionBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getKind = &Name::cloopgetKindDispatcher;
					this->getProcessID = &Name::cloopgetProcessIDDispatcher;
					this->getUserName = &Name::cloopgetUserNameDispatcher;
					this->getRoleName = &Name::cloopgetRoleNameDispatcher;
					this->getCharSet = &Name::cloopgetCharSetDispatcher;
					this->getRemoteProtocol = &Name::cloopgetRemoteProtocolDispatcher;
					this->getRemoteAddress = &Name::cloopgetRemoteAddressDispatcher;
					this->getRemoteProcessID = &Name::cloopgetRemoteProcessIDDispatcher;
					this->getRemoteProcessName = &Name::cloopgetRemoteProcessNameDispatcher;
					this->getServiceID = &Name::cloopgetServiceIDDispatcher;
					this->getServiceMgr = &Name::cloopgetServiceMgrDispatcher;
					this->getServiceName = &Name::cloopgetServiceNameDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void* CLOOP_CARG cloopgetServiceIDDispatcher(TraceServiceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getServiceID();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<void*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetServiceMgrDispatcher(TraceServiceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getServiceMgr();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetServiceNameDispatcher(TraceServiceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getServiceName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetKindDispatcher(TraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getKind();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static int CLOOP_CARG cloopgetProcessIDDispatcher(TraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getProcessID();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetUserNameDispatcher(TraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getUserName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRoleNameDispatcher(TraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRoleName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetCharSetDispatcher(TraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getCharSet();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRemoteProtocolDispatcher(TraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRemoteProtocol();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRemoteAddressDispatcher(TraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRemoteAddress();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static int CLOOP_CARG cloopgetRemoteProcessIDDispatcher(TraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRemoteProcessID();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRemoteProcessNameDispatcher(TraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRemoteProcessName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = TraceConnectionImpl<Name, Inherit<VersionedImpl<Name, Inherit<TraceServiceConnection> > > > >
	class TraceServiceConnectionImpl : public TraceServiceConnectionBaseImpl<Name, Base>
	{
	protected:
		TraceServiceConnectionImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~TraceServiceConnectionImpl()
		{
		}

		virtual void* getServiceID() = 0;
		virtual const char* getServiceMgr() = 0;
		virtual const char* getServiceName() = 0;
	};

	template <typename Name, typename Base>
	class TraceStatusVectorBaseImpl : public Base
	{
	public:
		typedef TraceStatusVector Declaration;

		TraceStatusVectorBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->hasError = &Name::cloophasErrorDispatcher;
					this->hasWarning = &Name::cloophasWarningDispatcher;
					this->getStatus = &Name::cloopgetStatusDispatcher;
					this->getText = &Name::cloopgetTextDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static FB_BOOLEAN CLOOP_CARG cloophasErrorDispatcher(TraceStatusVector* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::hasError();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG cloophasWarningDispatcher(TraceStatusVector* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::hasWarning();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static const intptr_t* CLOOP_CARG cloopgetStatusDispatcher(TraceStatusVector* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getStatus();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const intptr_t*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetTextDispatcher(TraceStatusVector* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getText();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = VersionedImpl<Name, Inherit<TraceStatusVector> > >
	class TraceStatusVectorImpl : public TraceStatusVectorBaseImpl<Name, Base>
	{
	protected:
		TraceStatusVectorImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~TraceStatusVectorImpl()
		{
		}

		virtual FB_BOOLEAN hasError() = 0;
		virtual FB_BOOLEAN hasWarning() = 0;
		virtual const intptr_t* getStatus() = 0;
		virtual const char* getText() = 0;
	};

	template <typename Name, typename Base>
	class TraceSweepInfoBaseImpl : public Base
	{
	public:
		typedef TraceSweepInfo Declaration;

		TraceSweepInfoBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getOIT = &Name::cloopgetOITDispatcher;
					this->getOST = &Name::cloopgetOSTDispatcher;
					this->getOAT = &Name::cloopgetOATDispatcher;
					this->getNext = &Name::cloopgetNextDispatcher;
					this->getPerf = &Name::cloopgetPerfDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static ISC_UINT64 CLOOP_CARG cloopgetOITDispatcher(TraceSweepInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOIT();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ISC_UINT64>(0);
			}
		}

		static ISC_UINT64 CLOOP_CARG cloopgetOSTDispatcher(TraceSweepInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOST();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ISC_UINT64>(0);
			}
		}

		static ISC_UINT64 CLOOP_CARG cloopgetOATDispatcher(TraceSweepInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOAT();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ISC_UINT64>(0);
			}
		}

		static ISC_UINT64 CLOOP_CARG cloopgetNextDispatcher(TraceSweepInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getNext();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ISC_UINT64>(0);
			}
		}

		static PerformanceInfo* CLOOP_CARG cloopgetPerfDispatcher(TraceSweepInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPerf();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PerformanceInfo*>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = VersionedImpl<Name, Inherit<TraceSweepInfo> > >
	class TraceSweepInfoImpl : public TraceSweepInfoBaseImpl<Name, Base>
	{
	protected:
		TraceSweepInfoImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~TraceSweepInfoImpl()
		{
		}

		virtual ISC_UINT64 getOIT() = 0;
		virtual ISC_UINT64 getOST() = 0;
		virtual ISC_UINT64 getOAT() = 0;
		virtual ISC_UINT64 getNext() = 0;
		virtual PerformanceInfo* getPerf() = 0;
	};

	template <typename Name, typename Base>
	class TraceLogWriterBaseImpl : public Base
	{
	public:
		typedef TraceLogWriter Declaration;

		TraceLogWriterBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->write = &Name::cloopwriteDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static unsigned CLOOP_CARG cloopwriteDispatcher(TraceLogWriter* self, const void* buf, unsigned size) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::write(buf, size);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = ReferenceCountedImpl<Name, Inherit<VersionedImpl<Name, Inherit<TraceLogWriter> > > > >
	class TraceLogWriterImpl : public TraceLogWriterBaseImpl<Name, Base>
	{
	protected:
		TraceLogWriterImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~TraceLogWriterImpl()
		{
		}

		virtual unsigned write(const void* buf, unsigned size) = 0;
	};

	template <typename Name, typename Base>
	class TraceInitInfoBaseImpl : public Base
	{
	public:
		typedef TraceInitInfo Declaration;

		TraceInitInfoBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getConfigText = &Name::cloopgetConfigTextDispatcher;
					this->getTraceSessionID = &Name::cloopgetTraceSessionIDDispatcher;
					this->getTraceSessionName = &Name::cloopgetTraceSessionNameDispatcher;
					this->getFirebirdRootDirectory = &Name::cloopgetFirebirdRootDirectoryDispatcher;
					this->getDatabaseName = &Name::cloopgetDatabaseNameDispatcher;
					this->getConnection = &Name::cloopgetConnectionDispatcher;
					this->getLogWriter = &Name::cloopgetLogWriterDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetConfigTextDispatcher(TraceInitInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getConfigText();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static int CLOOP_CARG cloopgetTraceSessionIDDispatcher(TraceInitInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getTraceSessionID();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetTraceSessionNameDispatcher(TraceInitInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getTraceSessionName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetFirebirdRootDirectoryDispatcher(TraceInitInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getFirebirdRootDirectory();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetDatabaseNameDispatcher(TraceInitInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getDatabaseName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static TraceDatabaseConnection* CLOOP_CARG cloopgetConnectionDispatcher(TraceInitInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getConnection();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<TraceDatabaseConnection*>(0);
			}
		}

		static TraceLogWriter* CLOOP_CARG cloopgetLogWriterDispatcher(TraceInitInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getLogWriter();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<TraceLogWriter*>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = VersionedImpl<Name, Inherit<TraceInitInfo> > >
	class TraceInitInfoImpl : public TraceInitInfoBaseImpl<Name, Base>
	{
	protected:
		TraceInitInfoImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~TraceInitInfoImpl()
		{
		}

		virtual const char* getConfigText() = 0;
		virtual int getTraceSessionID() = 0;
		virtual const char* getTraceSessionName() = 0;
		virtual const char* getFirebirdRootDirectory() = 0;
		virtual const char* getDatabaseName() = 0;
		virtual TraceDatabaseConnection* getConnection() = 0;
		virtual TraceLogWriter* getLogWriter() = 0;
	};

	template <typename Name, typename Base>
	class TracePluginBaseImpl : public Base
	{
	public:
		typedef TracePlugin Declaration;

		TracePluginBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->trace_get_error = &Name::clooptrace_get_errorDispatcher;
					this->trace_attach = &Name::clooptrace_attachDispatcher;
					this->trace_detach = &Name::clooptrace_detachDispatcher;
					this->trace_transaction_start = &Name::clooptrace_transaction_startDispatcher;
					this->trace_transaction_end = &Name::clooptrace_transaction_endDispatcher;
					this->trace_proc_execute = &Name::clooptrace_proc_executeDispatcher;
					this->trace_trigger_execute = &Name::clooptrace_trigger_executeDispatcher;
					this->trace_set_context = &Name::clooptrace_set_contextDispatcher;
					this->trace_dsql_prepare = &Name::clooptrace_dsql_prepareDispatcher;
					this->trace_dsql_free = &Name::clooptrace_dsql_freeDispatcher;
					this->trace_dsql_execute = &Name::clooptrace_dsql_executeDispatcher;
					this->trace_blr_compile = &Name::clooptrace_blr_compileDispatcher;
					this->trace_blr_execute = &Name::clooptrace_blr_executeDispatcher;
					this->trace_dyn_execute = &Name::clooptrace_dyn_executeDispatcher;
					this->trace_service_attach = &Name::clooptrace_service_attachDispatcher;
					this->trace_service_start = &Name::clooptrace_service_startDispatcher;
					this->trace_service_query = &Name::clooptrace_service_queryDispatcher;
					this->trace_service_detach = &Name::clooptrace_service_detachDispatcher;
					this->trace_event_error = &Name::clooptrace_event_errorDispatcher;
					this->trace_event_sweep = &Name::clooptrace_event_sweepDispatcher;
					this->trace_func_execute = &Name::clooptrace_func_executeDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG clooptrace_get_errorDispatcher(TracePlugin* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_get_error();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_attachDispatcher(TracePlugin* self, TraceDatabaseConnection* connection, FB_BOOLEAN create_db, unsigned att_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_attach(connection, create_db, att_result);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_detachDispatcher(TracePlugin* self, TraceDatabaseConnection* connection, FB_BOOLEAN drop_db) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_detach(connection, drop_db);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_transaction_startDispatcher(TracePlugin* self, TraceDatabaseConnection* connection, TraceTransaction* transaction, unsigned tpb_length, const unsigned char* tpb, unsigned tra_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_transaction_start(connection, transaction, tpb_length, tpb, tra_result);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_transaction_endDispatcher(TracePlugin* self, TraceDatabaseConnection* connection, TraceTransaction* transaction, FB_BOOLEAN commit, FB_BOOLEAN retain_context, unsigned tra_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_transaction_end(connection, transaction, commit, retain_context, tra_result);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_proc_executeDispatcher(TracePlugin* self, TraceDatabaseConnection* connection, TraceTransaction* transaction, TraceProcedure* procedure, FB_BOOLEAN started, unsigned proc_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_proc_execute(connection, transaction, procedure, started, proc_result);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_trigger_executeDispatcher(TracePlugin* self, TraceDatabaseConnection* connection, TraceTransaction* transaction, TraceTrigger* trigger, FB_BOOLEAN started, unsigned trig_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_trigger_execute(connection, transaction, trigger, started, trig_result);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_set_contextDispatcher(TracePlugin* self, TraceDatabaseConnection* connection, TraceTransaction* transaction, TraceContextVariable* variable) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_set_context(connection, transaction, variable);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_dsql_prepareDispatcher(TracePlugin* self, TraceDatabaseConnection* connection, TraceTransaction* transaction, TraceSQLStatement* statement, ISC_INT64 time_millis, unsigned req_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_dsql_prepare(connection, transaction, statement, time_millis, req_result);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_dsql_freeDispatcher(TracePlugin* self, TraceDatabaseConnection* connection, TraceSQLStatement* statement, unsigned option) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_dsql_free(connection, statement, option);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_dsql_executeDispatcher(TracePlugin* self, TraceDatabaseConnection* connection, TraceTransaction* transaction, TraceSQLStatement* statement, FB_BOOLEAN started, unsigned req_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_dsql_execute(connection, transaction, statement, started, req_result);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_blr_compileDispatcher(TracePlugin* self, TraceDatabaseConnection* connection, TraceTransaction* transaction, TraceBLRStatement* statement, ISC_INT64 time_millis, unsigned req_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_blr_compile(connection, transaction, statement, time_millis, req_result);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_blr_executeDispatcher(TracePlugin* self, TraceDatabaseConnection* connection, TraceTransaction* transaction, TraceBLRStatement* statement, unsigned req_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_blr_execute(connection, transaction, statement, req_result);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_dyn_executeDispatcher(TracePlugin* self, TraceDatabaseConnection* connection, TraceTransaction* transaction, TraceDYNRequest* request, ISC_INT64 time_millis, unsigned req_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_dyn_execute(connection, transaction, request, time_millis, req_result);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_service_attachDispatcher(TracePlugin* self, TraceServiceConnection* service, unsigned att_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_service_attach(service, att_result);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_service_startDispatcher(TracePlugin* self, TraceServiceConnection* service, unsigned switches_length, const char* switches, unsigned start_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_service_start(service, switches_length, switches, start_result);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_service_queryDispatcher(TracePlugin* self, TraceServiceConnection* service, unsigned send_item_length, const unsigned char* send_items, unsigned recv_item_length, const unsigned char* recv_items, unsigned query_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_service_query(service, send_item_length, send_items, recv_item_length, recv_items, query_result);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_service_detachDispatcher(TracePlugin* self, TraceServiceConnection* service, unsigned detach_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_service_detach(service, detach_result);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_event_errorDispatcher(TracePlugin* self, TraceConnection* connection, TraceStatusVector* status, const char* function) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_event_error(connection, status, function);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_event_sweepDispatcher(TracePlugin* self, TraceDatabaseConnection* connection, TraceSweepInfo* sweep, unsigned sweep_state) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_event_sweep(connection, sweep, sweep_state);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_func_executeDispatcher(TracePlugin* self, TraceDatabaseConnection* connection, TraceTransaction* transaction, TraceFunction* function, FB_BOOLEAN started, unsigned func_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_func_execute(connection, transaction, function, started, func_result);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = ReferenceCountedImpl<Name, Inherit<VersionedImpl<Name, Inherit<TracePlugin> > > > >
	class TracePluginImpl : public TracePluginBaseImpl<Name, Base>
	{
	protected:
		TracePluginImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~TracePluginImpl()
		{
		}

		virtual const char* trace_get_error() = 0;
		virtual FB_BOOLEAN trace_attach(TraceDatabaseConnection* connection, FB_BOOLEAN create_db, unsigned att_result) = 0;
		virtual FB_BOOLEAN trace_detach(TraceDatabaseConnection* connection, FB_BOOLEAN drop_db) = 0;
		virtual FB_BOOLEAN trace_transaction_start(TraceDatabaseConnection* connection, TraceTransaction* transaction, unsigned tpb_length, const unsigned char* tpb, unsigned tra_result) = 0;
		virtual FB_BOOLEAN trace_transaction_end(TraceDatabaseConnection* connection, TraceTransaction* transaction, FB_BOOLEAN commit, FB_BOOLEAN retain_context, unsigned tra_result) = 0;
		virtual FB_BOOLEAN trace_proc_execute(TraceDatabaseConnection* connection, TraceTransaction* transaction, TraceProcedure* procedure, FB_BOOLEAN started, unsigned proc_result) = 0;
		virtual FB_BOOLEAN trace_trigger_execute(TraceDatabaseConnection* connection, TraceTransaction* transaction, TraceTrigger* trigger, FB_BOOLEAN started, unsigned trig_result) = 0;
		virtual FB_BOOLEAN trace_set_context(TraceDatabaseConnection* connection, TraceTransaction* transaction, TraceContextVariable* variable) = 0;
		virtual FB_BOOLEAN trace_dsql_prepare(TraceDatabaseConnection* connection, TraceTransaction* transaction, TraceSQLStatement* statement, ISC_INT64 time_millis, unsigned req_result) = 0;
		virtual FB_BOOLEAN trace_dsql_free(TraceDatabaseConnection* connection, TraceSQLStatement* statement, unsigned option) = 0;
		virtual FB_BOOLEAN trace_dsql_execute(TraceDatabaseConnection* connection, TraceTransaction* transaction, TraceSQLStatement* statement, FB_BOOLEAN started, unsigned req_result) = 0;
		virtual FB_BOOLEAN trace_blr_compile(TraceDatabaseConnection* connection, TraceTransaction* transaction, TraceBLRStatement* statement, ISC_INT64 time_millis, unsigned req_result) = 0;
		virtual FB_BOOLEAN trace_blr_execute(TraceDatabaseConnection* connection, TraceTransaction* transaction, TraceBLRStatement* statement, unsigned req_result) = 0;
		virtual FB_BOOLEAN trace_dyn_execute(TraceDatabaseConnection* connection, TraceTransaction* transaction, TraceDYNRequest* request, ISC_INT64 time_millis, unsigned req_result) = 0;
		virtual FB_BOOLEAN trace_service_attach(TraceServiceConnection* service, unsigned att_result) = 0;
		virtual FB_BOOLEAN trace_service_start(TraceServiceConnection* service, unsigned switches_length, const char* switches, unsigned start_result) = 0;
		virtual FB_BOOLEAN trace_service_query(TraceServiceConnection* service, unsigned send_item_length, const unsigned char* send_items, unsigned recv_item_length, const unsigned char* recv_items, unsigned query_result) = 0;
		virtual FB_BOOLEAN trace_service_detach(TraceServiceConnection* service, unsigned detach_result) = 0;
		virtual FB_BOOLEAN trace_event_error(TraceConnection* connection, TraceStatusVector* status, const char* function) = 0;
		virtual FB_BOOLEAN trace_event_sweep(TraceDatabaseConnection* connection, TraceSweepInfo* sweep, unsigned sweep_state) = 0;
		virtual FB_BOOLEAN trace_func_execute(TraceDatabaseConnection* connection, TraceTransaction* transaction, TraceFunction* function, FB_BOOLEAN started, unsigned func_result) = 0;
	};

	template <typename Name, typename Base>
	class TraceFactoryBaseImpl : public Base
	{
	public:
		typedef TraceFactory Declaration;

		TraceFactoryBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->setOwner = &Name::cloopsetOwnerDispatcher;
					this->getOwner = &Name::cloopgetOwnerDispatcher;
					this->trace_needs = &Name::clooptrace_needsDispatcher;
					this->trace_create = &Name::clooptrace_createDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static ISC_UINT64 CLOOP_CARG clooptrace_needsDispatcher(TraceFactory* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_needs();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ISC_UINT64>(0);
			}
		}

		static TracePlugin* CLOOP_CARG clooptrace_createDispatcher(TraceFactory* self, Status* status, TraceInitInfo* init_info) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_create(status, init_info);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<TracePlugin*>(0);
			}
		}

		static void CLOOP_CARG cloopsetOwnerDispatcher(PluginBase* self, ReferenceCounted* r) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setOwner(r);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static ReferenceCounted* CLOOP_CARG cloopgetOwnerDispatcher(PluginBase* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOwner();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ReferenceCounted*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(ReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PluginModule* CLOOP_CARG cloopgetModuleDispatcher(Versioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = PluginBaseImpl<Name, Inherit<ReferenceCountedImpl<Name, Inherit<VersionedImpl<Name, Inherit<TraceFactory> > > > > > >
	class TraceFactoryImpl : public TraceFactoryBaseImpl<Name, Base>
	{
	protected:
		TraceFactoryImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~TraceFactoryImpl()
		{
		}

		virtual ISC_UINT64 trace_needs() = 0;
		virtual TracePlugin* trace_create(Status* status, TraceInitInfo* init_info) = 0;
	};
};

template <typename Policy> const unsigned FirebirdApi<Policy>::Status::FB_HAS_WARNINGS;
template <typename Policy> const unsigned FirebirdApi<Policy>::Status::FB_HAS_ERRORS;
template <typename Policy> const int FirebirdApi<Policy>::Status::FB_ERROR;
template <typename Policy> const int FirebirdApi<Policy>::Status::FB_OK;
template <typename Policy> const int FirebirdApi<Policy>::Status::FB_EOF;
template <typename Policy> const int FirebirdApi<Policy>::Status::FB_SEGMENT;

template <typename Policy> const unsigned FirebirdApi<Policy>::PluginManager::Provider;
template <typename Policy> const unsigned FirebirdApi<Policy>::PluginManager::FirstNonLibPlugin;
template <typename Policy> const unsigned FirebirdApi<Policy>::PluginManager::AuthServer;
template <typename Policy> const unsigned FirebirdApi<Policy>::PluginManager::AuthClient;
template <typename Policy> const unsigned FirebirdApi<Policy>::PluginManager::AuthUserManagement;
template <typename Policy> const unsigned FirebirdApi<Policy>::PluginManager::ExternalEngine;
template <typename Policy> const unsigned FirebirdApi<Policy>::PluginManager::Trace;
template <typename Policy> const unsigned FirebirdApi<Policy>::PluginManager::WireCrypt;
template <typename Policy> const unsigned FirebirdApi<Policy>::PluginManager::DbCrypt;
template <typename Policy> const unsigned FirebirdApi<Policy>::PluginManager::KeyHolder;
template <typename Policy> const unsigned FirebirdApi<Policy>::PluginManager::MaxType;

template <typename Policy> const unsigned FirebirdApi<Policy>::ConfigManager::FB_DIR_BIN;
template <typename Policy> const unsigned FirebirdApi<Policy>::ConfigManager::FB_DIR_SBIN;
template <typename Policy> const unsigned FirebirdApi<Policy>::ConfigManager::FB_DIR_CONF;
template <typename Policy> const unsigned FirebirdApi<Policy>::ConfigManager::FB_DIR_LIB;
template <typename Policy> const unsigned FirebirdApi<Policy>::ConfigManager::FB_DIR_INC;
template <typename Policy> const unsigned FirebirdApi<Policy>::ConfigManager::FB_DIR_DOC;
template <typename Policy> const unsigned FirebirdApi<Policy>::ConfigManager::FB_DIR_UDF;
template <typename Policy> const unsigned FirebirdApi<Policy>::ConfigManager::FB_DIR_SAMPLE;
template <typename Policy> const unsigned FirebirdApi<Policy>::ConfigManager::FB_DIR_SAMPLEDB;
template <typename Policy> const unsigned FirebirdApi<Policy>::ConfigManager::FB_DIR_HELP;
template <typename Policy> const unsigned FirebirdApi<Policy>::ConfigManager::FB_DIR_INTL;
template <typename Policy> const unsigned FirebirdApi<Policy>::ConfigManager::FB_DIR_MISC;
template <typename Policy> const unsigned FirebirdApi<Policy>::ConfigManager::FB_DIR_SECDB;
template <typename Policy> const unsigned FirebirdApi<Policy>::ConfigManager::FB_DIR_MSG;
template <typename Policy> const unsigned FirebirdApi<Policy>::ConfigManager::FB_DIR_LOG;
template <typename Policy> const unsigned FirebirdApi<Policy>::ConfigManager::FB_DIR_GUARD;
template <typename Policy> const unsigned FirebirdApi<Policy>::ConfigManager::FB_DIR_PLUGINS;
template <typename Policy> const unsigned FirebirdApi<Policy>::ConfigManager::FB_DIRCOUNT;

template <typename Policy> const unsigned FirebirdApi<Policy>::Statement::PREPARE_PREFETCH_NONE;
template <typename Policy> const unsigned FirebirdApi<Policy>::Statement::PREPARE_PREFETCH_TYPE;
template <typename Policy> const unsigned FirebirdApi<Policy>::Statement::PREPARE_PREFETCH_INPUT_PARAMETERS;
template <typename Policy> const unsigned FirebirdApi<Policy>::Statement::PREPARE_PREFETCH_OUTPUT_PARAMETERS;
template <typename Policy> const unsigned FirebirdApi<Policy>::Statement::PREPARE_PREFETCH_LEGACY_PLAN;
template <typename Policy> const unsigned FirebirdApi<Policy>::Statement::PREPARE_PREFETCH_DETAILED_PLAN;
template <typename Policy> const unsigned FirebirdApi<Policy>::Statement::PREPARE_PREFETCH_AFFECTED_RECORDS;
template <typename Policy> const unsigned FirebirdApi<Policy>::Statement::PREPARE_PREFETCH_FLAGS;
template <typename Policy> const unsigned FirebirdApi<Policy>::Statement::PREPARE_PREFETCH_METADATA;
template <typename Policy> const unsigned FirebirdApi<Policy>::Statement::PREPARE_PREFETCH_ALL;
template <typename Policy> const unsigned FirebirdApi<Policy>::Statement::FLAG_HAS_CURSOR;
template <typename Policy> const unsigned FirebirdApi<Policy>::Statement::FLAG_REPEAT_EXECUTE;

template <typename Policy> const int FirebirdApi<Policy>::Auth::AUTH_FAILED;
template <typename Policy> const int FirebirdApi<Policy>::Auth::AUTH_SUCCESS;
template <typename Policy> const int FirebirdApi<Policy>::Auth::AUTH_MORE_DATA;
template <typename Policy> const int FirebirdApi<Policy>::Auth::AUTH_CONTINUE;

template <typename Policy> const unsigned FirebirdApi<Policy>::ExternalTrigger::TYPE_BEFORE;
template <typename Policy> const unsigned FirebirdApi<Policy>::ExternalTrigger::TYPE_AFTER;
template <typename Policy> const unsigned FirebirdApi<Policy>::ExternalTrigger::TYPE_DATABASE;
template <typename Policy> const unsigned FirebirdApi<Policy>::ExternalTrigger::ACTION_INSERT;
template <typename Policy> const unsigned FirebirdApi<Policy>::ExternalTrigger::ACTION_UPDATE;
template <typename Policy> const unsigned FirebirdApi<Policy>::ExternalTrigger::ACTION_DELETE;
template <typename Policy> const unsigned FirebirdApi<Policy>::ExternalTrigger::ACTION_CONNECT;
template <typename Policy> const unsigned FirebirdApi<Policy>::ExternalTrigger::ACTION_DISCONNECT;
template <typename Policy> const unsigned FirebirdApi<Policy>::ExternalTrigger::ACTION_TRANS_START;
template <typename Policy> const unsigned FirebirdApi<Policy>::ExternalTrigger::ACTION_TRANS_COMMIT;
template <typename Policy> const unsigned FirebirdApi<Policy>::ExternalTrigger::ACTION_TRANS_ROLLBACK;
template <typename Policy> const unsigned FirebirdApi<Policy>::ExternalTrigger::ACTION_DDL;

template <typename Policy> const unsigned FirebirdApi<Policy>::TraceConnection::TRACE_CONNECTION_DATABASE;
template <typename Policy> const unsigned FirebirdApi<Policy>::TraceConnection::TRACE_CONNECTION_SERVICE;

template <typename Policy> const unsigned FirebirdApi<Policy>::TraceTransaction::TRA_ISO_CONSISTENCY;
template <typename Policy> const unsigned FirebirdApi<Policy>::TraceTransaction::TRA_ISO_CONCURRENCY;
template <typename Policy> const unsigned FirebirdApi<Policy>::TraceTransaction::TRA_ISO_READ_COMMITTED_RECVER;
template <typename Policy> const unsigned FirebirdApi<Policy>::TraceTransaction::TRA_ISO_READ_COMMITTED_NORECVER;

template <typename Policy> const unsigned FirebirdApi<Policy>::TraceTrigger::TRACE_ALL;
template <typename Policy> const unsigned FirebirdApi<Policy>::TraceTrigger::TRACE_BEFORE;
template <typename Policy> const unsigned FirebirdApi<Policy>::TraceTrigger::TRACE_AFTER;

template <typename Policy> const unsigned FirebirdApi<Policy>::TracePlugin::TRACE_RESULT_SUCCESS;
template <typename Policy> const unsigned FirebirdApi<Policy>::TracePlugin::TRACE_RESULT_FAILED;
template <typename Policy> const unsigned FirebirdApi<Policy>::TracePlugin::TRACE_RESULT_UNAUTHORIZED;
template <typename Policy> const unsigned FirebirdApi<Policy>::TracePlugin::SWEEP_STATE_STARTED;
template <typename Policy> const unsigned FirebirdApi<Policy>::TracePlugin::SWEEP_STATE_FINISHED;
template <typename Policy> const unsigned FirebirdApi<Policy>::TracePlugin::SWEEP_STATE_FAILED;
template <typename Policy> const unsigned FirebirdApi<Policy>::TracePlugin::SWEEP_STATE_PROGRESS;

template <typename Policy> const unsigned FirebirdApi<Policy>::TraceFactory::TRACE_EVENT_ATTACH;
template <typename Policy> const unsigned FirebirdApi<Policy>::TraceFactory::TRACE_EVENT_DETACH;
template <typename Policy> const unsigned FirebirdApi<Policy>::TraceFactory::TRACE_EVENT_TRANSACTION_START;
template <typename Policy> const unsigned FirebirdApi<Policy>::TraceFactory::TRACE_EVENT_TRANSACTION_END;
template <typename Policy> const unsigned FirebirdApi<Policy>::TraceFactory::TRACE_EVENT_SET_CONTEXT;
template <typename Policy> const unsigned FirebirdApi<Policy>::TraceFactory::TRACE_EVENT_PROC_EXECUTE;
template <typename Policy> const unsigned FirebirdApi<Policy>::TraceFactory::TRACE_EVENT_TRIGGER_EXECUTE;
template <typename Policy> const unsigned FirebirdApi<Policy>::TraceFactory::TRACE_EVENT_DSQL_PREPARE;
template <typename Policy> const unsigned FirebirdApi<Policy>::TraceFactory::TRACE_EVENT_DSQL_FREE;
template <typename Policy> const unsigned FirebirdApi<Policy>::TraceFactory::TRACE_EVENT_DSQL_EXECUTE;
template <typename Policy> const unsigned FirebirdApi<Policy>::TraceFactory::TRACE_EVENT_BLR_COMPILE;
template <typename Policy> const unsigned FirebirdApi<Policy>::TraceFactory::TRACE_EVENT_BLR_EXECUTE;
template <typename Policy> const unsigned FirebirdApi<Policy>::TraceFactory::TRACE_EVENT_DYN_EXECUTE;
template <typename Policy> const unsigned FirebirdApi<Policy>::TraceFactory::TRACE_EVENT_SERVICE_ATTACH;
template <typename Policy> const unsigned FirebirdApi<Policy>::TraceFactory::TRACE_EVENT_SERVICE_START;
template <typename Policy> const unsigned FirebirdApi<Policy>::TraceFactory::TRACE_EVENT_SERVICE_QUERY;
template <typename Policy> const unsigned FirebirdApi<Policy>::TraceFactory::TRACE_EVENT_SERVICE_DETACH;
template <typename Policy> const unsigned FirebirdApi<Policy>::TraceFactory::TRACE_EVENT_ERROR;
template <typename Policy> const unsigned FirebirdApi<Policy>::TraceFactory::TRACE_EVENT_SWEEP;
template <typename Policy> const unsigned FirebirdApi<Policy>::TraceFactory::TRACE_EVENT_FUNC_EXECUTE;
template <typename Policy> const unsigned FirebirdApi<Policy>::TraceFactory::TRACE_EVENT_MAX;


#endif	// IDL_FB_INTERFACES_H
