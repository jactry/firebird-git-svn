// This file was autogenerated by cloop - Cross Language Object Oriented Programming

#ifndef IDL_FB_INTERFACES_H
#define IDL_FB_INTERFACES_H

#ifndef CLOOP_CARG
#define CLOOP_CARG
#endif


template <typename Policy>
class FirebirdApi
{
private:
	class DoNotInherit
	{
	};

	template <typename T>
	class Inherit : public T
	{
	public:
		Inherit(DoNotInherit = DoNotInherit())
			: T(DoNotInherit())
		{
		}
	};

public:
	// Forward interfaces declarations

	class IVersioned;
	class IReferenceCounted;
	class IDisposable;
	class IStatus;
	class IMaster;
	class IPluginBase;
	class IPluginSet;
	class IConfigEntry;
	class IConfig;
	class IFirebirdConf;
	class IPluginConfig;
	class IPluginFactory;
	class IPluginModule;
	class IPluginManager;
	class IConfigManager;
	class IEventCallback;
	class IBlob;
	class ITransaction;
	class IMessageMetadata;
	class IMetadataBuilder;
	class IResultSet;
	class IStatement;
	class IRequest;
	class IEvents;
	class IAttachment;
	class IService;
	class IProvider;
	class IDtcStart;
	class IDtc;
	class IAuth;
	class IWriter;
	class IServerBlock;
	class IClientBlock;
	class IServer;
	class IClient;
	class IUserField;
	class ICharUserField;
	class IIntUserField;
	class IUser;
	class IListUsers;
	class ILogonInfo;
	class IManagement;
	class IWireCryptPlugin;
	class ICryptKeyCallback;
	class IKeyHolderPlugin;
	class IDbCryptPlugin;
	class IExternalContext;
	class IExternalResultSet;
	class IExternalFunction;
	class IExternalProcedure;
	class IExternalTrigger;
	class IRoutineMetadata;
	class IExternalEngine;
	class ITimer;
	class ITimerControl;
	class IVersionCallback;
	class IUtl;
	class ITraceConnection;
	class ITraceDatabaseConnection;
	class ITraceTransaction;
	class ITraceParams;
	class ITraceStatement;
	class ITraceSQLStatement;
	class ITraceBLRStatement;
	class ITraceDYNRequest;
	class ITraceContextVariable;
	class ITraceProcedure;
	class ITraceFunction;
	class ITraceTrigger;
	class ITraceServiceConnection;
	class ITraceStatusVector;
	class ITraceSweepInfo;
	class ITraceLogWriter;
	class ITraceInitInfo;
	class ITracePlugin;
	class ITraceFactory;

	// Interfaces declarations

	class IVersioned
	{
	public:
		struct VTable
		{
			void* cloopDummy[1];
			uintptr_t version;
			IPluginModule* (CLOOP_CARG *getModule)(IVersioned* self) throw();
		};

		void* cloopDummy[1];
		VTable* cloopVTable;

	protected:
		IVersioned(DoNotInherit)
		{
		}

		~IVersioned()
		{
		}

	public:
		static const unsigned VERSION = 1;

		IPluginModule* getModule()
		{
			IPluginModule* ret = static_cast<VTable*>(this->cloopVTable)->getModule(this);
			return ret;
		}
	};

	class IReferenceCounted : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			void (CLOOP_CARG *addRef)(IReferenceCounted* self) throw();
			int (CLOOP_CARG *release)(IReferenceCounted* self) throw();
		};

	protected:
		IReferenceCounted(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IReferenceCounted()
		{
		}

	public:
		static const unsigned VERSION = 2;

		void addRef()
		{
			static_cast<VTable*>(this->cloopVTable)->addRef(this);
		}

		int release()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->release(this);
			return ret;
		}
	};

	class IDisposable : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			void (CLOOP_CARG *dispose)(IDisposable* self) throw();
		};

	protected:
		IDisposable(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IDisposable()
		{
		}

	public:
		static const unsigned VERSION = 2;

		void dispose()
		{
			static_cast<VTable*>(this->cloopVTable)->dispose(this);
		}
	};

	class IStatus : public IDisposable
	{
	public:
		struct VTable : public IDisposable::VTable
		{
			void (CLOOP_CARG *init)(IStatus* self) throw();
			unsigned (CLOOP_CARG *getStatus)(const IStatus* self) throw();
			void (CLOOP_CARG *setErrors2)(IStatus* self, unsigned length, const intptr_t* value) throw();
			void (CLOOP_CARG *setWarnings2)(IStatus* self, unsigned length, const intptr_t* value) throw();
			void (CLOOP_CARG *setErrors)(IStatus* self, const intptr_t* value) throw();
			void (CLOOP_CARG *setWarnings)(IStatus* self, const intptr_t* value) throw();
			const intptr_t* (CLOOP_CARG *getErrors)(const IStatus* self) throw();
			const intptr_t* (CLOOP_CARG *getWarnings)(const IStatus* self) throw();
		};

	protected:
		IStatus(DoNotInherit)
			: IDisposable(DoNotInherit())
		{
		}

		~IStatus()
		{
		}

	public:
		static const unsigned VERSION = 3;

		static const unsigned FB_HAS_WARNINGS = 1;
		static const unsigned FB_HAS_ERRORS = 2;
		static const int FB_ERROR = -1;
		static const int FB_OK = 0;
		static const int FB_EOF = 1;
		static const int FB_SEGMENT = 2;

		void init()
		{
			static_cast<VTable*>(this->cloopVTable)->init(this);
		}

		unsigned getStatus() const
		{
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getStatus(this);
			return ret;
		}

		void setErrors2(unsigned length, const intptr_t* value)
		{
			static_cast<VTable*>(this->cloopVTable)->setErrors2(this, length, value);
		}

		void setWarnings2(unsigned length, const intptr_t* value)
		{
			static_cast<VTable*>(this->cloopVTable)->setWarnings2(this, length, value);
		}

		void setErrors(const intptr_t* value)
		{
			static_cast<VTable*>(this->cloopVTable)->setErrors(this, value);
		}

		void setWarnings(const intptr_t* value)
		{
			static_cast<VTable*>(this->cloopVTable)->setWarnings(this, value);
		}

		const intptr_t* getErrors() const
		{
			const intptr_t* ret = static_cast<VTable*>(this->cloopVTable)->getErrors(this);
			return ret;
		}

		const intptr_t* getWarnings() const
		{
			const intptr_t* ret = static_cast<VTable*>(this->cloopVTable)->getWarnings(this);
			return ret;
		}
	};

	class IMaster : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			IStatus* (CLOOP_CARG *getStatus)(IMaster* self) throw();
			IProvider* (CLOOP_CARG *getDispatcher)(IMaster* self) throw();
			IPluginManager* (CLOOP_CARG *getPluginManager)(IMaster* self) throw();
			const char* (CLOOP_CARG *circularAlloc)(IMaster* self, const char* s, unsigned len, intptr_t thr) throw();
			ITimerControl* (CLOOP_CARG *getTimerControl)(IMaster* self) throw();
			IDtc* (CLOOP_CARG *getDtc)(IMaster* self) throw();
			IAttachment* (CLOOP_CARG *registerAttachment)(IMaster* self, IProvider* provider, IAttachment* attachment) throw();
			ITransaction* (CLOOP_CARG *registerTransaction)(IMaster* self, IAttachment* attachment, ITransaction* transaction) throw();
			int (CLOOP_CARG *same)(IMaster* self, IVersioned* first, IVersioned* second) throw();
			IMetadataBuilder* (CLOOP_CARG *getMetadataBuilder)(IMaster* self, IStatus* status, unsigned fieldCount) throw();
			int (CLOOP_CARG *serverMode)(IMaster* self, int mode) throw();
			IUtl* (CLOOP_CARG *getUtlInterface)(IMaster* self) throw();
			IConfigManager* (CLOOP_CARG *getConfigManager)(IMaster* self) throw();
		};

	protected:
		IMaster(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IMaster()
		{
		}

	public:
		static const unsigned VERSION = 2;

		IStatus* getStatus()
		{
			IStatus* ret = static_cast<VTable*>(this->cloopVTable)->getStatus(this);
			return ret;
		}

		IProvider* getDispatcher()
		{
			IProvider* ret = static_cast<VTable*>(this->cloopVTable)->getDispatcher(this);
			return ret;
		}

		IPluginManager* getPluginManager()
		{
			IPluginManager* ret = static_cast<VTable*>(this->cloopVTable)->getPluginManager(this);
			return ret;
		}

		const char* circularAlloc(const char* s, unsigned len, intptr_t thr)
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->circularAlloc(this, s, len, thr);
			return ret;
		}

		ITimerControl* getTimerControl()
		{
			ITimerControl* ret = static_cast<VTable*>(this->cloopVTable)->getTimerControl(this);
			return ret;
		}

		IDtc* getDtc()
		{
			IDtc* ret = static_cast<VTable*>(this->cloopVTable)->getDtc(this);
			return ret;
		}

		IAttachment* registerAttachment(IProvider* provider, IAttachment* attachment)
		{
			IAttachment* ret = static_cast<VTable*>(this->cloopVTable)->registerAttachment(this, provider, attachment);
			return ret;
		}

		ITransaction* registerTransaction(IAttachment* attachment, ITransaction* transaction)
		{
			ITransaction* ret = static_cast<VTable*>(this->cloopVTable)->registerTransaction(this, attachment, transaction);
			return ret;
		}

		int same(IVersioned* first, IVersioned* second)
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->same(this, first, second);
			return ret;
		}

		IMetadataBuilder* getMetadataBuilder(IStatus* status, unsigned fieldCount)
		{
			typename Policy::IStatus status2(status);
			IMetadataBuilder* ret = static_cast<VTable*>(this->cloopVTable)->getMetadataBuilder(this, status2, fieldCount);
			Policy::checkException(status2);
			return ret;
		}

		int serverMode(int mode)
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->serverMode(this, mode);
			return ret;
		}

		IUtl* getUtlInterface()
		{
			IUtl* ret = static_cast<VTable*>(this->cloopVTable)->getUtlInterface(this);
			return ret;
		}

		IConfigManager* getConfigManager()
		{
			IConfigManager* ret = static_cast<VTable*>(this->cloopVTable)->getConfigManager(this);
			return ret;
		}
	};

	class IPluginBase : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			void (CLOOP_CARG *setOwner)(IPluginBase* self, IReferenceCounted* r) throw();
			IReferenceCounted* (CLOOP_CARG *getOwner)(IPluginBase* self) throw();
		};

	protected:
		IPluginBase(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~IPluginBase()
		{
		}

	public:
		static const unsigned VERSION = 3;

		void setOwner(IReferenceCounted* r)
		{
			static_cast<VTable*>(this->cloopVTable)->setOwner(this, r);
		}

		IReferenceCounted* getOwner()
		{
			IReferenceCounted* ret = static_cast<VTable*>(this->cloopVTable)->getOwner(this);
			return ret;
		}
	};

	class IPluginSet : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			const char* (CLOOP_CARG *getName)(const IPluginSet* self) throw();
			const char* (CLOOP_CARG *getModuleName)(const IPluginSet* self) throw();
			IPluginBase* (CLOOP_CARG *getPlugin)(IPluginSet* self, IStatus* status) throw();
			void (CLOOP_CARG *next)(IPluginSet* self, IStatus* status) throw();
			void (CLOOP_CARG *set)(IPluginSet* self, IStatus* status, const char* s) throw();
		};

	protected:
		IPluginSet(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~IPluginSet()
		{
		}

	public:
		static const unsigned VERSION = 3;

		const char* getName() const
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getName(this);
			return ret;
		}

		const char* getModuleName() const
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getModuleName(this);
			return ret;
		}

		IPluginBase* getPlugin(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			IPluginBase* ret = static_cast<VTable*>(this->cloopVTable)->getPlugin(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		void next(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->next(this, status2);
			Policy::checkException(status2);
		}

		void set(IStatus* status, const char* s)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->set(this, status2, s);
			Policy::checkException(status2);
		}
	};

	class IConfigEntry : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			const char* (CLOOP_CARG *getName)(IConfigEntry* self) throw();
			const char* (CLOOP_CARG *getValue)(IConfigEntry* self) throw();
			ISC_INT64 (CLOOP_CARG *getIntValue)(IConfigEntry* self) throw();
			FB_BOOLEAN (CLOOP_CARG *getBoolValue)(IConfigEntry* self) throw();
			IConfig* (CLOOP_CARG *getSubConfig)(IConfigEntry* self, IStatus* status) throw();
		};

	protected:
		IConfigEntry(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~IConfigEntry()
		{
		}

	public:
		static const unsigned VERSION = 3;

		const char* getName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getName(this);
			return ret;
		}

		const char* getValue()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getValue(this);
			return ret;
		}

		ISC_INT64 getIntValue()
		{
			ISC_INT64 ret = static_cast<VTable*>(this->cloopVTable)->getIntValue(this);
			return ret;
		}

		FB_BOOLEAN getBoolValue()
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->getBoolValue(this);
			return ret;
		}

		IConfig* getSubConfig(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			IConfig* ret = static_cast<VTable*>(this->cloopVTable)->getSubConfig(this, status2);
			Policy::checkException(status2);
			return ret;
		}
	};

	class IConfig : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			IConfigEntry* (CLOOP_CARG *find)(IConfig* self, IStatus* status, const char* name) throw();
			IConfigEntry* (CLOOP_CARG *findValue)(IConfig* self, IStatus* status, const char* name, const char* value) throw();
			IConfigEntry* (CLOOP_CARG *findPos)(IConfig* self, IStatus* status, const char* name, unsigned pos) throw();
		};

	protected:
		IConfig(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~IConfig()
		{
		}

	public:
		static const unsigned VERSION = 3;

		IConfigEntry* find(IStatus* status, const char* name)
		{
			typename Policy::IStatus status2(status);
			IConfigEntry* ret = static_cast<VTable*>(this->cloopVTable)->find(this, status2, name);
			Policy::checkException(status2);
			return ret;
		}

		IConfigEntry* findValue(IStatus* status, const char* name, const char* value)
		{
			typename Policy::IStatus status2(status);
			IConfigEntry* ret = static_cast<VTable*>(this->cloopVTable)->findValue(this, status2, name, value);
			Policy::checkException(status2);
			return ret;
		}

		IConfigEntry* findPos(IStatus* status, const char* name, unsigned pos)
		{
			typename Policy::IStatus status2(status);
			IConfigEntry* ret = static_cast<VTable*>(this->cloopVTable)->findPos(this, status2, name, pos);
			Policy::checkException(status2);
			return ret;
		}
	};

	class IFirebirdConf : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			unsigned (CLOOP_CARG *getKey)(IFirebirdConf* self, const char* name) throw();
			ISC_INT64 (CLOOP_CARG *asInteger)(IFirebirdConf* self, unsigned key) throw();
			const char* (CLOOP_CARG *asString)(IFirebirdConf* self, unsigned key) throw();
			FB_BOOLEAN (CLOOP_CARG *asBoolean)(IFirebirdConf* self, unsigned key) throw();
		};

	protected:
		IFirebirdConf(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~IFirebirdConf()
		{
		}

	public:
		static const unsigned VERSION = 3;

		unsigned getKey(const char* name)
		{
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getKey(this, name);
			return ret;
		}

		ISC_INT64 asInteger(unsigned key)
		{
			ISC_INT64 ret = static_cast<VTable*>(this->cloopVTable)->asInteger(this, key);
			return ret;
		}

		const char* asString(unsigned key)
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->asString(this, key);
			return ret;
		}

		FB_BOOLEAN asBoolean(unsigned key)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->asBoolean(this, key);
			return ret;
		}
	};

	class IPluginConfig : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			const char* (CLOOP_CARG *getConfigFileName)(IPluginConfig* self) throw();
			IConfig* (CLOOP_CARG *getDefaultConfig)(IPluginConfig* self, IStatus* status) throw();
			IFirebirdConf* (CLOOP_CARG *getFirebirdConf)(IPluginConfig* self, IStatus* status) throw();
			void (CLOOP_CARG *setReleaseDelay)(IPluginConfig* self, IStatus* status, ISC_UINT64 microSeconds) throw();
		};

	protected:
		IPluginConfig(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~IPluginConfig()
		{
		}

	public:
		static const unsigned VERSION = 3;

		const char* getConfigFileName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getConfigFileName(this);
			return ret;
		}

		IConfig* getDefaultConfig(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			IConfig* ret = static_cast<VTable*>(this->cloopVTable)->getDefaultConfig(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		IFirebirdConf* getFirebirdConf(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			IFirebirdConf* ret = static_cast<VTable*>(this->cloopVTable)->getFirebirdConf(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		void setReleaseDelay(IStatus* status, ISC_UINT64 microSeconds)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->setReleaseDelay(this, status2, microSeconds);
			Policy::checkException(status2);
		}
	};

	class IPluginFactory : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			IPluginBase* (CLOOP_CARG *createPlugin)(IPluginFactory* self, IStatus* status, IPluginConfig* factoryParameter) throw();
		};

	protected:
		IPluginFactory(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IPluginFactory()
		{
		}

	public:
		static const unsigned VERSION = 2;

		IPluginBase* createPlugin(IStatus* status, IPluginConfig* factoryParameter)
		{
			typename Policy::IStatus status2(status);
			IPluginBase* ret = static_cast<VTable*>(this->cloopVTable)->createPlugin(this, status2, factoryParameter);
			Policy::checkException(status2);
			return ret;
		}
	};

	class IPluginModule : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			void (CLOOP_CARG *doClean)(IPluginModule* self) throw();
		};

	protected:
		IPluginModule(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IPluginModule()
		{
		}

	public:
		static const unsigned VERSION = 2;

		void doClean()
		{
			static_cast<VTable*>(this->cloopVTable)->doClean(this);
		}
	};

	class IPluginManager : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			void (CLOOP_CARG *registerPluginFactory)(IPluginManager* self, unsigned pluginType, const char* defaultName, IPluginFactory* factory) throw();
			void (CLOOP_CARG *registerModule)(IPluginManager* self, IPluginModule* cleanup) throw();
			void (CLOOP_CARG *unregisterModule)(IPluginManager* self, IPluginModule* cleanup) throw();
			IPluginSet* (CLOOP_CARG *getPlugins)(IPluginManager* self, IStatus* status, unsigned pluginType, const char* namesList, IFirebirdConf* firebirdConf) throw();
			IConfig* (CLOOP_CARG *getConfig)(IPluginManager* self, IStatus* status, const char* filename) throw();
			void (CLOOP_CARG *releasePlugin)(IPluginManager* self, IPluginBase* plugin) throw();
		};

	protected:
		IPluginManager(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IPluginManager()
		{
		}

	public:
		static const unsigned VERSION = 2;

		static const unsigned Provider = 1;
		static const unsigned FirstNonLibPlugin = 2;
		static const unsigned AuthServer = 3;
		static const unsigned AuthClient = 4;
		static const unsigned AuthUserManagement = 5;
		static const unsigned ExternalEngine = 6;
		static const unsigned Trace = 7;
		static const unsigned WireCrypt = 8;
		static const unsigned DbCrypt = 9;
		static const unsigned KeyHolder = 10;
		static const unsigned MaxType = 11;

		void registerPluginFactory(unsigned pluginType, const char* defaultName, IPluginFactory* factory)
		{
			static_cast<VTable*>(this->cloopVTable)->registerPluginFactory(this, pluginType, defaultName, factory);
		}

		void registerModule(IPluginModule* cleanup)
		{
			static_cast<VTable*>(this->cloopVTable)->registerModule(this, cleanup);
		}

		void unregisterModule(IPluginModule* cleanup)
		{
			static_cast<VTable*>(this->cloopVTable)->unregisterModule(this, cleanup);
		}

		IPluginSet* getPlugins(IStatus* status, unsigned pluginType, const char* namesList, IFirebirdConf* firebirdConf)
		{
			typename Policy::IStatus status2(status);
			IPluginSet* ret = static_cast<VTable*>(this->cloopVTable)->getPlugins(this, status2, pluginType, namesList, firebirdConf);
			Policy::checkException(status2);
			return ret;
		}

		IConfig* getConfig(IStatus* status, const char* filename)
		{
			typename Policy::IStatus status2(status);
			IConfig* ret = static_cast<VTable*>(this->cloopVTable)->getConfig(this, status2, filename);
			Policy::checkException(status2);
			return ret;
		}

		void releasePlugin(IPluginBase* plugin)
		{
			static_cast<VTable*>(this->cloopVTable)->releasePlugin(this, plugin);
		}
	};

	class IConfigManager : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			const char* (CLOOP_CARG *getDirectory)(IConfigManager* self, unsigned code) throw();
			IFirebirdConf* (CLOOP_CARG *getFirebirdConf)(IConfigManager* self) throw();
			IFirebirdConf* (CLOOP_CARG *getDatabaseConf)(IConfigManager* self, const char* dbName) throw();
			IConfig* (CLOOP_CARG *getPluginConfig)(IConfigManager* self, const char* configuredPlugin) throw();
			const char* (CLOOP_CARG *getInstallDirectory)(IConfigManager* self) throw();
			const char* (CLOOP_CARG *getRootDirectory)(IConfigManager* self) throw();
		};

	protected:
		IConfigManager(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IConfigManager()
		{
		}

	public:
		static const unsigned VERSION = 2;

		static const unsigned FB_DIR_BIN = 0;
		static const unsigned FB_DIR_SBIN = 1;
		static const unsigned FB_DIR_CONF = 2;
		static const unsigned FB_DIR_LIB = 3;
		static const unsigned FB_DIR_INC = 4;
		static const unsigned FB_DIR_DOC = 5;
		static const unsigned FB_DIR_UDF = 6;
		static const unsigned FB_DIR_SAMPLE = 7;
		static const unsigned FB_DIR_SAMPLEDB = 8;
		static const unsigned FB_DIR_HELP = 9;
		static const unsigned FB_DIR_INTL = 10;
		static const unsigned FB_DIR_MISC = 11;
		static const unsigned FB_DIR_SECDB = 12;
		static const unsigned FB_DIR_MSG = 13;
		static const unsigned FB_DIR_LOG = 14;
		static const unsigned FB_DIR_GUARD = 15;
		static const unsigned FB_DIR_PLUGINS = 16;
		static const unsigned FB_DIRCOUNT = 17;

		const char* getDirectory(unsigned code)
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getDirectory(this, code);
			return ret;
		}

		IFirebirdConf* getFirebirdConf()
		{
			IFirebirdConf* ret = static_cast<VTable*>(this->cloopVTable)->getFirebirdConf(this);
			return ret;
		}

		IFirebirdConf* getDatabaseConf(const char* dbName)
		{
			IFirebirdConf* ret = static_cast<VTable*>(this->cloopVTable)->getDatabaseConf(this, dbName);
			return ret;
		}

		IConfig* getPluginConfig(const char* configuredPlugin)
		{
			IConfig* ret = static_cast<VTable*>(this->cloopVTable)->getPluginConfig(this, configuredPlugin);
			return ret;
		}

		const char* getInstallDirectory()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getInstallDirectory(this);
			return ret;
		}

		const char* getRootDirectory()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getRootDirectory(this);
			return ret;
		}
	};

	class IEventCallback : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			void (CLOOP_CARG *eventCallbackFunction)(IEventCallback* self, unsigned length, const unsigned char* events) throw();
		};

	protected:
		IEventCallback(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~IEventCallback()
		{
		}

	public:
		static const unsigned VERSION = 3;

		void eventCallbackFunction(unsigned length, const unsigned char* events)
		{
			static_cast<VTable*>(this->cloopVTable)->eventCallbackFunction(this, length, events);
		}
	};

	class IBlob : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			void (CLOOP_CARG *getInfo)(IBlob* self, IStatus* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) throw();
			int (CLOOP_CARG *getSegment)(IBlob* self, IStatus* status, unsigned bufferLength, void* buffer, unsigned* segmentLength) throw();
			void (CLOOP_CARG *putSegment)(IBlob* self, IStatus* status, unsigned length, const void* buffer) throw();
			void (CLOOP_CARG *cancel)(IBlob* self, IStatus* status) throw();
			void (CLOOP_CARG *close)(IBlob* self, IStatus* status) throw();
			int (CLOOP_CARG *seek)(IBlob* self, IStatus* status, int mode, int offset) throw();
		};

	protected:
		IBlob(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~IBlob()
		{
		}

	public:
		static const unsigned VERSION = 3;

		void getInfo(IStatus* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->getInfo(this, status2, itemsLength, items, bufferLength, buffer);
			Policy::checkException(status2);
		}

		int getSegment(IStatus* status, unsigned bufferLength, void* buffer, unsigned* segmentLength)
		{
			typename Policy::IStatus status2(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->getSegment(this, status2, bufferLength, buffer, segmentLength);
			Policy::checkException(status2);
			return ret;
		}

		void putSegment(IStatus* status, unsigned length, const void* buffer)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->putSegment(this, status2, length, buffer);
			Policy::checkException(status2);
		}

		void cancel(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->cancel(this, status2);
			Policy::checkException(status2);
		}

		void close(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->close(this, status2);
			Policy::checkException(status2);
		}

		int seek(IStatus* status, int mode, int offset)
		{
			typename Policy::IStatus status2(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->seek(this, status2, mode, offset);
			Policy::checkException(status2);
			return ret;
		}
	};

	class ITransaction : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			void (CLOOP_CARG *getInfo)(ITransaction* self, IStatus* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) throw();
			void (CLOOP_CARG *prepare)(ITransaction* self, IStatus* status, unsigned msgLength, const unsigned char* message) throw();
			void (CLOOP_CARG *commit)(ITransaction* self, IStatus* status) throw();
			void (CLOOP_CARG *commitRetaining)(ITransaction* self, IStatus* status) throw();
			void (CLOOP_CARG *rollback)(ITransaction* self, IStatus* status) throw();
			void (CLOOP_CARG *rollbackRetaining)(ITransaction* self, IStatus* status) throw();
			void (CLOOP_CARG *disconnect)(ITransaction* self, IStatus* status) throw();
			ITransaction* (CLOOP_CARG *join)(ITransaction* self, IStatus* status, ITransaction* transaction) throw();
			ITransaction* (CLOOP_CARG *validate)(ITransaction* self, IStatus* status, IAttachment* attachment) throw();
			ITransaction* (CLOOP_CARG *enterDtc)(ITransaction* self, IStatus* status) throw();
		};

	protected:
		ITransaction(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~ITransaction()
		{
		}

	public:
		static const unsigned VERSION = 3;

		void getInfo(IStatus* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->getInfo(this, status2, itemsLength, items, bufferLength, buffer);
			Policy::checkException(status2);
		}

		void prepare(IStatus* status, unsigned msgLength, const unsigned char* message)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->prepare(this, status2, msgLength, message);
			Policy::checkException(status2);
		}

		void commit(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->commit(this, status2);
			Policy::checkException(status2);
		}

		void commitRetaining(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->commitRetaining(this, status2);
			Policy::checkException(status2);
		}

		void rollback(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->rollback(this, status2);
			Policy::checkException(status2);
		}

		void rollbackRetaining(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->rollbackRetaining(this, status2);
			Policy::checkException(status2);
		}

		void disconnect(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->disconnect(this, status2);
			Policy::checkException(status2);
		}

		ITransaction* join(IStatus* status, ITransaction* transaction)
		{
			typename Policy::IStatus status2(status);
			ITransaction* ret = static_cast<VTable*>(this->cloopVTable)->join(this, status2, transaction);
			Policy::checkException(status2);
			return ret;
		}

		ITransaction* validate(IStatus* status, IAttachment* attachment)
		{
			typename Policy::IStatus status2(status);
			ITransaction* ret = static_cast<VTable*>(this->cloopVTable)->validate(this, status2, attachment);
			Policy::checkException(status2);
			return ret;
		}

		ITransaction* enterDtc(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			ITransaction* ret = static_cast<VTable*>(this->cloopVTable)->enterDtc(this, status2);
			Policy::checkException(status2);
			return ret;
		}
	};

	class IMessageMetadata : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			unsigned (CLOOP_CARG *getCount)(IMessageMetadata* self, IStatus* status) throw();
			const char* (CLOOP_CARG *getField)(IMessageMetadata* self, IStatus* status, unsigned index) throw();
			const char* (CLOOP_CARG *getRelation)(IMessageMetadata* self, IStatus* status, unsigned index) throw();
			const char* (CLOOP_CARG *getOwner)(IMessageMetadata* self, IStatus* status, unsigned index) throw();
			const char* (CLOOP_CARG *getAlias)(IMessageMetadata* self, IStatus* status, unsigned index) throw();
			unsigned (CLOOP_CARG *getType)(IMessageMetadata* self, IStatus* status, unsigned index) throw();
			FB_BOOLEAN (CLOOP_CARG *isNullable)(IMessageMetadata* self, IStatus* status, unsigned index) throw();
			int (CLOOP_CARG *getSubType)(IMessageMetadata* self, IStatus* status, unsigned index) throw();
			unsigned (CLOOP_CARG *getLength)(IMessageMetadata* self, IStatus* status, unsigned index) throw();
			int (CLOOP_CARG *getScale)(IMessageMetadata* self, IStatus* status, unsigned index) throw();
			unsigned (CLOOP_CARG *getCharSet)(IMessageMetadata* self, IStatus* status, unsigned index) throw();
			unsigned (CLOOP_CARG *getOffset)(IMessageMetadata* self, IStatus* status, unsigned index) throw();
			unsigned (CLOOP_CARG *getNullOffset)(IMessageMetadata* self, IStatus* status, unsigned index) throw();
			IMetadataBuilder* (CLOOP_CARG *getBuilder)(IMessageMetadata* self, IStatus* status) throw();
			unsigned (CLOOP_CARG *getMessageLength)(IMessageMetadata* self, IStatus* status) throw();
		};

	protected:
		IMessageMetadata(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~IMessageMetadata()
		{
		}

	public:
		static const unsigned VERSION = 3;

		unsigned getCount(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getCount(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		const char* getField(IStatus* status, unsigned index)
		{
			typename Policy::IStatus status2(status);
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getField(this, status2, index);
			Policy::checkException(status2);
			return ret;
		}

		const char* getRelation(IStatus* status, unsigned index)
		{
			typename Policy::IStatus status2(status);
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getRelation(this, status2, index);
			Policy::checkException(status2);
			return ret;
		}

		const char* getOwner(IStatus* status, unsigned index)
		{
			typename Policy::IStatus status2(status);
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getOwner(this, status2, index);
			Policy::checkException(status2);
			return ret;
		}

		const char* getAlias(IStatus* status, unsigned index)
		{
			typename Policy::IStatus status2(status);
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getAlias(this, status2, index);
			Policy::checkException(status2);
			return ret;
		}

		unsigned getType(IStatus* status, unsigned index)
		{
			typename Policy::IStatus status2(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getType(this, status2, index);
			Policy::checkException(status2);
			return ret;
		}

		FB_BOOLEAN isNullable(IStatus* status, unsigned index)
		{
			typename Policy::IStatus status2(status);
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->isNullable(this, status2, index);
			Policy::checkException(status2);
			return ret;
		}

		int getSubType(IStatus* status, unsigned index)
		{
			typename Policy::IStatus status2(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->getSubType(this, status2, index);
			Policy::checkException(status2);
			return ret;
		}

		unsigned getLength(IStatus* status, unsigned index)
		{
			typename Policy::IStatus status2(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getLength(this, status2, index);
			Policy::checkException(status2);
			return ret;
		}

		int getScale(IStatus* status, unsigned index)
		{
			typename Policy::IStatus status2(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->getScale(this, status2, index);
			Policy::checkException(status2);
			return ret;
		}

		unsigned getCharSet(IStatus* status, unsigned index)
		{
			typename Policy::IStatus status2(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getCharSet(this, status2, index);
			Policy::checkException(status2);
			return ret;
		}

		unsigned getOffset(IStatus* status, unsigned index)
		{
			typename Policy::IStatus status2(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getOffset(this, status2, index);
			Policy::checkException(status2);
			return ret;
		}

		unsigned getNullOffset(IStatus* status, unsigned index)
		{
			typename Policy::IStatus status2(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getNullOffset(this, status2, index);
			Policy::checkException(status2);
			return ret;
		}

		IMetadataBuilder* getBuilder(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			IMetadataBuilder* ret = static_cast<VTable*>(this->cloopVTable)->getBuilder(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		unsigned getMessageLength(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getMessageLength(this, status2);
			Policy::checkException(status2);
			return ret;
		}
	};

	class IMetadataBuilder : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			void (CLOOP_CARG *setType)(IMetadataBuilder* self, IStatus* status, unsigned index, unsigned type) throw();
			void (CLOOP_CARG *setSubType)(IMetadataBuilder* self, IStatus* status, unsigned index, int subType) throw();
			void (CLOOP_CARG *setLength)(IMetadataBuilder* self, IStatus* status, unsigned index, unsigned length) throw();
			void (CLOOP_CARG *setCharSet)(IMetadataBuilder* self, IStatus* status, unsigned index, unsigned charSet) throw();
			void (CLOOP_CARG *setScale)(IMetadataBuilder* self, IStatus* status, unsigned index, unsigned scale) throw();
			void (CLOOP_CARG *truncate)(IMetadataBuilder* self, IStatus* status, unsigned count) throw();
			void (CLOOP_CARG *moveNameToIndex)(IMetadataBuilder* self, IStatus* status, const char* name, unsigned index) throw();
			void (CLOOP_CARG *remove)(IMetadataBuilder* self, IStatus* status, unsigned index) throw();
			unsigned (CLOOP_CARG *addField)(IMetadataBuilder* self, IStatus* status) throw();
			IMessageMetadata* (CLOOP_CARG *getMetadata)(IMetadataBuilder* self, IStatus* status) throw();
		};

	protected:
		IMetadataBuilder(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~IMetadataBuilder()
		{
		}

	public:
		static const unsigned VERSION = 3;

		void setType(IStatus* status, unsigned index, unsigned type)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->setType(this, status2, index, type);
			Policy::checkException(status2);
		}

		void setSubType(IStatus* status, unsigned index, int subType)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->setSubType(this, status2, index, subType);
			Policy::checkException(status2);
		}

		void setLength(IStatus* status, unsigned index, unsigned length)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->setLength(this, status2, index, length);
			Policy::checkException(status2);
		}

		void setCharSet(IStatus* status, unsigned index, unsigned charSet)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->setCharSet(this, status2, index, charSet);
			Policy::checkException(status2);
		}

		void setScale(IStatus* status, unsigned index, unsigned scale)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->setScale(this, status2, index, scale);
			Policy::checkException(status2);
		}

		void truncate(IStatus* status, unsigned count)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->truncate(this, status2, count);
			Policy::checkException(status2);
		}

		void moveNameToIndex(IStatus* status, const char* name, unsigned index)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->moveNameToIndex(this, status2, name, index);
			Policy::checkException(status2);
		}

		void remove(IStatus* status, unsigned index)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->remove(this, status2, index);
			Policy::checkException(status2);
		}

		unsigned addField(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->addField(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		IMessageMetadata* getMetadata(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			IMessageMetadata* ret = static_cast<VTable*>(this->cloopVTable)->getMetadata(this, status2);
			Policy::checkException(status2);
			return ret;
		}
	};

	class IResultSet : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			int (CLOOP_CARG *fetchNext)(IResultSet* self, IStatus* status, void* message) throw();
			int (CLOOP_CARG *fetchPrior)(IResultSet* self, IStatus* status, void* message) throw();
			int (CLOOP_CARG *fetchFirst)(IResultSet* self, IStatus* status, void* message) throw();
			int (CLOOP_CARG *fetchLast)(IResultSet* self, IStatus* status, void* message) throw();
			int (CLOOP_CARG *fetchAbsolute)(IResultSet* self, IStatus* status, unsigned position, void* message) throw();
			int (CLOOP_CARG *fetchRelative)(IResultSet* self, IStatus* status, int offset, void* message) throw();
			FB_BOOLEAN (CLOOP_CARG *isEof)(IResultSet* self, IStatus* status) throw();
			FB_BOOLEAN (CLOOP_CARG *isBof)(IResultSet* self, IStatus* status) throw();
			IMessageMetadata* (CLOOP_CARG *getMetadata)(IResultSet* self, IStatus* status) throw();
			void (CLOOP_CARG *close)(IResultSet* self, IStatus* status) throw();
			void (CLOOP_CARG *setDelayedOutputFormat)(IResultSet* self, IStatus* status, IMessageMetadata* format) throw();
		};

	protected:
		IResultSet(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~IResultSet()
		{
		}

	public:
		static const unsigned VERSION = 3;

		int fetchNext(IStatus* status, void* message)
		{
			typename Policy::IStatus status2(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->fetchNext(this, status2, message);
			Policy::checkException(status2);
			return ret;
		}

		int fetchPrior(IStatus* status, void* message)
		{
			typename Policy::IStatus status2(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->fetchPrior(this, status2, message);
			Policy::checkException(status2);
			return ret;
		}

		int fetchFirst(IStatus* status, void* message)
		{
			typename Policy::IStatus status2(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->fetchFirst(this, status2, message);
			Policy::checkException(status2);
			return ret;
		}

		int fetchLast(IStatus* status, void* message)
		{
			typename Policy::IStatus status2(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->fetchLast(this, status2, message);
			Policy::checkException(status2);
			return ret;
		}

		int fetchAbsolute(IStatus* status, unsigned position, void* message)
		{
			typename Policy::IStatus status2(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->fetchAbsolute(this, status2, position, message);
			Policy::checkException(status2);
			return ret;
		}

		int fetchRelative(IStatus* status, int offset, void* message)
		{
			typename Policy::IStatus status2(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->fetchRelative(this, status2, offset, message);
			Policy::checkException(status2);
			return ret;
		}

		FB_BOOLEAN isEof(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->isEof(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		FB_BOOLEAN isBof(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->isBof(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		IMessageMetadata* getMetadata(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			IMessageMetadata* ret = static_cast<VTable*>(this->cloopVTable)->getMetadata(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		void close(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->close(this, status2);
			Policy::checkException(status2);
		}

		void setDelayedOutputFormat(IStatus* status, IMessageMetadata* format)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->setDelayedOutputFormat(this, status2, format);
			Policy::checkException(status2);
		}
	};

	class IStatement : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			void (CLOOP_CARG *getInfo)(IStatement* self, IStatus* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) throw();
			unsigned (CLOOP_CARG *getType)(IStatement* self, IStatus* status) throw();
			const char* (CLOOP_CARG *getPlan)(IStatement* self, IStatus* status, FB_BOOLEAN detailed) throw();
			ISC_UINT64 (CLOOP_CARG *getAffectedRecords)(IStatement* self, IStatus* status) throw();
			IMessageMetadata* (CLOOP_CARG *getInputMetadata)(IStatement* self, IStatus* status) throw();
			IMessageMetadata* (CLOOP_CARG *getOutputMetadata)(IStatement* self, IStatus* status) throw();
			ITransaction* (CLOOP_CARG *execute)(IStatement* self, IStatus* status, ITransaction* transaction, IMessageMetadata* inMetadata, void* inBuffer, IMessageMetadata* outMetadata, void* outBuffer) throw();
			IResultSet* (CLOOP_CARG *openCursor)(IStatement* self, IStatus* status, ITransaction* transaction, IMessageMetadata* inMetadata, void* inBuffer, IMessageMetadata* outMetadata) throw();
			void (CLOOP_CARG *setCursorName)(IStatement* self, IStatus* status, const char* name) throw();
			void (CLOOP_CARG *free)(IStatement* self, IStatus* status) throw();
			unsigned (CLOOP_CARG *getFlags)(IStatement* self, IStatus* status) throw();
		};

	protected:
		IStatement(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~IStatement()
		{
		}

	public:
		static const unsigned VERSION = 3;

		static const unsigned PREPARE_PREFETCH_NONE = 0;
		static const unsigned PREPARE_PREFETCH_TYPE = 1;
		static const unsigned PREPARE_PREFETCH_INPUT_PARAMETERS = 2;
		static const unsigned PREPARE_PREFETCH_OUTPUT_PARAMETERS = 4;
		static const unsigned PREPARE_PREFETCH_LEGACY_PLAN = 8;
		static const unsigned PREPARE_PREFETCH_DETAILED_PLAN = 16;
		static const unsigned PREPARE_PREFETCH_AFFECTED_RECORDS = 32;
		static const unsigned PREPARE_PREFETCH_FLAGS = 64;
		static const unsigned PREPARE_PREFETCH_METADATA = IStatement::PREPARE_PREFETCH_TYPE | IStatement::PREPARE_PREFETCH_FLAGS | IStatement::PREPARE_PREFETCH_INPUT_PARAMETERS | IStatement::PREPARE_PREFETCH_OUTPUT_PARAMETERS;
		static const unsigned PREPARE_PREFETCH_ALL = IStatement::PREPARE_PREFETCH_METADATA | IStatement::PREPARE_PREFETCH_LEGACY_PLAN | IStatement::PREPARE_PREFETCH_DETAILED_PLAN | IStatement::PREPARE_PREFETCH_AFFECTED_RECORDS;
		static const unsigned FLAG_HAS_CURSOR = 1;
		static const unsigned FLAG_REPEAT_EXECUTE = 2;

		void getInfo(IStatus* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->getInfo(this, status2, itemsLength, items, bufferLength, buffer);
			Policy::checkException(status2);
		}

		unsigned getType(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getType(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		const char* getPlan(IStatus* status, FB_BOOLEAN detailed)
		{
			typename Policy::IStatus status2(status);
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getPlan(this, status2, detailed);
			Policy::checkException(status2);
			return ret;
		}

		ISC_UINT64 getAffectedRecords(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			ISC_UINT64 ret = static_cast<VTable*>(this->cloopVTable)->getAffectedRecords(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		IMessageMetadata* getInputMetadata(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			IMessageMetadata* ret = static_cast<VTable*>(this->cloopVTable)->getInputMetadata(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		IMessageMetadata* getOutputMetadata(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			IMessageMetadata* ret = static_cast<VTable*>(this->cloopVTable)->getOutputMetadata(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		ITransaction* execute(IStatus* status, ITransaction* transaction, IMessageMetadata* inMetadata, void* inBuffer, IMessageMetadata* outMetadata, void* outBuffer)
		{
			typename Policy::IStatus status2(status);
			ITransaction* ret = static_cast<VTable*>(this->cloopVTable)->execute(this, status2, transaction, inMetadata, inBuffer, outMetadata, outBuffer);
			Policy::checkException(status2);
			return ret;
		}

		IResultSet* openCursor(IStatus* status, ITransaction* transaction, IMessageMetadata* inMetadata, void* inBuffer, IMessageMetadata* outMetadata)
		{
			typename Policy::IStatus status2(status);
			IResultSet* ret = static_cast<VTable*>(this->cloopVTable)->openCursor(this, status2, transaction, inMetadata, inBuffer, outMetadata);
			Policy::checkException(status2);
			return ret;
		}

		void setCursorName(IStatus* status, const char* name)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->setCursorName(this, status2, name);
			Policy::checkException(status2);
		}

		void free(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->free(this, status2);
			Policy::checkException(status2);
		}

		unsigned getFlags(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getFlags(this, status2);
			Policy::checkException(status2);
			return ret;
		}
	};

	class IRequest : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			void (CLOOP_CARG *receive)(IRequest* self, IStatus* status, int level, unsigned msgType, unsigned length, unsigned char* message) throw();
			void (CLOOP_CARG *send)(IRequest* self, IStatus* status, int level, unsigned msgType, unsigned length, const unsigned char* message) throw();
			void (CLOOP_CARG *getInfo)(IRequest* self, IStatus* status, int level, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) throw();
			void (CLOOP_CARG *start)(IRequest* self, IStatus* status, ITransaction* tra, int level) throw();
			void (CLOOP_CARG *startAndSend)(IRequest* self, IStatus* status, ITransaction* tra, int level, unsigned msgType, unsigned length, const unsigned char* message) throw();
			void (CLOOP_CARG *unwind)(IRequest* self, IStatus* status, int level) throw();
			void (CLOOP_CARG *free)(IRequest* self, IStatus* status) throw();
		};

	protected:
		IRequest(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~IRequest()
		{
		}

	public:
		static const unsigned VERSION = 3;

		void receive(IStatus* status, int level, unsigned msgType, unsigned length, unsigned char* message)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->receive(this, status2, level, msgType, length, message);
			Policy::checkException(status2);
		}

		void send(IStatus* status, int level, unsigned msgType, unsigned length, const unsigned char* message)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->send(this, status2, level, msgType, length, message);
			Policy::checkException(status2);
		}

		void getInfo(IStatus* status, int level, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->getInfo(this, status2, level, itemsLength, items, bufferLength, buffer);
			Policy::checkException(status2);
		}

		void start(IStatus* status, ITransaction* tra, int level)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->start(this, status2, tra, level);
			Policy::checkException(status2);
		}

		void startAndSend(IStatus* status, ITransaction* tra, int level, unsigned msgType, unsigned length, const unsigned char* message)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->startAndSend(this, status2, tra, level, msgType, length, message);
			Policy::checkException(status2);
		}

		void unwind(IStatus* status, int level)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->unwind(this, status2, level);
			Policy::checkException(status2);
		}

		void free(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->free(this, status2);
			Policy::checkException(status2);
		}
	};

	class IEvents : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			void (CLOOP_CARG *cancel)(IEvents* self, IStatus* status) throw();
		};

	protected:
		IEvents(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~IEvents()
		{
		}

	public:
		static const unsigned VERSION = 3;

		void cancel(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->cancel(this, status2);
			Policy::checkException(status2);
		}
	};

	class IAttachment : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			void (CLOOP_CARG *getInfo)(IAttachment* self, IStatus* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) throw();
			ITransaction* (CLOOP_CARG *startTransaction)(IAttachment* self, IStatus* status, unsigned tpbLength, const unsigned char* tpb) throw();
			ITransaction* (CLOOP_CARG *reconnectTransaction)(IAttachment* self, IStatus* status, unsigned length, const unsigned char* id) throw();
			IRequest* (CLOOP_CARG *compileRequest)(IAttachment* self, IStatus* status, unsigned blrLength, const unsigned char* blr) throw();
			void (CLOOP_CARG *transactRequest)(IAttachment* self, IStatus* status, ITransaction* transaction, unsigned blrLength, const unsigned char* blr, unsigned inMsgLength, const unsigned char* inMsg, unsigned outMsgLength, unsigned char* outMsg) throw();
			IBlob* (CLOOP_CARG *createBlob)(IAttachment* self, IStatus* status, ITransaction* transaction, ISC_QUAD* id, unsigned bpbLength, const unsigned char* bpb) throw();
			IBlob* (CLOOP_CARG *openBlob)(IAttachment* self, IStatus* status, ITransaction* transaction, ISC_QUAD* id, unsigned bpbLength, const unsigned char* bpb) throw();
			int (CLOOP_CARG *getSlice)(IAttachment* self, IStatus* status, ITransaction* transaction, ISC_QUAD* id, unsigned sdlLength, const unsigned char* sdl, unsigned paramLength, const unsigned char* param, int sliceLength, unsigned char* slice) throw();
			void (CLOOP_CARG *putSlice)(IAttachment* self, IStatus* status, ITransaction* transaction, ISC_QUAD* id, unsigned sdlLength, const unsigned char* sdl, unsigned paramLength, const unsigned char* param, int sliceLength, unsigned char* slice) throw();
			void (CLOOP_CARG *executeDyn)(IAttachment* self, IStatus* status, ITransaction* transaction, unsigned length, const unsigned char* dyn) throw();
			IStatement* (CLOOP_CARG *prepare)(IAttachment* self, IStatus* status, ITransaction* tra, unsigned stmtLength, const char* sqlStmt, unsigned dialect, unsigned flags) throw();
			ITransaction* (CLOOP_CARG *execute)(IAttachment* self, IStatus* status, ITransaction* transaction, unsigned stmtLength, const char* sqlStmt, unsigned dialect, IMessageMetadata* inMetadata, void* inBuffer, IMessageMetadata* outMetadata, void* outBuffer) throw();
			IResultSet* (CLOOP_CARG *openCursor)(IAttachment* self, IStatus* status, ITransaction* transaction, unsigned stmtLength, const char* sqlStmt, unsigned dialect, IMessageMetadata* inMetadata, void* inBuffer, IMessageMetadata* outMetadata, const char* cursorName) throw();
			IEvents* (CLOOP_CARG *queEvents)(IAttachment* self, IStatus* status, IEventCallback* callback, unsigned length, const unsigned char* events) throw();
			void (CLOOP_CARG *cancelOperation)(IAttachment* self, IStatus* status, int option) throw();
			void (CLOOP_CARG *ping)(IAttachment* self, IStatus* status) throw();
			void (CLOOP_CARG *detach)(IAttachment* self, IStatus* status) throw();
			void (CLOOP_CARG *dropDatabase)(IAttachment* self, IStatus* status) throw();
		};

	protected:
		IAttachment(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~IAttachment()
		{
		}

	public:
		static const unsigned VERSION = 3;

		void getInfo(IStatus* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->getInfo(this, status2, itemsLength, items, bufferLength, buffer);
			Policy::checkException(status2);
		}

		ITransaction* startTransaction(IStatus* status, unsigned tpbLength, const unsigned char* tpb)
		{
			typename Policy::IStatus status2(status);
			ITransaction* ret = static_cast<VTable*>(this->cloopVTable)->startTransaction(this, status2, tpbLength, tpb);
			Policy::checkException(status2);
			return ret;
		}

		ITransaction* reconnectTransaction(IStatus* status, unsigned length, const unsigned char* id)
		{
			typename Policy::IStatus status2(status);
			ITransaction* ret = static_cast<VTable*>(this->cloopVTable)->reconnectTransaction(this, status2, length, id);
			Policy::checkException(status2);
			return ret;
		}

		IRequest* compileRequest(IStatus* status, unsigned blrLength, const unsigned char* blr)
		{
			typename Policy::IStatus status2(status);
			IRequest* ret = static_cast<VTable*>(this->cloopVTable)->compileRequest(this, status2, blrLength, blr);
			Policy::checkException(status2);
			return ret;
		}

		void transactRequest(IStatus* status, ITransaction* transaction, unsigned blrLength, const unsigned char* blr, unsigned inMsgLength, const unsigned char* inMsg, unsigned outMsgLength, unsigned char* outMsg)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->transactRequest(this, status2, transaction, blrLength, blr, inMsgLength, inMsg, outMsgLength, outMsg);
			Policy::checkException(status2);
		}

		IBlob* createBlob(IStatus* status, ITransaction* transaction, ISC_QUAD* id, unsigned bpbLength, const unsigned char* bpb)
		{
			typename Policy::IStatus status2(status);
			IBlob* ret = static_cast<VTable*>(this->cloopVTable)->createBlob(this, status2, transaction, id, bpbLength, bpb);
			Policy::checkException(status2);
			return ret;
		}

		IBlob* openBlob(IStatus* status, ITransaction* transaction, ISC_QUAD* id, unsigned bpbLength, const unsigned char* bpb)
		{
			typename Policy::IStatus status2(status);
			IBlob* ret = static_cast<VTable*>(this->cloopVTable)->openBlob(this, status2, transaction, id, bpbLength, bpb);
			Policy::checkException(status2);
			return ret;
		}

		int getSlice(IStatus* status, ITransaction* transaction, ISC_QUAD* id, unsigned sdlLength, const unsigned char* sdl, unsigned paramLength, const unsigned char* param, int sliceLength, unsigned char* slice)
		{
			typename Policy::IStatus status2(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->getSlice(this, status2, transaction, id, sdlLength, sdl, paramLength, param, sliceLength, slice);
			Policy::checkException(status2);
			return ret;
		}

		void putSlice(IStatus* status, ITransaction* transaction, ISC_QUAD* id, unsigned sdlLength, const unsigned char* sdl, unsigned paramLength, const unsigned char* param, int sliceLength, unsigned char* slice)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->putSlice(this, status2, transaction, id, sdlLength, sdl, paramLength, param, sliceLength, slice);
			Policy::checkException(status2);
		}

		void executeDyn(IStatus* status, ITransaction* transaction, unsigned length, const unsigned char* dyn)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->executeDyn(this, status2, transaction, length, dyn);
			Policy::checkException(status2);
		}

		IStatement* prepare(IStatus* status, ITransaction* tra, unsigned stmtLength, const char* sqlStmt, unsigned dialect, unsigned flags)
		{
			typename Policy::IStatus status2(status);
			IStatement* ret = static_cast<VTable*>(this->cloopVTable)->prepare(this, status2, tra, stmtLength, sqlStmt, dialect, flags);
			Policy::checkException(status2);
			return ret;
		}

		ITransaction* execute(IStatus* status, ITransaction* transaction, unsigned stmtLength, const char* sqlStmt, unsigned dialect, IMessageMetadata* inMetadata, void* inBuffer, IMessageMetadata* outMetadata, void* outBuffer)
		{
			typename Policy::IStatus status2(status);
			ITransaction* ret = static_cast<VTable*>(this->cloopVTable)->execute(this, status2, transaction, stmtLength, sqlStmt, dialect, inMetadata, inBuffer, outMetadata, outBuffer);
			Policy::checkException(status2);
			return ret;
		}

		IResultSet* openCursor(IStatus* status, ITransaction* transaction, unsigned stmtLength, const char* sqlStmt, unsigned dialect, IMessageMetadata* inMetadata, void* inBuffer, IMessageMetadata* outMetadata, const char* cursorName)
		{
			typename Policy::IStatus status2(status);
			IResultSet* ret = static_cast<VTable*>(this->cloopVTable)->openCursor(this, status2, transaction, stmtLength, sqlStmt, dialect, inMetadata, inBuffer, outMetadata, cursorName);
			Policy::checkException(status2);
			return ret;
		}

		IEvents* queEvents(IStatus* status, IEventCallback* callback, unsigned length, const unsigned char* events)
		{
			typename Policy::IStatus status2(status);
			IEvents* ret = static_cast<VTable*>(this->cloopVTable)->queEvents(this, status2, callback, length, events);
			Policy::checkException(status2);
			return ret;
		}

		void cancelOperation(IStatus* status, int option)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->cancelOperation(this, status2, option);
			Policy::checkException(status2);
		}

		void ping(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->ping(this, status2);
			Policy::checkException(status2);
		}

		void detach(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->detach(this, status2);
			Policy::checkException(status2);
		}

		void dropDatabase(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->dropDatabase(this, status2);
			Policy::checkException(status2);
		}
	};

	class IService : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			void (CLOOP_CARG *detach)(IService* self, IStatus* status) throw();
			void (CLOOP_CARG *query)(IService* self, IStatus* status, unsigned sendLength, const unsigned char* sendItems, unsigned receiveLength, const unsigned char* receiveItems, unsigned bufferLength, unsigned char* buffer) throw();
			void (CLOOP_CARG *start)(IService* self, IStatus* status, unsigned spbLength, const unsigned char* spb) throw();
		};

	protected:
		IService(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~IService()
		{
		}

	public:
		static const unsigned VERSION = 3;

		void detach(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->detach(this, status2);
			Policy::checkException(status2);
		}

		void query(IStatus* status, unsigned sendLength, const unsigned char* sendItems, unsigned receiveLength, const unsigned char* receiveItems, unsigned bufferLength, unsigned char* buffer)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->query(this, status2, sendLength, sendItems, receiveLength, receiveItems, bufferLength, buffer);
			Policy::checkException(status2);
		}

		void start(IStatus* status, unsigned spbLength, const unsigned char* spb)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->start(this, status2, spbLength, spb);
			Policy::checkException(status2);
		}
	};

	class IProvider : public IPluginBase
	{
	public:
		struct VTable : public IPluginBase::VTable
		{
			IAttachment* (CLOOP_CARG *attachDatabase)(IProvider* self, IStatus* status, const char* fileName, unsigned dpbLength, const unsigned char* dpb) throw();
			IAttachment* (CLOOP_CARG *createDatabase)(IProvider* self, IStatus* status, const char* fileName, unsigned dpbLength, const unsigned char* dpb) throw();
			IService* (CLOOP_CARG *attachServiceManager)(IProvider* self, IStatus* status, const char* service, unsigned spbLength, const unsigned char* spb) throw();
			void (CLOOP_CARG *shutdown)(IProvider* self, IStatus* status, unsigned timeout, const int reason) throw();
			void (CLOOP_CARG *setDbCryptCallback)(IProvider* self, IStatus* status, ICryptKeyCallback* cryptCallback) throw();
		};

	protected:
		IProvider(DoNotInherit)
			: IPluginBase(DoNotInherit())
		{
		}

		~IProvider()
		{
		}

	public:
		static const unsigned VERSION = 4;

		IAttachment* attachDatabase(IStatus* status, const char* fileName, unsigned dpbLength, const unsigned char* dpb)
		{
			typename Policy::IStatus status2(status);
			IAttachment* ret = static_cast<VTable*>(this->cloopVTable)->attachDatabase(this, status2, fileName, dpbLength, dpb);
			Policy::checkException(status2);
			return ret;
		}

		IAttachment* createDatabase(IStatus* status, const char* fileName, unsigned dpbLength, const unsigned char* dpb)
		{
			typename Policy::IStatus status2(status);
			IAttachment* ret = static_cast<VTable*>(this->cloopVTable)->createDatabase(this, status2, fileName, dpbLength, dpb);
			Policy::checkException(status2);
			return ret;
		}

		IService* attachServiceManager(IStatus* status, const char* service, unsigned spbLength, const unsigned char* spb)
		{
			typename Policy::IStatus status2(status);
			IService* ret = static_cast<VTable*>(this->cloopVTable)->attachServiceManager(this, status2, service, spbLength, spb);
			Policy::checkException(status2);
			return ret;
		}

		void shutdown(IStatus* status, unsigned timeout, const int reason)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->shutdown(this, status2, timeout, reason);
			Policy::checkException(status2);
		}

		void setDbCryptCallback(IStatus* status, ICryptKeyCallback* cryptCallback)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->setDbCryptCallback(this, status2, cryptCallback);
			Policy::checkException(status2);
		}
	};

	class IDtcStart : public IDisposable
	{
	public:
		struct VTable : public IDisposable::VTable
		{
			void (CLOOP_CARG *setComponent)(IDtcStart* self, IStatus* status, IAttachment* att) throw();
			void (CLOOP_CARG *setWithParam)(IDtcStart* self, IStatus* status, IAttachment* att, unsigned length, const unsigned char* tpb) throw();
			unsigned (CLOOP_CARG *getCount)(IDtcStart* self, IStatus* status) throw();
			IAttachment* (CLOOP_CARG *getAttachment)(IDtcStart* self, IStatus* status, unsigned pos) throw();
			const unsigned char* (CLOOP_CARG *getTpb)(IDtcStart* self, IStatus* status, unsigned pos, unsigned* length) throw();
		};

	protected:
		IDtcStart(DoNotInherit)
			: IDisposable(DoNotInherit())
		{
		}

		~IDtcStart()
		{
		}

	public:
		static const unsigned VERSION = 3;

		void setComponent(IStatus* status, IAttachment* att)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->setComponent(this, status2, att);
			Policy::checkException(status2);
		}

		void setWithParam(IStatus* status, IAttachment* att, unsigned length, const unsigned char* tpb)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->setWithParam(this, status2, att, length, tpb);
			Policy::checkException(status2);
		}

		unsigned getCount(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getCount(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		IAttachment* getAttachment(IStatus* status, unsigned pos)
		{
			typename Policy::IStatus status2(status);
			IAttachment* ret = static_cast<VTable*>(this->cloopVTable)->getAttachment(this, status2, pos);
			Policy::checkException(status2);
			return ret;
		}

		const unsigned char* getTpb(IStatus* status, unsigned pos, unsigned* length)
		{
			typename Policy::IStatus status2(status);
			const unsigned char* ret = static_cast<VTable*>(this->cloopVTable)->getTpb(this, status2, pos, length);
			Policy::checkException(status2);
			return ret;
		}
	};

	class IDtc : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			ITransaction* (CLOOP_CARG *start)(IDtc* self, IStatus* status, IDtcStart* components) throw();
			ITransaction* (CLOOP_CARG *join)(IDtc* self, IStatus* status, ITransaction* one, ITransaction* two) throw();
			IDtcStart* (CLOOP_CARG *startBuilder)(IDtc* self, IStatus* status) throw();
		};

	protected:
		IDtc(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IDtc()
		{
		}

	public:
		static const unsigned VERSION = 2;

		ITransaction* start(IStatus* status, IDtcStart* components)
		{
			typename Policy::IStatus status2(status);
			ITransaction* ret = static_cast<VTable*>(this->cloopVTable)->start(this, status2, components);
			Policy::checkException(status2);
			return ret;
		}

		ITransaction* join(IStatus* status, ITransaction* one, ITransaction* two)
		{
			typename Policy::IStatus status2(status);
			ITransaction* ret = static_cast<VTable*>(this->cloopVTable)->join(this, status2, one, two);
			Policy::checkException(status2);
			return ret;
		}

		IDtcStart* startBuilder(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			IDtcStart* ret = static_cast<VTable*>(this->cloopVTable)->startBuilder(this, status2);
			Policy::checkException(status2);
			return ret;
		}
	};

	class IAuth : public IPluginBase
	{
	public:
		struct VTable : public IPluginBase::VTable
		{
		};

	protected:
		IAuth(DoNotInherit)
			: IPluginBase(DoNotInherit())
		{
		}

		~IAuth()
		{
		}

	public:
		static const unsigned VERSION = 4;

		static const int AUTH_FAILED = -1;
		static const int AUTH_SUCCESS = 0;
		static const int AUTH_MORE_DATA = 1;
		static const int AUTH_CONTINUE = 2;
	};

	class IWriter : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			void (CLOOP_CARG *reset)(IWriter* self) throw();
			void (CLOOP_CARG *add)(IWriter* self, IStatus* status, const char* name) throw();
			void (CLOOP_CARG *setType)(IWriter* self, IStatus* status, const char* value) throw();
			void (CLOOP_CARG *setDb)(IWriter* self, IStatus* status, const char* value) throw();
		};

	protected:
		IWriter(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IWriter()
		{
		}

	public:
		static const unsigned VERSION = 2;

		void reset()
		{
			static_cast<VTable*>(this->cloopVTable)->reset(this);
		}

		void add(IStatus* status, const char* name)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->add(this, status2, name);
			Policy::checkException(status2);
		}

		void setType(IStatus* status, const char* value)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->setType(this, status2, value);
			Policy::checkException(status2);
		}

		void setDb(IStatus* status, const char* value)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->setDb(this, status2, value);
			Policy::checkException(status2);
		}
	};

	class IServerBlock : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			const char* (CLOOP_CARG *getLogin)(IServerBlock* self) throw();
			const unsigned char* (CLOOP_CARG *getData)(IServerBlock* self, unsigned* length) throw();
			void (CLOOP_CARG *putData)(IServerBlock* self, IStatus* status, unsigned length, const void* data) throw();
			void (CLOOP_CARG *putKey)(IServerBlock* self, IStatus* status, FbCryptKey* cryptKey) throw();
		};

	protected:
		IServerBlock(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IServerBlock()
		{
		}

	public:
		static const unsigned VERSION = 2;

		const char* getLogin()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getLogin(this);
			return ret;
		}

		const unsigned char* getData(unsigned* length)
		{
			const unsigned char* ret = static_cast<VTable*>(this->cloopVTable)->getData(this, length);
			return ret;
		}

		void putData(IStatus* status, unsigned length, const void* data)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->putData(this, status2, length, data);
			Policy::checkException(status2);
		}

		void putKey(IStatus* status, FbCryptKey* cryptKey)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->putKey(this, status2, cryptKey);
			Policy::checkException(status2);
		}
	};

	class IClientBlock : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			const char* (CLOOP_CARG *getLogin)(IClientBlock* self) throw();
			const char* (CLOOP_CARG *getPassword)(IClientBlock* self) throw();
			const unsigned char* (CLOOP_CARG *getData)(IClientBlock* self, unsigned* length) throw();
			void (CLOOP_CARG *putData)(IClientBlock* self, IStatus* status, unsigned length, const void* data) throw();
			void (CLOOP_CARG *putKey)(IClientBlock* self, IStatus* status, FbCryptKey* cryptKey) throw();
		};

	protected:
		IClientBlock(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~IClientBlock()
		{
		}

	public:
		static const unsigned VERSION = 3;

		const char* getLogin()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getLogin(this);
			return ret;
		}

		const char* getPassword()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getPassword(this);
			return ret;
		}

		const unsigned char* getData(unsigned* length)
		{
			const unsigned char* ret = static_cast<VTable*>(this->cloopVTable)->getData(this, length);
			return ret;
		}

		void putData(IStatus* status, unsigned length, const void* data)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->putData(this, status2, length, data);
			Policy::checkException(status2);
		}

		void putKey(IStatus* status, FbCryptKey* cryptKey)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->putKey(this, status2, cryptKey);
			Policy::checkException(status2);
		}
	};

	class IServer : public IAuth
	{
	public:
		struct VTable : public IAuth::VTable
		{
			int (CLOOP_CARG *authenticate)(IServer* self, IStatus* status, IServerBlock* sBlock, IWriter* writerInterface) throw();
		};

	protected:
		IServer(DoNotInherit)
			: IAuth(DoNotInherit())
		{
		}

		~IServer()
		{
		}

	public:
		static const unsigned VERSION = 5;

		int authenticate(IStatus* status, IServerBlock* sBlock, IWriter* writerInterface)
		{
			typename Policy::IStatus status2(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->authenticate(this, status2, sBlock, writerInterface);
			Policy::checkException(status2);
			return ret;
		}
	};

	class IClient : public IAuth
	{
	public:
		struct VTable : public IAuth::VTable
		{
			int (CLOOP_CARG *authenticate)(IClient* self, IStatus* status, IClientBlock* cBlock) throw();
		};

	protected:
		IClient(DoNotInherit)
			: IAuth(DoNotInherit())
		{
		}

		~IClient()
		{
		}

	public:
		static const unsigned VERSION = 5;

		int authenticate(IStatus* status, IClientBlock* cBlock)
		{
			typename Policy::IStatus status2(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->authenticate(this, status2, cBlock);
			Policy::checkException(status2);
			return ret;
		}
	};

	class IUserField : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			int (CLOOP_CARG *entered)(IUserField* self) throw();
			int (CLOOP_CARG *specified)(IUserField* self) throw();
			void (CLOOP_CARG *setEntered)(IUserField* self, IStatus* status, int newValue) throw();
		};

	protected:
		IUserField(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IUserField()
		{
		}

	public:
		static const unsigned VERSION = 2;

		int entered()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->entered(this);
			return ret;
		}

		int specified()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->specified(this);
			return ret;
		}

		void setEntered(IStatus* status, int newValue)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->setEntered(this, status2, newValue);
			Policy::checkException(status2);
		}
	};

	class ICharUserField : public IUserField
	{
	public:
		struct VTable : public IUserField::VTable
		{
			const char* (CLOOP_CARG *get)(ICharUserField* self) throw();
			void (CLOOP_CARG *set)(ICharUserField* self, IStatus* status, const char* newValue) throw();
		};

	protected:
		ICharUserField(DoNotInherit)
			: IUserField(DoNotInherit())
		{
		}

		~ICharUserField()
		{
		}

	public:
		static const unsigned VERSION = 3;

		const char* get()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->get(this);
			return ret;
		}

		void set(IStatus* status, const char* newValue)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->set(this, status2, newValue);
			Policy::checkException(status2);
		}
	};

	class IIntUserField : public IUserField
	{
	public:
		struct VTable : public IUserField::VTable
		{
			int (CLOOP_CARG *get)(IIntUserField* self) throw();
			void (CLOOP_CARG *set)(IIntUserField* self, IStatus* status, int newValue) throw();
		};

	protected:
		IIntUserField(DoNotInherit)
			: IUserField(DoNotInherit())
		{
		}

		~IIntUserField()
		{
		}

	public:
		static const unsigned VERSION = 3;

		int get()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->get(this);
			return ret;
		}

		void set(IStatus* status, int newValue)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->set(this, status2, newValue);
			Policy::checkException(status2);
		}
	};

	class IUser : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			int (CLOOP_CARG *operation)(IUser* self) throw();
			ICharUserField* (CLOOP_CARG *userName)(IUser* self) throw();
			ICharUserField* (CLOOP_CARG *password)(IUser* self) throw();
			ICharUserField* (CLOOP_CARG *firstName)(IUser* self) throw();
			ICharUserField* (CLOOP_CARG *lastName)(IUser* self) throw();
			ICharUserField* (CLOOP_CARG *middleName)(IUser* self) throw();
			ICharUserField* (CLOOP_CARG *comment)(IUser* self) throw();
			ICharUserField* (CLOOP_CARG *attributes)(IUser* self) throw();
			IIntUserField* (CLOOP_CARG *active)(IUser* self) throw();
			IIntUserField* (CLOOP_CARG *admin)(IUser* self) throw();
			void (CLOOP_CARG *clear)(IUser* self, IStatus* status) throw();
		};

	protected:
		IUser(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IUser()
		{
		}

	public:
		static const unsigned VERSION = 2;

		int operation()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->operation(this);
			return ret;
		}

		ICharUserField* userName()
		{
			ICharUserField* ret = static_cast<VTable*>(this->cloopVTable)->userName(this);
			return ret;
		}

		ICharUserField* password()
		{
			ICharUserField* ret = static_cast<VTable*>(this->cloopVTable)->password(this);
			return ret;
		}

		ICharUserField* firstName()
		{
			ICharUserField* ret = static_cast<VTable*>(this->cloopVTable)->firstName(this);
			return ret;
		}

		ICharUserField* lastName()
		{
			ICharUserField* ret = static_cast<VTable*>(this->cloopVTable)->lastName(this);
			return ret;
		}

		ICharUserField* middleName()
		{
			ICharUserField* ret = static_cast<VTable*>(this->cloopVTable)->middleName(this);
			return ret;
		}

		ICharUserField* comment()
		{
			ICharUserField* ret = static_cast<VTable*>(this->cloopVTable)->comment(this);
			return ret;
		}

		ICharUserField* attributes()
		{
			ICharUserField* ret = static_cast<VTable*>(this->cloopVTable)->attributes(this);
			return ret;
		}

		IIntUserField* active()
		{
			IIntUserField* ret = static_cast<VTable*>(this->cloopVTable)->active(this);
			return ret;
		}

		IIntUserField* admin()
		{
			IIntUserField* ret = static_cast<VTable*>(this->cloopVTable)->admin(this);
			return ret;
		}

		void clear(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->clear(this, status2);
			Policy::checkException(status2);
		}
	};

	class IListUsers : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			void (CLOOP_CARG *list)(IListUsers* self, IStatus* status, IUser* user) throw();
		};

	protected:
		IListUsers(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IListUsers()
		{
		}

	public:
		static const unsigned VERSION = 2;

		void list(IStatus* status, IUser* user)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->list(this, status2, user);
			Policy::checkException(status2);
		}
	};

	class ILogonInfo : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			const char* (CLOOP_CARG *name)(ILogonInfo* self) throw();
			const char* (CLOOP_CARG *role)(ILogonInfo* self) throw();
			const char* (CLOOP_CARG *networkProtocol)(ILogonInfo* self) throw();
			const char* (CLOOP_CARG *remoteAddress)(ILogonInfo* self) throw();
			const unsigned char* (CLOOP_CARG *authBlock)(ILogonInfo* self, unsigned* length) throw();
		};

	protected:
		ILogonInfo(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~ILogonInfo()
		{
		}

	public:
		static const unsigned VERSION = 2;

		const char* name()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->name(this);
			return ret;
		}

		const char* role()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->role(this);
			return ret;
		}

		const char* networkProtocol()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->networkProtocol(this);
			return ret;
		}

		const char* remoteAddress()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->remoteAddress(this);
			return ret;
		}

		const unsigned char* authBlock(unsigned* length)
		{
			const unsigned char* ret = static_cast<VTable*>(this->cloopVTable)->authBlock(this, length);
			return ret;
		}
	};

	class IManagement : public IPluginBase
	{
	public:
		struct VTable : public IPluginBase::VTable
		{
			void (CLOOP_CARG *start)(IManagement* self, IStatus* status, ILogonInfo* logonInfo) throw();
			int (CLOOP_CARG *execute)(IManagement* self, IStatus* status, IUser* user, IListUsers* callback) throw();
			void (CLOOP_CARG *commit)(IManagement* self, IStatus* status) throw();
			void (CLOOP_CARG *rollback)(IManagement* self, IStatus* status) throw();
		};

	protected:
		IManagement(DoNotInherit)
			: IPluginBase(DoNotInherit())
		{
		}

		~IManagement()
		{
		}

	public:
		static const unsigned VERSION = 4;

		void start(IStatus* status, ILogonInfo* logonInfo)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->start(this, status2, logonInfo);
			Policy::checkException(status2);
		}

		int execute(IStatus* status, IUser* user, IListUsers* callback)
		{
			typename Policy::IStatus status2(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->execute(this, status2, user, callback);
			Policy::checkException(status2);
			return ret;
		}

		void commit(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->commit(this, status2);
			Policy::checkException(status2);
		}

		void rollback(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->rollback(this, status2);
			Policy::checkException(status2);
		}
	};

	class IWireCryptPlugin : public IPluginBase
	{
	public:
		struct VTable : public IPluginBase::VTable
		{
			const char* (CLOOP_CARG *getKnownTypes)(IWireCryptPlugin* self, IStatus* status) throw();
			void (CLOOP_CARG *setKey)(IWireCryptPlugin* self, IStatus* status, FbCryptKey* key) throw();
			void (CLOOP_CARG *encrypt)(IWireCryptPlugin* self, IStatus* status, unsigned length, const void* from, void* to) throw();
			void (CLOOP_CARG *decrypt)(IWireCryptPlugin* self, IStatus* status, unsigned length, const void* from, void* to) throw();
		};

	protected:
		IWireCryptPlugin(DoNotInherit)
			: IPluginBase(DoNotInherit())
		{
		}

		~IWireCryptPlugin()
		{
		}

	public:
		static const unsigned VERSION = 4;

		const char* getKnownTypes(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getKnownTypes(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		void setKey(IStatus* status, FbCryptKey* key)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->setKey(this, status2, key);
			Policy::checkException(status2);
		}

		void encrypt(IStatus* status, unsigned length, const void* from, void* to)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->encrypt(this, status2, length, from, to);
			Policy::checkException(status2);
		}

		void decrypt(IStatus* status, unsigned length, const void* from, void* to)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->decrypt(this, status2, length, from, to);
			Policy::checkException(status2);
		}
	};

	class ICryptKeyCallback : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			unsigned (CLOOP_CARG *callback)(ICryptKeyCallback* self, unsigned dataLength, const void* data, unsigned bufferLength, void* buffer) throw();
		};

	protected:
		ICryptKeyCallback(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~ICryptKeyCallback()
		{
		}

	public:
		static const unsigned VERSION = 2;

		unsigned callback(unsigned dataLength, const void* data, unsigned bufferLength, void* buffer)
		{
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->callback(this, dataLength, data, bufferLength, buffer);
			return ret;
		}
	};

	class IKeyHolderPlugin : public IPluginBase
	{
	public:
		struct VTable : public IPluginBase::VTable
		{
			int (CLOOP_CARG *keyCallback)(IKeyHolderPlugin* self, IStatus* status, ICryptKeyCallback* callback) throw();
			ICryptKeyCallback* (CLOOP_CARG *keyHandle)(IKeyHolderPlugin* self, IStatus* status, const char* keyName) throw();
		};

	protected:
		IKeyHolderPlugin(DoNotInherit)
			: IPluginBase(DoNotInherit())
		{
		}

		~IKeyHolderPlugin()
		{
		}

	public:
		static const unsigned VERSION = 4;

		int keyCallback(IStatus* status, ICryptKeyCallback* callback)
		{
			typename Policy::IStatus status2(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->keyCallback(this, status2, callback);
			Policy::checkException(status2);
			return ret;
		}

		ICryptKeyCallback* keyHandle(IStatus* status, const char* keyName)
		{
			typename Policy::IStatus status2(status);
			ICryptKeyCallback* ret = static_cast<VTable*>(this->cloopVTable)->keyHandle(this, status2, keyName);
			Policy::checkException(status2);
			return ret;
		}
	};

	class IDbCryptPlugin : public IPluginBase
	{
	public:
		struct VTable : public IPluginBase::VTable
		{
			void (CLOOP_CARG *setKey)(IDbCryptPlugin* self, IStatus* status, unsigned length, IKeyHolderPlugin** sources) throw();
			void (CLOOP_CARG *encrypt)(IDbCryptPlugin* self, IStatus* status, unsigned length, const void* from, void* to) throw();
			void (CLOOP_CARG *decrypt)(IDbCryptPlugin* self, IStatus* status, unsigned length, const void* from, void* to) throw();
		};

	protected:
		IDbCryptPlugin(DoNotInherit)
			: IPluginBase(DoNotInherit())
		{
		}

		~IDbCryptPlugin()
		{
		}

	public:
		static const unsigned VERSION = 4;

		void setKey(IStatus* status, unsigned length, IKeyHolderPlugin** sources)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->setKey(this, status2, length, sources);
			Policy::checkException(status2);
		}

		void encrypt(IStatus* status, unsigned length, const void* from, void* to)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->encrypt(this, status2, length, from, to);
			Policy::checkException(status2);
		}

		void decrypt(IStatus* status, unsigned length, const void* from, void* to)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->decrypt(this, status2, length, from, to);
			Policy::checkException(status2);
		}
	};

	class IExternalContext : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			IMaster* (CLOOP_CARG *getMaster)(IExternalContext* self) throw();
			IExternalEngine* (CLOOP_CARG *getEngine)(IExternalContext* self, IStatus* status) throw();
			IAttachment* (CLOOP_CARG *getAttachment)(IExternalContext* self, IStatus* status) throw();
			ITransaction* (CLOOP_CARG *getTransaction)(IExternalContext* self, IStatus* status) throw();
			const char* (CLOOP_CARG *getUserName)(IExternalContext* self) throw();
			const char* (CLOOP_CARG *getDatabaseName)(IExternalContext* self) throw();
			const char* (CLOOP_CARG *getClientCharSet)(IExternalContext* self) throw();
			int (CLOOP_CARG *obtainInfoCode)(IExternalContext* self) throw();
			void* (CLOOP_CARG *getInfo)(IExternalContext* self, int code) throw();
			void* (CLOOP_CARG *setInfo)(IExternalContext* self, int code, void* value) throw();
		};

	protected:
		IExternalContext(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IExternalContext()
		{
		}

	public:
		static const unsigned VERSION = 2;

		IMaster* getMaster()
		{
			IMaster* ret = static_cast<VTable*>(this->cloopVTable)->getMaster(this);
			return ret;
		}

		IExternalEngine* getEngine(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			IExternalEngine* ret = static_cast<VTable*>(this->cloopVTable)->getEngine(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		IAttachment* getAttachment(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			IAttachment* ret = static_cast<VTable*>(this->cloopVTable)->getAttachment(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		ITransaction* getTransaction(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			ITransaction* ret = static_cast<VTable*>(this->cloopVTable)->getTransaction(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		const char* getUserName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getUserName(this);
			return ret;
		}

		const char* getDatabaseName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getDatabaseName(this);
			return ret;
		}

		const char* getClientCharSet()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getClientCharSet(this);
			return ret;
		}

		int obtainInfoCode()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->obtainInfoCode(this);
			return ret;
		}

		void* getInfo(int code)
		{
			void* ret = static_cast<VTable*>(this->cloopVTable)->getInfo(this, code);
			return ret;
		}

		void* setInfo(int code, void* value)
		{
			void* ret = static_cast<VTable*>(this->cloopVTable)->setInfo(this, code, value);
			return ret;
		}
	};

	class IExternalResultSet : public IDisposable
	{
	public:
		struct VTable : public IDisposable::VTable
		{
			FB_BOOLEAN (CLOOP_CARG *fetch)(IExternalResultSet* self, IStatus* status) throw();
		};

	protected:
		IExternalResultSet(DoNotInherit)
			: IDisposable(DoNotInherit())
		{
		}

		~IExternalResultSet()
		{
		}

	public:
		static const unsigned VERSION = 3;

		FB_BOOLEAN fetch(IStatus* status)
		{
			typename Policy::IStatus status2(status);
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->fetch(this, status2);
			Policy::checkException(status2);
			return ret;
		}
	};

	class IExternalFunction : public IDisposable
	{
	public:
		struct VTable : public IDisposable::VTable
		{
			void (CLOOP_CARG *getCharSet)(IExternalFunction* self, IStatus* status, IExternalContext* context, char* name, unsigned nameSize) throw();
			void (CLOOP_CARG *execute)(IExternalFunction* self, IStatus* status, IExternalContext* context, void* inMsg, void* outMsg) throw();
		};

	protected:
		IExternalFunction(DoNotInherit)
			: IDisposable(DoNotInherit())
		{
		}

		~IExternalFunction()
		{
		}

	public:
		static const unsigned VERSION = 3;

		void getCharSet(IStatus* status, IExternalContext* context, char* name, unsigned nameSize)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->getCharSet(this, status2, context, name, nameSize);
			Policy::checkException(status2);
		}

		void execute(IStatus* status, IExternalContext* context, void* inMsg, void* outMsg)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->execute(this, status2, context, inMsg, outMsg);
			Policy::checkException(status2);
		}
	};

	class IExternalProcedure : public IDisposable
	{
	public:
		struct VTable : public IDisposable::VTable
		{
			void (CLOOP_CARG *getCharSet)(IExternalProcedure* self, IStatus* status, IExternalContext* context, char* name, unsigned nameSize) throw();
			IExternalResultSet* (CLOOP_CARG *open)(IExternalProcedure* self, IStatus* status, IExternalContext* context, void* inMsg, void* outMsg) throw();
		};

	protected:
		IExternalProcedure(DoNotInherit)
			: IDisposable(DoNotInherit())
		{
		}

		~IExternalProcedure()
		{
		}

	public:
		static const unsigned VERSION = 3;

		void getCharSet(IStatus* status, IExternalContext* context, char* name, unsigned nameSize)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->getCharSet(this, status2, context, name, nameSize);
			Policy::checkException(status2);
		}

		IExternalResultSet* open(IStatus* status, IExternalContext* context, void* inMsg, void* outMsg)
		{
			typename Policy::IStatus status2(status);
			IExternalResultSet* ret = static_cast<VTable*>(this->cloopVTable)->open(this, status2, context, inMsg, outMsg);
			Policy::checkException(status2);
			return ret;
		}
	};

	class IExternalTrigger : public IDisposable
	{
	public:
		struct VTable : public IDisposable::VTable
		{
			void (CLOOP_CARG *getCharSet)(IExternalTrigger* self, IStatus* status, IExternalContext* context, char* name, unsigned nameSize) throw();
			void (CLOOP_CARG *execute)(IExternalTrigger* self, IStatus* status, IExternalContext* context, unsigned action, void* oldMsg, void* newMsg) throw();
		};

	protected:
		IExternalTrigger(DoNotInherit)
			: IDisposable(DoNotInherit())
		{
		}

		~IExternalTrigger()
		{
		}

	public:
		static const unsigned VERSION = 3;

		static const unsigned TYPE_BEFORE = 1;
		static const unsigned TYPE_AFTER = 2;
		static const unsigned TYPE_DATABASE = 3;
		static const unsigned ACTION_INSERT = 1;
		static const unsigned ACTION_UPDATE = 2;
		static const unsigned ACTION_DELETE = 3;
		static const unsigned ACTION_CONNECT = 4;
		static const unsigned ACTION_DISCONNECT = 5;
		static const unsigned ACTION_TRANS_START = 6;
		static const unsigned ACTION_TRANS_COMMIT = 7;
		static const unsigned ACTION_TRANS_ROLLBACK = 8;
		static const unsigned ACTION_DDL = 9;

		void getCharSet(IStatus* status, IExternalContext* context, char* name, unsigned nameSize)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->getCharSet(this, status2, context, name, nameSize);
			Policy::checkException(status2);
		}

		void execute(IStatus* status, IExternalContext* context, unsigned action, void* oldMsg, void* newMsg)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->execute(this, status2, context, action, oldMsg, newMsg);
			Policy::checkException(status2);
		}
	};

	class IRoutineMetadata : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			const char* (CLOOP_CARG *getPackage)(const IRoutineMetadata* self, IStatus* status) throw();
			const char* (CLOOP_CARG *getName)(const IRoutineMetadata* self, IStatus* status) throw();
			const char* (CLOOP_CARG *getEntryPoint)(const IRoutineMetadata* self, IStatus* status) throw();
			const char* (CLOOP_CARG *getBody)(const IRoutineMetadata* self, IStatus* status) throw();
			IMessageMetadata* (CLOOP_CARG *getInputMetadata)(const IRoutineMetadata* self, IStatus* status) throw();
			IMessageMetadata* (CLOOP_CARG *getOutputMetadata)(const IRoutineMetadata* self, IStatus* status) throw();
			IMessageMetadata* (CLOOP_CARG *getTriggerMetadata)(const IRoutineMetadata* self, IStatus* status) throw();
			const char* (CLOOP_CARG *getTriggerTable)(const IRoutineMetadata* self, IStatus* status) throw();
			unsigned (CLOOP_CARG *getTriggerType)(const IRoutineMetadata* self, IStatus* status) throw();
		};

	protected:
		IRoutineMetadata(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IRoutineMetadata()
		{
		}

	public:
		static const unsigned VERSION = 2;

		const char* getPackage(IStatus* status) const
		{
			typename Policy::IStatus status2(status);
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getPackage(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		const char* getName(IStatus* status) const
		{
			typename Policy::IStatus status2(status);
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getName(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		const char* getEntryPoint(IStatus* status) const
		{
			typename Policy::IStatus status2(status);
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getEntryPoint(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		const char* getBody(IStatus* status) const
		{
			typename Policy::IStatus status2(status);
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getBody(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		IMessageMetadata* getInputMetadata(IStatus* status) const
		{
			typename Policy::IStatus status2(status);
			IMessageMetadata* ret = static_cast<VTable*>(this->cloopVTable)->getInputMetadata(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		IMessageMetadata* getOutputMetadata(IStatus* status) const
		{
			typename Policy::IStatus status2(status);
			IMessageMetadata* ret = static_cast<VTable*>(this->cloopVTable)->getOutputMetadata(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		IMessageMetadata* getTriggerMetadata(IStatus* status) const
		{
			typename Policy::IStatus status2(status);
			IMessageMetadata* ret = static_cast<VTable*>(this->cloopVTable)->getTriggerMetadata(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		const char* getTriggerTable(IStatus* status) const
		{
			typename Policy::IStatus status2(status);
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getTriggerTable(this, status2);
			Policy::checkException(status2);
			return ret;
		}

		unsigned getTriggerType(IStatus* status) const
		{
			typename Policy::IStatus status2(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getTriggerType(this, status2);
			Policy::checkException(status2);
			return ret;
		}
	};

	class IExternalEngine : public IPluginBase
	{
	public:
		struct VTable : public IPluginBase::VTable
		{
			void (CLOOP_CARG *open)(IExternalEngine* self, IStatus* status, IExternalContext* context, char* charSet, unsigned charSetSize) throw();
			void (CLOOP_CARG *openAttachment)(IExternalEngine* self, IStatus* status, IExternalContext* context) throw();
			void (CLOOP_CARG *closeAttachment)(IExternalEngine* self, IStatus* status, IExternalContext* context) throw();
			IExternalFunction* (CLOOP_CARG *makeFunction)(IExternalEngine* self, IStatus* status, IExternalContext* context, IRoutineMetadata* metadata, IMetadataBuilder* inBuilder, IMetadataBuilder* outBuilder) throw();
			IExternalProcedure* (CLOOP_CARG *makeProcedure)(IExternalEngine* self, IStatus* status, IExternalContext* context, IRoutineMetadata* metadata, IMetadataBuilder* inBuilder, IMetadataBuilder* outBuilder) throw();
			IExternalTrigger* (CLOOP_CARG *makeTrigger)(IExternalEngine* self, IStatus* status, IExternalContext* context, IRoutineMetadata* metadata, IMetadataBuilder* fieldsBuilder) throw();
		};

	protected:
		IExternalEngine(DoNotInherit)
			: IPluginBase(DoNotInherit())
		{
		}

		~IExternalEngine()
		{
		}

	public:
		static const unsigned VERSION = 4;

		void open(IStatus* status, IExternalContext* context, char* charSet, unsigned charSetSize)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->open(this, status2, context, charSet, charSetSize);
			Policy::checkException(status2);
		}

		void openAttachment(IStatus* status, IExternalContext* context)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->openAttachment(this, status2, context);
			Policy::checkException(status2);
		}

		void closeAttachment(IStatus* status, IExternalContext* context)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->closeAttachment(this, status2, context);
			Policy::checkException(status2);
		}

		IExternalFunction* makeFunction(IStatus* status, IExternalContext* context, IRoutineMetadata* metadata, IMetadataBuilder* inBuilder, IMetadataBuilder* outBuilder)
		{
			typename Policy::IStatus status2(status);
			IExternalFunction* ret = static_cast<VTable*>(this->cloopVTable)->makeFunction(this, status2, context, metadata, inBuilder, outBuilder);
			Policy::checkException(status2);
			return ret;
		}

		IExternalProcedure* makeProcedure(IStatus* status, IExternalContext* context, IRoutineMetadata* metadata, IMetadataBuilder* inBuilder, IMetadataBuilder* outBuilder)
		{
			typename Policy::IStatus status2(status);
			IExternalProcedure* ret = static_cast<VTable*>(this->cloopVTable)->makeProcedure(this, status2, context, metadata, inBuilder, outBuilder);
			Policy::checkException(status2);
			return ret;
		}

		IExternalTrigger* makeTrigger(IStatus* status, IExternalContext* context, IRoutineMetadata* metadata, IMetadataBuilder* fieldsBuilder)
		{
			typename Policy::IStatus status2(status);
			IExternalTrigger* ret = static_cast<VTable*>(this->cloopVTable)->makeTrigger(this, status2, context, metadata, fieldsBuilder);
			Policy::checkException(status2);
			return ret;
		}
	};

	class ITimer : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			void (CLOOP_CARG *handler)(ITimer* self) throw();
		};

	protected:
		ITimer(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~ITimer()
		{
		}

	public:
		static const unsigned VERSION = 3;

		void handler()
		{
			static_cast<VTable*>(this->cloopVTable)->handler(this);
		}
	};

	class ITimerControl : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			void (CLOOP_CARG *start)(ITimerControl* self, IStatus* status, ITimer* timer, ISC_UINT64 microSeconds) throw();
			void (CLOOP_CARG *stop)(ITimerControl* self, IStatus* status, ITimer* timer) throw();
		};

	protected:
		ITimerControl(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~ITimerControl()
		{
		}

	public:
		static const unsigned VERSION = 2;

		void start(IStatus* status, ITimer* timer, ISC_UINT64 microSeconds)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->start(this, status2, timer, microSeconds);
			Policy::checkException(status2);
		}

		void stop(IStatus* status, ITimer* timer)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->stop(this, status2, timer);
			Policy::checkException(status2);
		}
	};

	class IVersionCallback : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			void (CLOOP_CARG *callback)(IVersionCallback* self, IStatus* status, const char* text) throw();
		};

	protected:
		IVersionCallback(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IVersionCallback()
		{
		}

	public:
		static const unsigned VERSION = 2;

		void callback(IStatus* status, const char* text)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->callback(this, status2, text);
			Policy::checkException(status2);
		}
	};

	class IUtl : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			void (CLOOP_CARG *getFbVersion)(IUtl* self, IStatus* status, IAttachment* att, IVersionCallback* callback) throw();
			void (CLOOP_CARG *loadBlob)(IUtl* self, IStatus* status, ISC_QUAD* blobId, IAttachment* att, ITransaction* tra, const char* file, FB_BOOLEAN txt) throw();
			void (CLOOP_CARG *dumpBlob)(IUtl* self, IStatus* status, ISC_QUAD* blobId, IAttachment* att, ITransaction* tra, const char* file, FB_BOOLEAN txt) throw();
			void (CLOOP_CARG *getPerfCounters)(IUtl* self, IStatus* status, IAttachment* att, const char* countersSet, ISC_INT64* counters) throw();
			IAttachment* (CLOOP_CARG *executeCreateDatabase)(IUtl* self, IStatus* status, unsigned stmtLength, const char* creatDBstatement, unsigned dialect, FB_BOOLEAN* stmtIsCreateDb) throw();
		};

	protected:
		IUtl(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IUtl()
		{
		}

	public:
		static const unsigned VERSION = 2;

		void getFbVersion(IStatus* status, IAttachment* att, IVersionCallback* callback)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->getFbVersion(this, status2, att, callback);
			Policy::checkException(status2);
		}

		void loadBlob(IStatus* status, ISC_QUAD* blobId, IAttachment* att, ITransaction* tra, const char* file, FB_BOOLEAN txt)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->loadBlob(this, status2, blobId, att, tra, file, txt);
			Policy::checkException(status2);
		}

		void dumpBlob(IStatus* status, ISC_QUAD* blobId, IAttachment* att, ITransaction* tra, const char* file, FB_BOOLEAN txt)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->dumpBlob(this, status2, blobId, att, tra, file, txt);
			Policy::checkException(status2);
		}

		void getPerfCounters(IStatus* status, IAttachment* att, const char* countersSet, ISC_INT64* counters)
		{
			typename Policy::IStatus status2(status);
			static_cast<VTable*>(this->cloopVTable)->getPerfCounters(this, status2, att, countersSet, counters);
			Policy::checkException(status2);
		}

		IAttachment* executeCreateDatabase(IStatus* status, unsigned stmtLength, const char* creatDBstatement, unsigned dialect, FB_BOOLEAN* stmtIsCreateDb)
		{
			typename Policy::IStatus status2(status);
			IAttachment* ret = static_cast<VTable*>(this->cloopVTable)->executeCreateDatabase(this, status2, stmtLength, creatDBstatement, dialect, stmtIsCreateDb);
			Policy::checkException(status2);
			return ret;
		}
	};

	class ITraceConnection : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			unsigned (CLOOP_CARG *getKind)(ITraceConnection* self) throw();
			int (CLOOP_CARG *getProcessID)(ITraceConnection* self) throw();
			const char* (CLOOP_CARG *getUserName)(ITraceConnection* self) throw();
			const char* (CLOOP_CARG *getRoleName)(ITraceConnection* self) throw();
			const char* (CLOOP_CARG *getCharSet)(ITraceConnection* self) throw();
			const char* (CLOOP_CARG *getRemoteProtocol)(ITraceConnection* self) throw();
			const char* (CLOOP_CARG *getRemoteAddress)(ITraceConnection* self) throw();
			int (CLOOP_CARG *getRemoteProcessID)(ITraceConnection* self) throw();
			const char* (CLOOP_CARG *getRemoteProcessName)(ITraceConnection* self) throw();
		};

	protected:
		ITraceConnection(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~ITraceConnection()
		{
		}

	public:
		static const unsigned VERSION = 2;

		static const unsigned TRACE_CONNECTION_DATABASE = 1;
		static const unsigned TRACE_CONNECTION_SERVICE = 2;

		unsigned getKind()
		{
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getKind(this);
			return ret;
		}

		int getProcessID()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->getProcessID(this);
			return ret;
		}

		const char* getUserName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getUserName(this);
			return ret;
		}

		const char* getRoleName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getRoleName(this);
			return ret;
		}

		const char* getCharSet()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getCharSet(this);
			return ret;
		}

		const char* getRemoteProtocol()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getRemoteProtocol(this);
			return ret;
		}

		const char* getRemoteAddress()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getRemoteAddress(this);
			return ret;
		}

		int getRemoteProcessID()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->getRemoteProcessID(this);
			return ret;
		}

		const char* getRemoteProcessName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getRemoteProcessName(this);
			return ret;
		}
	};

	class ITraceDatabaseConnection : public ITraceConnection
	{
	public:
		struct VTable : public ITraceConnection::VTable
		{
			int (CLOOP_CARG *getConnectionID)(ITraceDatabaseConnection* self) throw();
			const char* (CLOOP_CARG *getDatabaseName)(ITraceDatabaseConnection* self) throw();
		};

	protected:
		ITraceDatabaseConnection(DoNotInherit)
			: ITraceConnection(DoNotInherit())
		{
		}

		~ITraceDatabaseConnection()
		{
		}

	public:
		static const unsigned VERSION = 3;

		int getConnectionID()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->getConnectionID(this);
			return ret;
		}

		const char* getDatabaseName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getDatabaseName(this);
			return ret;
		}
	};

	class ITraceTransaction : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			unsigned (CLOOP_CARG *getTransactionID)(ITraceTransaction* self) throw();
			FB_BOOLEAN (CLOOP_CARG *getReadOnly)(ITraceTransaction* self) throw();
			int (CLOOP_CARG *getWait)(ITraceTransaction* self) throw();
			unsigned (CLOOP_CARG *getIsolation)(ITraceTransaction* self) throw();
			PerformanceInfo* (CLOOP_CARG *getPerf)(ITraceTransaction* self) throw();
		};

	protected:
		ITraceTransaction(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~ITraceTransaction()
		{
		}

	public:
		static const unsigned VERSION = 2;

		static const unsigned TRA_ISO_CONSISTENCY = 1;
		static const unsigned TRA_ISO_CONCURRENCY = 2;
		static const unsigned TRA_ISO_READ_COMMITTED_RECVER = 3;
		static const unsigned TRA_ISO_READ_COMMITTED_NORECVER = 4;

		unsigned getTransactionID()
		{
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getTransactionID(this);
			return ret;
		}

		FB_BOOLEAN getReadOnly()
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->getReadOnly(this);
			return ret;
		}

		int getWait()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->getWait(this);
			return ret;
		}

		unsigned getIsolation()
		{
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getIsolation(this);
			return ret;
		}

		PerformanceInfo* getPerf()
		{
			PerformanceInfo* ret = static_cast<VTable*>(this->cloopVTable)->getPerf(this);
			return ret;
		}
	};

	class ITraceParams : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			unsigned (CLOOP_CARG *getCount)(ITraceParams* self) throw();
			const dsc* (CLOOP_CARG *getParam)(ITraceParams* self, unsigned idx) throw();
		};

	protected:
		ITraceParams(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~ITraceParams()
		{
		}

	public:
		static const unsigned VERSION = 2;

		unsigned getCount()
		{
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getCount(this);
			return ret;
		}

		const dsc* getParam(unsigned idx)
		{
			const dsc* ret = static_cast<VTable*>(this->cloopVTable)->getParam(this, idx);
			return ret;
		}
	};

	class ITraceStatement : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			int (CLOOP_CARG *getStmtID)(ITraceStatement* self) throw();
			PerformanceInfo* (CLOOP_CARG *getPerf)(ITraceStatement* self) throw();
		};

	protected:
		ITraceStatement(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~ITraceStatement()
		{
		}

	public:
		static const unsigned VERSION = 2;

		int getStmtID()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->getStmtID(this);
			return ret;
		}

		PerformanceInfo* getPerf()
		{
			PerformanceInfo* ret = static_cast<VTable*>(this->cloopVTable)->getPerf(this);
			return ret;
		}
	};

	class ITraceSQLStatement : public ITraceStatement
	{
	public:
		struct VTable : public ITraceStatement::VTable
		{
			const char* (CLOOP_CARG *getText)(ITraceSQLStatement* self) throw();
			const char* (CLOOP_CARG *getPlan)(ITraceSQLStatement* self) throw();
			ITraceParams* (CLOOP_CARG *getInputs)(ITraceSQLStatement* self) throw();
			const char* (CLOOP_CARG *getTextUTF8)(ITraceSQLStatement* self) throw();
			const char* (CLOOP_CARG *getExplainedPlan)(ITraceSQLStatement* self) throw();
		};

	protected:
		ITraceSQLStatement(DoNotInherit)
			: ITraceStatement(DoNotInherit())
		{
		}

		~ITraceSQLStatement()
		{
		}

	public:
		static const unsigned VERSION = 3;

		const char* getText()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getText(this);
			return ret;
		}

		const char* getPlan()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getPlan(this);
			return ret;
		}

		ITraceParams* getInputs()
		{
			ITraceParams* ret = static_cast<VTable*>(this->cloopVTable)->getInputs(this);
			return ret;
		}

		const char* getTextUTF8()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getTextUTF8(this);
			return ret;
		}

		const char* getExplainedPlan()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getExplainedPlan(this);
			return ret;
		}
	};

	class ITraceBLRStatement : public ITraceStatement
	{
	public:
		struct VTable : public ITraceStatement::VTable
		{
			const unsigned char* (CLOOP_CARG *getData)(ITraceBLRStatement* self) throw();
			unsigned (CLOOP_CARG *getDataLength)(ITraceBLRStatement* self) throw();
			const char* (CLOOP_CARG *getText)(ITraceBLRStatement* self) throw();
		};

	protected:
		ITraceBLRStatement(DoNotInherit)
			: ITraceStatement(DoNotInherit())
		{
		}

		~ITraceBLRStatement()
		{
		}

	public:
		static const unsigned VERSION = 3;

		const unsigned char* getData()
		{
			const unsigned char* ret = static_cast<VTable*>(this->cloopVTable)->getData(this);
			return ret;
		}

		unsigned getDataLength()
		{
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getDataLength(this);
			return ret;
		}

		const char* getText()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getText(this);
			return ret;
		}
	};

	class ITraceDYNRequest : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			const unsigned char* (CLOOP_CARG *getData)(ITraceDYNRequest* self) throw();
			unsigned (CLOOP_CARG *getDataLength)(ITraceDYNRequest* self) throw();
			const char* (CLOOP_CARG *getText)(ITraceDYNRequest* self) throw();
		};

	protected:
		ITraceDYNRequest(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~ITraceDYNRequest()
		{
		}

	public:
		static const unsigned VERSION = 2;

		const unsigned char* getData()
		{
			const unsigned char* ret = static_cast<VTable*>(this->cloopVTable)->getData(this);
			return ret;
		}

		unsigned getDataLength()
		{
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getDataLength(this);
			return ret;
		}

		const char* getText()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getText(this);
			return ret;
		}
	};

	class ITraceContextVariable : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			const char* (CLOOP_CARG *getNameSpace)(ITraceContextVariable* self) throw();
			const char* (CLOOP_CARG *getVarName)(ITraceContextVariable* self) throw();
			const char* (CLOOP_CARG *getVarValue)(ITraceContextVariable* self) throw();
		};

	protected:
		ITraceContextVariable(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~ITraceContextVariable()
		{
		}

	public:
		static const unsigned VERSION = 2;

		const char* getNameSpace()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getNameSpace(this);
			return ret;
		}

		const char* getVarName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getVarName(this);
			return ret;
		}

		const char* getVarValue()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getVarValue(this);
			return ret;
		}
	};

	class ITraceProcedure : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			const char* (CLOOP_CARG *getProcName)(ITraceProcedure* self) throw();
			ITraceParams* (CLOOP_CARG *getInputs)(ITraceProcedure* self) throw();
			PerformanceInfo* (CLOOP_CARG *getPerf)(ITraceProcedure* self) throw();
		};

	protected:
		ITraceProcedure(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~ITraceProcedure()
		{
		}

	public:
		static const unsigned VERSION = 2;

		const char* getProcName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getProcName(this);
			return ret;
		}

		ITraceParams* getInputs()
		{
			ITraceParams* ret = static_cast<VTable*>(this->cloopVTable)->getInputs(this);
			return ret;
		}

		PerformanceInfo* getPerf()
		{
			PerformanceInfo* ret = static_cast<VTable*>(this->cloopVTable)->getPerf(this);
			return ret;
		}
	};

	class ITraceFunction : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			const char* (CLOOP_CARG *getFuncName)(ITraceFunction* self) throw();
			ITraceParams* (CLOOP_CARG *getInputs)(ITraceFunction* self) throw();
			ITraceParams* (CLOOP_CARG *getResult)(ITraceFunction* self) throw();
			PerformanceInfo* (CLOOP_CARG *getPerf)(ITraceFunction* self) throw();
		};

	protected:
		ITraceFunction(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~ITraceFunction()
		{
		}

	public:
		static const unsigned VERSION = 2;

		const char* getFuncName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getFuncName(this);
			return ret;
		}

		ITraceParams* getInputs()
		{
			ITraceParams* ret = static_cast<VTable*>(this->cloopVTable)->getInputs(this);
			return ret;
		}

		ITraceParams* getResult()
		{
			ITraceParams* ret = static_cast<VTable*>(this->cloopVTable)->getResult(this);
			return ret;
		}

		PerformanceInfo* getPerf()
		{
			PerformanceInfo* ret = static_cast<VTable*>(this->cloopVTable)->getPerf(this);
			return ret;
		}
	};

	class ITraceTrigger : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			const char* (CLOOP_CARG *getTriggerName)(ITraceTrigger* self) throw();
			const char* (CLOOP_CARG *getRelationName)(ITraceTrigger* self) throw();
			int (CLOOP_CARG *getAction)(ITraceTrigger* self) throw();
			int (CLOOP_CARG *getWhich)(ITraceTrigger* self) throw();
			PerformanceInfo* (CLOOP_CARG *getPerf)(ITraceTrigger* self) throw();
		};

	protected:
		ITraceTrigger(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~ITraceTrigger()
		{
		}

	public:
		static const unsigned VERSION = 2;

		static const unsigned TRACE_ALL = 0;
		static const unsigned TRACE_BEFORE = 1;
		static const unsigned TRACE_AFTER = 2;

		const char* getTriggerName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getTriggerName(this);
			return ret;
		}

		const char* getRelationName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getRelationName(this);
			return ret;
		}

		int getAction()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->getAction(this);
			return ret;
		}

		int getWhich()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->getWhich(this);
			return ret;
		}

		PerformanceInfo* getPerf()
		{
			PerformanceInfo* ret = static_cast<VTable*>(this->cloopVTable)->getPerf(this);
			return ret;
		}
	};

	class ITraceServiceConnection : public ITraceConnection
	{
	public:
		struct VTable : public ITraceConnection::VTable
		{
			void* (CLOOP_CARG *getServiceID)(ITraceServiceConnection* self) throw();
			const char* (CLOOP_CARG *getServiceMgr)(ITraceServiceConnection* self) throw();
			const char* (CLOOP_CARG *getServiceName)(ITraceServiceConnection* self) throw();
		};

	protected:
		ITraceServiceConnection(DoNotInherit)
			: ITraceConnection(DoNotInherit())
		{
		}

		~ITraceServiceConnection()
		{
		}

	public:
		static const unsigned VERSION = 3;

		void* getServiceID()
		{
			void* ret = static_cast<VTable*>(this->cloopVTable)->getServiceID(this);
			return ret;
		}

		const char* getServiceMgr()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getServiceMgr(this);
			return ret;
		}

		const char* getServiceName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getServiceName(this);
			return ret;
		}
	};

	class ITraceStatusVector : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			FB_BOOLEAN (CLOOP_CARG *hasError)(ITraceStatusVector* self) throw();
			FB_BOOLEAN (CLOOP_CARG *hasWarning)(ITraceStatusVector* self) throw();
			const intptr_t* (CLOOP_CARG *getStatus)(ITraceStatusVector* self) throw();
			const char* (CLOOP_CARG *getText)(ITraceStatusVector* self) throw();
		};

	protected:
		ITraceStatusVector(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~ITraceStatusVector()
		{
		}

	public:
		static const unsigned VERSION = 2;

		FB_BOOLEAN hasError()
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->hasError(this);
			return ret;
		}

		FB_BOOLEAN hasWarning()
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->hasWarning(this);
			return ret;
		}

		const intptr_t* getStatus()
		{
			const intptr_t* ret = static_cast<VTable*>(this->cloopVTable)->getStatus(this);
			return ret;
		}

		const char* getText()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getText(this);
			return ret;
		}
	};

	class ITraceSweepInfo : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			ISC_UINT64 (CLOOP_CARG *getOIT)(ITraceSweepInfo* self) throw();
			ISC_UINT64 (CLOOP_CARG *getOST)(ITraceSweepInfo* self) throw();
			ISC_UINT64 (CLOOP_CARG *getOAT)(ITraceSweepInfo* self) throw();
			ISC_UINT64 (CLOOP_CARG *getNext)(ITraceSweepInfo* self) throw();
			PerformanceInfo* (CLOOP_CARG *getPerf)(ITraceSweepInfo* self) throw();
		};

	protected:
		ITraceSweepInfo(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~ITraceSweepInfo()
		{
		}

	public:
		static const unsigned VERSION = 2;

		ISC_UINT64 getOIT()
		{
			ISC_UINT64 ret = static_cast<VTable*>(this->cloopVTable)->getOIT(this);
			return ret;
		}

		ISC_UINT64 getOST()
		{
			ISC_UINT64 ret = static_cast<VTable*>(this->cloopVTable)->getOST(this);
			return ret;
		}

		ISC_UINT64 getOAT()
		{
			ISC_UINT64 ret = static_cast<VTable*>(this->cloopVTable)->getOAT(this);
			return ret;
		}

		ISC_UINT64 getNext()
		{
			ISC_UINT64 ret = static_cast<VTable*>(this->cloopVTable)->getNext(this);
			return ret;
		}

		PerformanceInfo* getPerf()
		{
			PerformanceInfo* ret = static_cast<VTable*>(this->cloopVTable)->getPerf(this);
			return ret;
		}
	};

	class ITraceLogWriter : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			unsigned (CLOOP_CARG *write)(ITraceLogWriter* self, const void* buf, unsigned size) throw();
		};

	protected:
		ITraceLogWriter(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~ITraceLogWriter()
		{
		}

	public:
		static const unsigned VERSION = 3;

		unsigned write(const void* buf, unsigned size)
		{
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->write(this, buf, size);
			return ret;
		}
	};

	class ITraceInitInfo : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			const char* (CLOOP_CARG *getConfigText)(ITraceInitInfo* self) throw();
			int (CLOOP_CARG *getTraceSessionID)(ITraceInitInfo* self) throw();
			const char* (CLOOP_CARG *getTraceSessionName)(ITraceInitInfo* self) throw();
			const char* (CLOOP_CARG *getFirebirdRootDirectory)(ITraceInitInfo* self) throw();
			const char* (CLOOP_CARG *getDatabaseName)(ITraceInitInfo* self) throw();
			ITraceDatabaseConnection* (CLOOP_CARG *getConnection)(ITraceInitInfo* self) throw();
			ITraceLogWriter* (CLOOP_CARG *getLogWriter)(ITraceInitInfo* self) throw();
		};

	protected:
		ITraceInitInfo(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~ITraceInitInfo()
		{
		}

	public:
		static const unsigned VERSION = 2;

		const char* getConfigText()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getConfigText(this);
			return ret;
		}

		int getTraceSessionID()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->getTraceSessionID(this);
			return ret;
		}

		const char* getTraceSessionName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getTraceSessionName(this);
			return ret;
		}

		const char* getFirebirdRootDirectory()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getFirebirdRootDirectory(this);
			return ret;
		}

		const char* getDatabaseName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getDatabaseName(this);
			return ret;
		}

		ITraceDatabaseConnection* getConnection()
		{
			ITraceDatabaseConnection* ret = static_cast<VTable*>(this->cloopVTable)->getConnection(this);
			return ret;
		}

		ITraceLogWriter* getLogWriter()
		{
			ITraceLogWriter* ret = static_cast<VTable*>(this->cloopVTable)->getLogWriter(this);
			return ret;
		}
	};

	class ITracePlugin : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			const char* (CLOOP_CARG *trace_get_error)(ITracePlugin* self) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_attach)(ITracePlugin* self, ITraceDatabaseConnection* connection, FB_BOOLEAN create_db, unsigned att_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_detach)(ITracePlugin* self, ITraceDatabaseConnection* connection, FB_BOOLEAN drop_db) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_transaction_start)(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, unsigned tpb_length, const unsigned char* tpb, unsigned tra_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_transaction_end)(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, FB_BOOLEAN commit, FB_BOOLEAN retain_context, unsigned tra_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_proc_execute)(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceProcedure* procedure, FB_BOOLEAN started, unsigned proc_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_trigger_execute)(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceTrigger* trigger, FB_BOOLEAN started, unsigned trig_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_set_context)(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceContextVariable* variable) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_dsql_prepare)(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceSQLStatement* statement, ISC_INT64 time_millis, unsigned req_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_dsql_free)(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceSQLStatement* statement, unsigned option) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_dsql_execute)(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceSQLStatement* statement, FB_BOOLEAN started, unsigned req_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_blr_compile)(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceBLRStatement* statement, ISC_INT64 time_millis, unsigned req_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_blr_execute)(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceBLRStatement* statement, unsigned req_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_dyn_execute)(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceDYNRequest* request, ISC_INT64 time_millis, unsigned req_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_service_attach)(ITracePlugin* self, ITraceServiceConnection* service, unsigned att_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_service_start)(ITracePlugin* self, ITraceServiceConnection* service, unsigned switches_length, const char* switches, unsigned start_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_service_query)(ITracePlugin* self, ITraceServiceConnection* service, unsigned send_item_length, const unsigned char* send_items, unsigned recv_item_length, const unsigned char* recv_items, unsigned query_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_service_detach)(ITracePlugin* self, ITraceServiceConnection* service, unsigned detach_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_event_error)(ITracePlugin* self, ITraceConnection* connection, ITraceStatusVector* status, const char* function) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_event_sweep)(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceSweepInfo* sweep, unsigned sweep_state) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_func_execute)(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceFunction* function, FB_BOOLEAN started, unsigned func_result) throw();
		};

	protected:
		ITracePlugin(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~ITracePlugin()
		{
		}

	public:
		static const unsigned VERSION = 3;

		static const unsigned TRACE_RESULT_SUCCESS = 0;
		static const unsigned TRACE_RESULT_FAILED = 1;
		static const unsigned TRACE_RESULT_UNAUTHORIZED = 2;
		static const unsigned SWEEP_STATE_STARTED = 1;
		static const unsigned SWEEP_STATE_FINISHED = 2;
		static const unsigned SWEEP_STATE_FAILED = 3;
		static const unsigned SWEEP_STATE_PROGRESS = 4;

		const char* trace_get_error()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->trace_get_error(this);
			return ret;
		}

		FB_BOOLEAN trace_attach(ITraceDatabaseConnection* connection, FB_BOOLEAN create_db, unsigned att_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_attach(this, connection, create_db, att_result);
			return ret;
		}

		FB_BOOLEAN trace_detach(ITraceDatabaseConnection* connection, FB_BOOLEAN drop_db)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_detach(this, connection, drop_db);
			return ret;
		}

		FB_BOOLEAN trace_transaction_start(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, unsigned tpb_length, const unsigned char* tpb, unsigned tra_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_transaction_start(this, connection, transaction, tpb_length, tpb, tra_result);
			return ret;
		}

		FB_BOOLEAN trace_transaction_end(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, FB_BOOLEAN commit, FB_BOOLEAN retain_context, unsigned tra_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_transaction_end(this, connection, transaction, commit, retain_context, tra_result);
			return ret;
		}

		FB_BOOLEAN trace_proc_execute(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceProcedure* procedure, FB_BOOLEAN started, unsigned proc_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_proc_execute(this, connection, transaction, procedure, started, proc_result);
			return ret;
		}

		FB_BOOLEAN trace_trigger_execute(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceTrigger* trigger, FB_BOOLEAN started, unsigned trig_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_trigger_execute(this, connection, transaction, trigger, started, trig_result);
			return ret;
		}

		FB_BOOLEAN trace_set_context(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceContextVariable* variable)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_set_context(this, connection, transaction, variable);
			return ret;
		}

		FB_BOOLEAN trace_dsql_prepare(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceSQLStatement* statement, ISC_INT64 time_millis, unsigned req_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_dsql_prepare(this, connection, transaction, statement, time_millis, req_result);
			return ret;
		}

		FB_BOOLEAN trace_dsql_free(ITraceDatabaseConnection* connection, ITraceSQLStatement* statement, unsigned option)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_dsql_free(this, connection, statement, option);
			return ret;
		}

		FB_BOOLEAN trace_dsql_execute(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceSQLStatement* statement, FB_BOOLEAN started, unsigned req_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_dsql_execute(this, connection, transaction, statement, started, req_result);
			return ret;
		}

		FB_BOOLEAN trace_blr_compile(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceBLRStatement* statement, ISC_INT64 time_millis, unsigned req_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_blr_compile(this, connection, transaction, statement, time_millis, req_result);
			return ret;
		}

		FB_BOOLEAN trace_blr_execute(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceBLRStatement* statement, unsigned req_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_blr_execute(this, connection, transaction, statement, req_result);
			return ret;
		}

		FB_BOOLEAN trace_dyn_execute(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceDYNRequest* request, ISC_INT64 time_millis, unsigned req_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_dyn_execute(this, connection, transaction, request, time_millis, req_result);
			return ret;
		}

		FB_BOOLEAN trace_service_attach(ITraceServiceConnection* service, unsigned att_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_service_attach(this, service, att_result);
			return ret;
		}

		FB_BOOLEAN trace_service_start(ITraceServiceConnection* service, unsigned switches_length, const char* switches, unsigned start_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_service_start(this, service, switches_length, switches, start_result);
			return ret;
		}

		FB_BOOLEAN trace_service_query(ITraceServiceConnection* service, unsigned send_item_length, const unsigned char* send_items, unsigned recv_item_length, const unsigned char* recv_items, unsigned query_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_service_query(this, service, send_item_length, send_items, recv_item_length, recv_items, query_result);
			return ret;
		}

		FB_BOOLEAN trace_service_detach(ITraceServiceConnection* service, unsigned detach_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_service_detach(this, service, detach_result);
			return ret;
		}

		FB_BOOLEAN trace_event_error(ITraceConnection* connection, ITraceStatusVector* status, const char* function)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_event_error(this, connection, status, function);
			return ret;
		}

		FB_BOOLEAN trace_event_sweep(ITraceDatabaseConnection* connection, ITraceSweepInfo* sweep, unsigned sweep_state)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_event_sweep(this, connection, sweep, sweep_state);
			return ret;
		}

		FB_BOOLEAN trace_func_execute(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceFunction* function, FB_BOOLEAN started, unsigned func_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_func_execute(this, connection, transaction, function, started, func_result);
			return ret;
		}
	};

	class ITraceFactory : public IPluginBase
	{
	public:
		struct VTable : public IPluginBase::VTable
		{
			ISC_UINT64 (CLOOP_CARG *trace_needs)(ITraceFactory* self) throw();
			ITracePlugin* (CLOOP_CARG *trace_create)(ITraceFactory* self, IStatus* status, ITraceInitInfo* init_info) throw();
		};

	protected:
		ITraceFactory(DoNotInherit)
			: IPluginBase(DoNotInherit())
		{
		}

		~ITraceFactory()
		{
		}

	public:
		static const unsigned VERSION = 4;

		static const unsigned TRACE_EVENT_ATTACH = 0;
		static const unsigned TRACE_EVENT_DETACH = 1;
		static const unsigned TRACE_EVENT_TRANSACTION_START = 2;
		static const unsigned TRACE_EVENT_TRANSACTION_END = 3;
		static const unsigned TRACE_EVENT_SET_CONTEXT = 4;
		static const unsigned TRACE_EVENT_PROC_EXECUTE = 5;
		static const unsigned TRACE_EVENT_TRIGGER_EXECUTE = 6;
		static const unsigned TRACE_EVENT_DSQL_PREPARE = 7;
		static const unsigned TRACE_EVENT_DSQL_FREE = 8;
		static const unsigned TRACE_EVENT_DSQL_EXECUTE = 9;
		static const unsigned TRACE_EVENT_BLR_COMPILE = 10;
		static const unsigned TRACE_EVENT_BLR_EXECUTE = 11;
		static const unsigned TRACE_EVENT_DYN_EXECUTE = 12;
		static const unsigned TRACE_EVENT_SERVICE_ATTACH = 13;
		static const unsigned TRACE_EVENT_SERVICE_START = 14;
		static const unsigned TRACE_EVENT_SERVICE_QUERY = 15;
		static const unsigned TRACE_EVENT_SERVICE_DETACH = 16;
		static const unsigned TRACE_EVENT_ERROR = 17;
		static const unsigned TRACE_EVENT_SWEEP = 18;
		static const unsigned TRACE_EVENT_FUNC_EXECUTE = 19;
		static const unsigned TRACE_EVENT_MAX = 20;

		ISC_UINT64 trace_needs()
		{
			ISC_UINT64 ret = static_cast<VTable*>(this->cloopVTable)->trace_needs(this);
			return ret;
		}

		ITracePlugin* trace_create(IStatus* status, ITraceInitInfo* init_info)
		{
			typename Policy::IStatus status2(status);
			ITracePlugin* ret = static_cast<VTable*>(this->cloopVTable)->trace_create(this, status2, init_info);
			Policy::checkException(status2);
			return ret;
		}
	};

	// Interfaces implementations

	template <typename Name, typename Base>
	class IVersionedBaseImpl : public Base
	{
	public:
		typedef IVersioned Declaration;

		IVersionedBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = Inherit<IVersioned> >
	class IVersionedImpl : public IVersionedBaseImpl<Name, Base>
	{
	protected:
		IVersionedImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IVersionedImpl()
		{
		}

		virtual IPluginModule* getModule() = 0;
	};

	template <typename Name, typename Base>
	class IReferenceCountedBaseImpl : public Base
	{
	public:
		typedef IReferenceCounted Declaration;

		IReferenceCountedBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IVersionedImpl<Name, Inherit<IReferenceCounted> > >
	class IReferenceCountedImpl : public IReferenceCountedBaseImpl<Name, Base>
	{
	protected:
		IReferenceCountedImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IReferenceCountedImpl()
		{
		}

		virtual void addRef() = 0;
		virtual int release() = 0;
	};

	template <typename Name, typename Base>
	class IDisposableBaseImpl : public Base
	{
	public:
		typedef IDisposable Declaration;

		IDisposableBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->dispose = &Name::cloopdisposeDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopdisposeDispatcher(IDisposable* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::dispose();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IVersionedImpl<Name, Inherit<IDisposable> > >
	class IDisposableImpl : public IDisposableBaseImpl<Name, Base>
	{
	protected:
		IDisposableImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IDisposableImpl()
		{
		}

		virtual void dispose() = 0;
	};

	template <typename Name, typename Base>
	class IStatusBaseImpl : public Base
	{
	public:
		typedef IStatus Declaration;

		IStatusBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->dispose = &Name::cloopdisposeDispatcher;
					this->init = &Name::cloopinitDispatcher;
					this->getStatus = &Name::cloopgetStatusDispatcher;
					this->setErrors2 = &Name::cloopsetErrors2Dispatcher;
					this->setWarnings2 = &Name::cloopsetWarnings2Dispatcher;
					this->setErrors = &Name::cloopsetErrorsDispatcher;
					this->setWarnings = &Name::cloopsetWarningsDispatcher;
					this->getErrors = &Name::cloopgetErrorsDispatcher;
					this->getWarnings = &Name::cloopgetWarningsDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopinitDispatcher(IStatus* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::init();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetStatusDispatcher(const IStatus* self) throw()
		{
			try
			{
				return static_cast<const Name*>(self)->Name::getStatus();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static void CLOOP_CARG cloopsetErrors2Dispatcher(IStatus* self, unsigned length, const intptr_t* value) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setErrors2(length, value);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static void CLOOP_CARG cloopsetWarnings2Dispatcher(IStatus* self, unsigned length, const intptr_t* value) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setWarnings2(length, value);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static void CLOOP_CARG cloopsetErrorsDispatcher(IStatus* self, const intptr_t* value) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setErrors(value);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static void CLOOP_CARG cloopsetWarningsDispatcher(IStatus* self, const intptr_t* value) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setWarnings(value);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static const intptr_t* CLOOP_CARG cloopgetErrorsDispatcher(const IStatus* self) throw()
		{
			try
			{
				return static_cast<const Name*>(self)->Name::getErrors();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const intptr_t*>(0);
			}
		}

		static const intptr_t* CLOOP_CARG cloopgetWarningsDispatcher(const IStatus* self) throw()
		{
			try
			{
				return static_cast<const Name*>(self)->Name::getWarnings();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const intptr_t*>(0);
			}
		}

		static void CLOOP_CARG cloopdisposeDispatcher(IDisposable* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::dispose();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IDisposableImpl<Name, Inherit<IVersionedImpl<Name, Inherit<IStatus> > > > >
	class IStatusImpl : public IStatusBaseImpl<Name, Base>
	{
	protected:
		IStatusImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IStatusImpl()
		{
		}

		virtual void init() = 0;
		virtual unsigned getStatus() const = 0;
		virtual void setErrors2(unsigned length, const intptr_t* value) = 0;
		virtual void setWarnings2(unsigned length, const intptr_t* value) = 0;
		virtual void setErrors(const intptr_t* value) = 0;
		virtual void setWarnings(const intptr_t* value) = 0;
		virtual const intptr_t* getErrors() const = 0;
		virtual const intptr_t* getWarnings() const = 0;
	};

	template <typename Name, typename Base>
	class IMasterBaseImpl : public Base
	{
	public:
		typedef IMaster Declaration;

		IMasterBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getStatus = &Name::cloopgetStatusDispatcher;
					this->getDispatcher = &Name::cloopgetDispatcherDispatcher;
					this->getPluginManager = &Name::cloopgetPluginManagerDispatcher;
					this->circularAlloc = &Name::cloopcircularAllocDispatcher;
					this->getTimerControl = &Name::cloopgetTimerControlDispatcher;
					this->getDtc = &Name::cloopgetDtcDispatcher;
					this->registerAttachment = &Name::cloopregisterAttachmentDispatcher;
					this->registerTransaction = &Name::cloopregisterTransactionDispatcher;
					this->same = &Name::cloopsameDispatcher;
					this->getMetadataBuilder = &Name::cloopgetMetadataBuilderDispatcher;
					this->serverMode = &Name::cloopserverModeDispatcher;
					this->getUtlInterface = &Name::cloopgetUtlInterfaceDispatcher;
					this->getConfigManager = &Name::cloopgetConfigManagerDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static IStatus* CLOOP_CARG cloopgetStatusDispatcher(IMaster* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getStatus();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IStatus*>(0);
			}
		}

		static IProvider* CLOOP_CARG cloopgetDispatcherDispatcher(IMaster* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getDispatcher();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IProvider*>(0);
			}
		}

		static IPluginManager* CLOOP_CARG cloopgetPluginManagerDispatcher(IMaster* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPluginManager();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginManager*>(0);
			}
		}

		static const char* CLOOP_CARG cloopcircularAllocDispatcher(IMaster* self, const char* s, unsigned len, intptr_t thr) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::circularAlloc(s, len, thr);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static ITimerControl* CLOOP_CARG cloopgetTimerControlDispatcher(IMaster* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getTimerControl();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ITimerControl*>(0);
			}
		}

		static IDtc* CLOOP_CARG cloopgetDtcDispatcher(IMaster* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getDtc();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IDtc*>(0);
			}
		}

		static IAttachment* CLOOP_CARG cloopregisterAttachmentDispatcher(IMaster* self, IProvider* provider, IAttachment* attachment) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::registerAttachment(provider, attachment);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IAttachment*>(0);
			}
		}

		static ITransaction* CLOOP_CARG cloopregisterTransactionDispatcher(IMaster* self, IAttachment* attachment, ITransaction* transaction) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::registerTransaction(attachment, transaction);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ITransaction*>(0);
			}
		}

		static int CLOOP_CARG cloopsameDispatcher(IMaster* self, IVersioned* first, IVersioned* second) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::same(first, second);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static IMetadataBuilder* CLOOP_CARG cloopgetMetadataBuilderDispatcher(IMaster* self, IStatus* status, unsigned fieldCount) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getMetadataBuilder(status, fieldCount);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IMetadataBuilder*>(0);
			}
		}

		static int CLOOP_CARG cloopserverModeDispatcher(IMaster* self, int mode) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::serverMode(mode);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static IUtl* CLOOP_CARG cloopgetUtlInterfaceDispatcher(IMaster* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getUtlInterface();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IUtl*>(0);
			}
		}

		static IConfigManager* CLOOP_CARG cloopgetConfigManagerDispatcher(IMaster* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getConfigManager();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IConfigManager*>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IVersionedImpl<Name, Inherit<IMaster> > >
	class IMasterImpl : public IMasterBaseImpl<Name, Base>
	{
	protected:
		IMasterImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IMasterImpl()
		{
		}

		virtual IStatus* getStatus() = 0;
		virtual IProvider* getDispatcher() = 0;
		virtual IPluginManager* getPluginManager() = 0;
		virtual const char* circularAlloc(const char* s, unsigned len, intptr_t thr) = 0;
		virtual ITimerControl* getTimerControl() = 0;
		virtual IDtc* getDtc() = 0;
		virtual IAttachment* registerAttachment(IProvider* provider, IAttachment* attachment) = 0;
		virtual ITransaction* registerTransaction(IAttachment* attachment, ITransaction* transaction) = 0;
		virtual int same(IVersioned* first, IVersioned* second) = 0;
		virtual IMetadataBuilder* getMetadataBuilder(IStatus* status, unsigned fieldCount) = 0;
		virtual int serverMode(int mode) = 0;
		virtual IUtl* getUtlInterface() = 0;
		virtual IConfigManager* getConfigManager() = 0;
	};

	template <typename Name, typename Base>
	class IPluginBaseBaseImpl : public Base
	{
	public:
		typedef IPluginBase Declaration;

		IPluginBaseBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->setOwner = &Name::cloopsetOwnerDispatcher;
					this->getOwner = &Name::cloopgetOwnerDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopsetOwnerDispatcher(IPluginBase* self, IReferenceCounted* r) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setOwner(r);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static IReferenceCounted* CLOOP_CARG cloopgetOwnerDispatcher(IPluginBase* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOwner();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IReferenceCounted*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IReferenceCountedImpl<Name, Inherit<IVersionedImpl<Name, Inherit<IPluginBase> > > > >
	class IPluginBaseImpl : public IPluginBaseBaseImpl<Name, Base>
	{
	protected:
		IPluginBaseImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IPluginBaseImpl()
		{
		}

		virtual void setOwner(IReferenceCounted* r) = 0;
		virtual IReferenceCounted* getOwner() = 0;
	};

	template <typename Name, typename Base>
	class IPluginSetBaseImpl : public Base
	{
	public:
		typedef IPluginSet Declaration;

		IPluginSetBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->getName = &Name::cloopgetNameDispatcher;
					this->getModuleName = &Name::cloopgetModuleNameDispatcher;
					this->getPlugin = &Name::cloopgetPluginDispatcher;
					this->next = &Name::cloopnextDispatcher;
					this->set = &Name::cloopsetDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetNameDispatcher(const IPluginSet* self) throw()
		{
			try
			{
				return static_cast<const Name*>(self)->Name::getName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetModuleNameDispatcher(const IPluginSet* self) throw()
		{
			try
			{
				return static_cast<const Name*>(self)->Name::getModuleName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static IPluginBase* CLOOP_CARG cloopgetPluginDispatcher(IPluginSet* self, IStatus* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPlugin(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IPluginBase*>(0);
			}
		}

		static void CLOOP_CARG cloopnextDispatcher(IPluginSet* self, IStatus* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::next(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopsetDispatcher(IPluginSet* self, IStatus* status, const char* s) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::set(status, s);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IReferenceCountedImpl<Name, Inherit<IVersionedImpl<Name, Inherit<IPluginSet> > > > >
	class IPluginSetImpl : public IPluginSetBaseImpl<Name, Base>
	{
	protected:
		IPluginSetImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IPluginSetImpl()
		{
		}

		virtual const char* getName() const = 0;
		virtual const char* getModuleName() const = 0;
		virtual IPluginBase* getPlugin(IStatus* status) = 0;
		virtual void next(IStatus* status) = 0;
		virtual void set(IStatus* status, const char* s) = 0;
	};

	template <typename Name, typename Base>
	class IConfigEntryBaseImpl : public Base
	{
	public:
		typedef IConfigEntry Declaration;

		IConfigEntryBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->getName = &Name::cloopgetNameDispatcher;
					this->getValue = &Name::cloopgetValueDispatcher;
					this->getIntValue = &Name::cloopgetIntValueDispatcher;
					this->getBoolValue = &Name::cloopgetBoolValueDispatcher;
					this->getSubConfig = &Name::cloopgetSubConfigDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetNameDispatcher(IConfigEntry* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetValueDispatcher(IConfigEntry* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getValue();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static ISC_INT64 CLOOP_CARG cloopgetIntValueDispatcher(IConfigEntry* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getIntValue();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ISC_INT64>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG cloopgetBoolValueDispatcher(IConfigEntry* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getBoolValue();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static IConfig* CLOOP_CARG cloopgetSubConfigDispatcher(IConfigEntry* self, IStatus* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getSubConfig(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IConfig*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IReferenceCountedImpl<Name, Inherit<IVersionedImpl<Name, Inherit<IConfigEntry> > > > >
	class IConfigEntryImpl : public IConfigEntryBaseImpl<Name, Base>
	{
	protected:
		IConfigEntryImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IConfigEntryImpl()
		{
		}

		virtual const char* getName() = 0;
		virtual const char* getValue() = 0;
		virtual ISC_INT64 getIntValue() = 0;
		virtual FB_BOOLEAN getBoolValue() = 0;
		virtual IConfig* getSubConfig(IStatus* status) = 0;
	};

	template <typename Name, typename Base>
	class IConfigBaseImpl : public Base
	{
	public:
		typedef IConfig Declaration;

		IConfigBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->find = &Name::cloopfindDispatcher;
					this->findValue = &Name::cloopfindValueDispatcher;
					this->findPos = &Name::cloopfindPosDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static IConfigEntry* CLOOP_CARG cloopfindDispatcher(IConfig* self, IStatus* status, const char* name) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::find(status, name);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IConfigEntry*>(0);
			}
		}

		static IConfigEntry* CLOOP_CARG cloopfindValueDispatcher(IConfig* self, IStatus* status, const char* name, const char* value) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::findValue(status, name, value);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IConfigEntry*>(0);
			}
		}

		static IConfigEntry* CLOOP_CARG cloopfindPosDispatcher(IConfig* self, IStatus* status, const char* name, unsigned pos) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::findPos(status, name, pos);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IConfigEntry*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IReferenceCountedImpl<Name, Inherit<IVersionedImpl<Name, Inherit<IConfig> > > > >
	class IConfigImpl : public IConfigBaseImpl<Name, Base>
	{
	protected:
		IConfigImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IConfigImpl()
		{
		}

		virtual IConfigEntry* find(IStatus* status, const char* name) = 0;
		virtual IConfigEntry* findValue(IStatus* status, const char* name, const char* value) = 0;
		virtual IConfigEntry* findPos(IStatus* status, const char* name, unsigned pos) = 0;
	};

	template <typename Name, typename Base>
	class IFirebirdConfBaseImpl : public Base
	{
	public:
		typedef IFirebirdConf Declaration;

		IFirebirdConfBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->getKey = &Name::cloopgetKeyDispatcher;
					this->asInteger = &Name::cloopasIntegerDispatcher;
					this->asString = &Name::cloopasStringDispatcher;
					this->asBoolean = &Name::cloopasBooleanDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static unsigned CLOOP_CARG cloopgetKeyDispatcher(IFirebirdConf* self, const char* name) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getKey(name);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static ISC_INT64 CLOOP_CARG cloopasIntegerDispatcher(IFirebirdConf* self, unsigned key) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::asInteger(key);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ISC_INT64>(0);
			}
		}

		static const char* CLOOP_CARG cloopasStringDispatcher(IFirebirdConf* self, unsigned key) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::asString(key);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG cloopasBooleanDispatcher(IFirebirdConf* self, unsigned key) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::asBoolean(key);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IReferenceCountedImpl<Name, Inherit<IVersionedImpl<Name, Inherit<IFirebirdConf> > > > >
	class IFirebirdConfImpl : public IFirebirdConfBaseImpl<Name, Base>
	{
	protected:
		IFirebirdConfImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IFirebirdConfImpl()
		{
		}

		virtual unsigned getKey(const char* name) = 0;
		virtual ISC_INT64 asInteger(unsigned key) = 0;
		virtual const char* asString(unsigned key) = 0;
		virtual FB_BOOLEAN asBoolean(unsigned key) = 0;
	};

	template <typename Name, typename Base>
	class IPluginConfigBaseImpl : public Base
	{
	public:
		typedef IPluginConfig Declaration;

		IPluginConfigBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->getConfigFileName = &Name::cloopgetConfigFileNameDispatcher;
					this->getDefaultConfig = &Name::cloopgetDefaultConfigDispatcher;
					this->getFirebirdConf = &Name::cloopgetFirebirdConfDispatcher;
					this->setReleaseDelay = &Name::cloopsetReleaseDelayDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetConfigFileNameDispatcher(IPluginConfig* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getConfigFileName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static IConfig* CLOOP_CARG cloopgetDefaultConfigDispatcher(IPluginConfig* self, IStatus* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getDefaultConfig(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IConfig*>(0);
			}
		}

		static IFirebirdConf* CLOOP_CARG cloopgetFirebirdConfDispatcher(IPluginConfig* self, IStatus* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getFirebirdConf(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IFirebirdConf*>(0);
			}
		}

		static void CLOOP_CARG cloopsetReleaseDelayDispatcher(IPluginConfig* self, IStatus* status, ISC_UINT64 microSeconds) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setReleaseDelay(status, microSeconds);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IReferenceCountedImpl<Name, Inherit<IVersionedImpl<Name, Inherit<IPluginConfig> > > > >
	class IPluginConfigImpl : public IPluginConfigBaseImpl<Name, Base>
	{
	protected:
		IPluginConfigImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IPluginConfigImpl()
		{
		}

		virtual const char* getConfigFileName() = 0;
		virtual IConfig* getDefaultConfig(IStatus* status) = 0;
		virtual IFirebirdConf* getFirebirdConf(IStatus* status) = 0;
		virtual void setReleaseDelay(IStatus* status, ISC_UINT64 microSeconds) = 0;
	};

	template <typename Name, typename Base>
	class IPluginFactoryBaseImpl : public Base
	{
	public:
		typedef IPluginFactory Declaration;

		IPluginFactoryBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->createPlugin = &Name::cloopcreatePluginDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static IPluginBase* CLOOP_CARG cloopcreatePluginDispatcher(IPluginFactory* self, IStatus* status, IPluginConfig* factoryParameter) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::createPlugin(status, factoryParameter);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IPluginBase*>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IVersionedImpl<Name, Inherit<IPluginFactory> > >
	class IPluginFactoryImpl : public IPluginFactoryBaseImpl<Name, Base>
	{
	protected:
		IPluginFactoryImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IPluginFactoryImpl()
		{
		}

		virtual IPluginBase* createPlugin(IStatus* status, IPluginConfig* factoryParameter) = 0;
	};

	template <typename Name, typename Base>
	class IPluginModuleBaseImpl : public Base
	{
	public:
		typedef IPluginModule Declaration;

		IPluginModuleBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->doClean = &Name::cloopdoCleanDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopdoCleanDispatcher(IPluginModule* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::doClean();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IVersionedImpl<Name, Inherit<IPluginModule> > >
	class IPluginModuleImpl : public IPluginModuleBaseImpl<Name, Base>
	{
	protected:
		IPluginModuleImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IPluginModuleImpl()
		{
		}

		virtual void doClean() = 0;
	};

	template <typename Name, typename Base>
	class IPluginManagerBaseImpl : public Base
	{
	public:
		typedef IPluginManager Declaration;

		IPluginManagerBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->registerPluginFactory = &Name::cloopregisterPluginFactoryDispatcher;
					this->registerModule = &Name::cloopregisterModuleDispatcher;
					this->unregisterModule = &Name::cloopunregisterModuleDispatcher;
					this->getPlugins = &Name::cloopgetPluginsDispatcher;
					this->getConfig = &Name::cloopgetConfigDispatcher;
					this->releasePlugin = &Name::cloopreleasePluginDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopregisterPluginFactoryDispatcher(IPluginManager* self, unsigned pluginType, const char* defaultName, IPluginFactory* factory) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::registerPluginFactory(pluginType, defaultName, factory);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static void CLOOP_CARG cloopregisterModuleDispatcher(IPluginManager* self, IPluginModule* cleanup) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::registerModule(cleanup);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static void CLOOP_CARG cloopunregisterModuleDispatcher(IPluginManager* self, IPluginModule* cleanup) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::unregisterModule(cleanup);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static IPluginSet* CLOOP_CARG cloopgetPluginsDispatcher(IPluginManager* self, IStatus* status, unsigned pluginType, const char* namesList, IFirebirdConf* firebirdConf) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPlugins(status, pluginType, namesList, firebirdConf);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IPluginSet*>(0);
			}
		}

		static IConfig* CLOOP_CARG cloopgetConfigDispatcher(IPluginManager* self, IStatus* status, const char* filename) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getConfig(status, filename);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IConfig*>(0);
			}
		}

		static void CLOOP_CARG cloopreleasePluginDispatcher(IPluginManager* self, IPluginBase* plugin) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::releasePlugin(plugin);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IVersionedImpl<Name, Inherit<IPluginManager> > >
	class IPluginManagerImpl : public IPluginManagerBaseImpl<Name, Base>
	{
	protected:
		IPluginManagerImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IPluginManagerImpl()
		{
		}

		virtual void registerPluginFactory(unsigned pluginType, const char* defaultName, IPluginFactory* factory) = 0;
		virtual void registerModule(IPluginModule* cleanup) = 0;
		virtual void unregisterModule(IPluginModule* cleanup) = 0;
		virtual IPluginSet* getPlugins(IStatus* status, unsigned pluginType, const char* namesList, IFirebirdConf* firebirdConf) = 0;
		virtual IConfig* getConfig(IStatus* status, const char* filename) = 0;
		virtual void releasePlugin(IPluginBase* plugin) = 0;
	};

	template <typename Name, typename Base>
	class IConfigManagerBaseImpl : public Base
	{
	public:
		typedef IConfigManager Declaration;

		IConfigManagerBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getDirectory = &Name::cloopgetDirectoryDispatcher;
					this->getFirebirdConf = &Name::cloopgetFirebirdConfDispatcher;
					this->getDatabaseConf = &Name::cloopgetDatabaseConfDispatcher;
					this->getPluginConfig = &Name::cloopgetPluginConfigDispatcher;
					this->getInstallDirectory = &Name::cloopgetInstallDirectoryDispatcher;
					this->getRootDirectory = &Name::cloopgetRootDirectoryDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetDirectoryDispatcher(IConfigManager* self, unsigned code) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getDirectory(code);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static IFirebirdConf* CLOOP_CARG cloopgetFirebirdConfDispatcher(IConfigManager* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getFirebirdConf();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IFirebirdConf*>(0);
			}
		}

		static IFirebirdConf* CLOOP_CARG cloopgetDatabaseConfDispatcher(IConfigManager* self, const char* dbName) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getDatabaseConf(dbName);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IFirebirdConf*>(0);
			}
		}

		static IConfig* CLOOP_CARG cloopgetPluginConfigDispatcher(IConfigManager* self, const char* configuredPlugin) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPluginConfig(configuredPlugin);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IConfig*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetInstallDirectoryDispatcher(IConfigManager* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getInstallDirectory();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRootDirectoryDispatcher(IConfigManager* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRootDirectory();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IVersionedImpl<Name, Inherit<IConfigManager> > >
	class IConfigManagerImpl : public IConfigManagerBaseImpl<Name, Base>
	{
	protected:
		IConfigManagerImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IConfigManagerImpl()
		{
		}

		virtual const char* getDirectory(unsigned code) = 0;
		virtual IFirebirdConf* getFirebirdConf() = 0;
		virtual IFirebirdConf* getDatabaseConf(const char* dbName) = 0;
		virtual IConfig* getPluginConfig(const char* configuredPlugin) = 0;
		virtual const char* getInstallDirectory() = 0;
		virtual const char* getRootDirectory() = 0;
	};

	template <typename Name, typename Base>
	class IEventCallbackBaseImpl : public Base
	{
	public:
		typedef IEventCallback Declaration;

		IEventCallbackBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->eventCallbackFunction = &Name::cloopeventCallbackFunctionDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopeventCallbackFunctionDispatcher(IEventCallback* self, unsigned length, const unsigned char* events) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::eventCallbackFunction(length, events);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IReferenceCountedImpl<Name, Inherit<IVersionedImpl<Name, Inherit<IEventCallback> > > > >
	class IEventCallbackImpl : public IEventCallbackBaseImpl<Name, Base>
	{
	protected:
		IEventCallbackImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IEventCallbackImpl()
		{
		}

		virtual void eventCallbackFunction(unsigned length, const unsigned char* events) = 0;
	};

	template <typename Name, typename Base>
	class IBlobBaseImpl : public Base
	{
	public:
		typedef IBlob Declaration;

		IBlobBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->getInfo = &Name::cloopgetInfoDispatcher;
					this->getSegment = &Name::cloopgetSegmentDispatcher;
					this->putSegment = &Name::cloopputSegmentDispatcher;
					this->cancel = &Name::cloopcancelDispatcher;
					this->close = &Name::cloopcloseDispatcher;
					this->seek = &Name::cloopseekDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopgetInfoDispatcher(IBlob* self, IStatus* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::getInfo(status, itemsLength, items, bufferLength, buffer);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static int CLOOP_CARG cloopgetSegmentDispatcher(IBlob* self, IStatus* status, unsigned bufferLength, void* buffer, unsigned* segmentLength) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getSegment(status, bufferLength, buffer, segmentLength);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<int>(0);
			}
		}

		static void CLOOP_CARG cloopputSegmentDispatcher(IBlob* self, IStatus* status, unsigned length, const void* buffer) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::putSegment(status, length, buffer);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopcancelDispatcher(IBlob* self, IStatus* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::cancel(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopcloseDispatcher(IBlob* self, IStatus* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::close(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static int CLOOP_CARG cloopseekDispatcher(IBlob* self, IStatus* status, int mode, int offset) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::seek(status, mode, offset);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<int>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IReferenceCountedImpl<Name, Inherit<IVersionedImpl<Name, Inherit<IBlob> > > > >
	class IBlobImpl : public IBlobBaseImpl<Name, Base>
	{
	protected:
		IBlobImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IBlobImpl()
		{
		}

		virtual void getInfo(IStatus* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) = 0;
		virtual int getSegment(IStatus* status, unsigned bufferLength, void* buffer, unsigned* segmentLength) = 0;
		virtual void putSegment(IStatus* status, unsigned length, const void* buffer) = 0;
		virtual void cancel(IStatus* status) = 0;
		virtual void close(IStatus* status) = 0;
		virtual int seek(IStatus* status, int mode, int offset) = 0;
	};

	template <typename Name, typename Base>
	class ITransactionBaseImpl : public Base
	{
	public:
		typedef ITransaction Declaration;

		ITransactionBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->getInfo = &Name::cloopgetInfoDispatcher;
					this->prepare = &Name::cloopprepareDispatcher;
					this->commit = &Name::cloopcommitDispatcher;
					this->commitRetaining = &Name::cloopcommitRetainingDispatcher;
					this->rollback = &Name::clooprollbackDispatcher;
					this->rollbackRetaining = &Name::clooprollbackRetainingDispatcher;
					this->disconnect = &Name::cloopdisconnectDispatcher;
					this->join = &Name::cloopjoinDispatcher;
					this->validate = &Name::cloopvalidateDispatcher;
					this->enterDtc = &Name::cloopenterDtcDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopgetInfoDispatcher(ITransaction* self, IStatus* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::getInfo(status, itemsLength, items, bufferLength, buffer);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopprepareDispatcher(ITransaction* self, IStatus* status, unsigned msgLength, const unsigned char* message) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::prepare(status, msgLength, message);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopcommitDispatcher(ITransaction* self, IStatus* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::commit(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopcommitRetainingDispatcher(ITransaction* self, IStatus* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::commitRetaining(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG clooprollbackDispatcher(ITransaction* self, IStatus* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::rollback(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG clooprollbackRetainingDispatcher(ITransaction* self, IStatus* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::rollbackRetaining(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopdisconnectDispatcher(ITransaction* self, IStatus* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::disconnect(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static ITransaction* CLOOP_CARG cloopjoinDispatcher(ITransaction* self, IStatus* status, ITransaction* transaction) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::join(status, transaction);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<ITransaction*>(0);
			}
		}

		static ITransaction* CLOOP_CARG cloopvalidateDispatcher(ITransaction* self, IStatus* status, IAttachment* attachment) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::validate(status, attachment);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<ITransaction*>(0);
			}
		}

		static ITransaction* CLOOP_CARG cloopenterDtcDispatcher(ITransaction* self, IStatus* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::enterDtc(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<ITransaction*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IReferenceCountedImpl<Name, Inherit<IVersionedImpl<Name, Inherit<ITransaction> > > > >
	class ITransactionImpl : public ITransactionBaseImpl<Name, Base>
	{
	protected:
		ITransactionImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITransactionImpl()
		{
		}

		virtual void getInfo(IStatus* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) = 0;
		virtual void prepare(IStatus* status, unsigned msgLength, const unsigned char* message) = 0;
		virtual void commit(IStatus* status) = 0;
		virtual void commitRetaining(IStatus* status) = 0;
		virtual void rollback(IStatus* status) = 0;
		virtual void rollbackRetaining(IStatus* status) = 0;
		virtual void disconnect(IStatus* status) = 0;
		virtual ITransaction* join(IStatus* status, ITransaction* transaction) = 0;
		virtual ITransaction* validate(IStatus* status, IAttachment* attachment) = 0;
		virtual ITransaction* enterDtc(IStatus* status) = 0;
	};

	template <typename Name, typename Base>
	class IMessageMetadataBaseImpl : public Base
	{
	public:
		typedef IMessageMetadata Declaration;

		IMessageMetadataBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->getCount = &Name::cloopgetCountDispatcher;
					this->getField = &Name::cloopgetFieldDispatcher;
					this->getRelation = &Name::cloopgetRelationDispatcher;
					this->getOwner = &Name::cloopgetOwnerDispatcher;
					this->getAlias = &Name::cloopgetAliasDispatcher;
					this->getType = &Name::cloopgetTypeDispatcher;
					this->isNullable = &Name::cloopisNullableDispatcher;
					this->getSubType = &Name::cloopgetSubTypeDispatcher;
					this->getLength = &Name::cloopgetLengthDispatcher;
					this->getScale = &Name::cloopgetScaleDispatcher;
					this->getCharSet = &Name::cloopgetCharSetDispatcher;
					this->getOffset = &Name::cloopgetOffsetDispatcher;
					this->getNullOffset = &Name::cloopgetNullOffsetDispatcher;
					this->getBuilder = &Name::cloopgetBuilderDispatcher;
					this->getMessageLength = &Name::cloopgetMessageLengthDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static unsigned CLOOP_CARG cloopgetCountDispatcher(IMessageMetadata* self, IStatus* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getCount(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<unsigned>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetFieldDispatcher(IMessageMetadata* self, IStatus* status, unsigned index) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getField(status, index);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRelationDispatcher(IMessageMetadata* self, IStatus* status, unsigned index) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRelation(status, index);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetOwnerDispatcher(IMessageMetadata* self, IStatus* status, unsigned index) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOwner(status, index);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetAliasDispatcher(IMessageMetadata* self, IStatus* status, unsigned index) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getAlias(status, index);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<const char*>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetTypeDispatcher(IMessageMetadata* self, IStatus* status, unsigned index) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getType(status, index);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<unsigned>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG cloopisNullableDispatcher(IMessageMetadata* self, IStatus* status, unsigned index) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::isNullable(status, index);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static int CLOOP_CARG cloopgetSubTypeDispatcher(IMessageMetadata* self, IStatus* status, unsigned index) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getSubType(status, index);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<int>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetLengthDispatcher(IMessageMetadata* self, IStatus* status, unsigned index) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getLength(status, index);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<unsigned>(0);
			}
		}

		static int CLOOP_CARG cloopgetScaleDispatcher(IMessageMetadata* self, IStatus* status, unsigned index) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getScale(status, index);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<int>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetCharSetDispatcher(IMessageMetadata* self, IStatus* status, unsigned index) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getCharSet(status, index);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<unsigned>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetOffsetDispatcher(IMessageMetadata* self, IStatus* status, unsigned index) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOffset(status, index);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<unsigned>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetNullOffsetDispatcher(IMessageMetadata* self, IStatus* status, unsigned index) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getNullOffset(status, index);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<unsigned>(0);
			}
		}

		static IMetadataBuilder* CLOOP_CARG cloopgetBuilderDispatcher(IMessageMetadata* self, IStatus* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getBuilder(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IMetadataBuilder*>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetMessageLengthDispatcher(IMessageMetadata* self, IStatus* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getMessageLength(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<unsigned>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IReferenceCountedImpl<Name, Inherit<IVersionedImpl<Name, Inherit<IMessageMetadata> > > > >
	class IMessageMetadataImpl : public IMessageMetadataBaseImpl<Name, Base>
	{
	protected:
		IMessageMetadataImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IMessageMetadataImpl()
		{
		}

		virtual unsigned getCount(IStatus* status) = 0;
		virtual const char* getField(IStatus* status, unsigned index) = 0;
		virtual const char* getRelation(IStatus* status, unsigned index) = 0;
		virtual const char* getOwner(IStatus* status, unsigned index) = 0;
		virtual const char* getAlias(IStatus* status, unsigned index) = 0;
		virtual unsigned getType(IStatus* status, unsigned index) = 0;
		virtual FB_BOOLEAN isNullable(IStatus* status, unsigned index) = 0;
		virtual int getSubType(IStatus* status, unsigned index) = 0;
		virtual unsigned getLength(IStatus* status, unsigned index) = 0;
		virtual int getScale(IStatus* status, unsigned index) = 0;
		virtual unsigned getCharSet(IStatus* status, unsigned index) = 0;
		virtual unsigned getOffset(IStatus* status, unsigned index) = 0;
		virtual unsigned getNullOffset(IStatus* status, unsigned index) = 0;
		virtual IMetadataBuilder* getBuilder(IStatus* status) = 0;
		virtual unsigned getMessageLength(IStatus* status) = 0;
	};

	template <typename Name, typename Base>
	class IMetadataBuilderBaseImpl : public Base
	{
	public:
		typedef IMetadataBuilder Declaration;

		IMetadataBuilderBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->setType = &Name::cloopsetTypeDispatcher;
					this->setSubType = &Name::cloopsetSubTypeDispatcher;
					this->setLength = &Name::cloopsetLengthDispatcher;
					this->setCharSet = &Name::cloopsetCharSetDispatcher;
					this->setScale = &Name::cloopsetScaleDispatcher;
					this->truncate = &Name::clooptruncateDispatcher;
					this->moveNameToIndex = &Name::cloopmoveNameToIndexDispatcher;
					this->remove = &Name::cloopremoveDispatcher;
					this->addField = &Name::cloopaddFieldDispatcher;
					this->getMetadata = &Name::cloopgetMetadataDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopsetTypeDispatcher(IMetadataBuilder* self, IStatus* status, unsigned index, unsigned type) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setType(status, index, type);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopsetSubTypeDispatcher(IMetadataBuilder* self, IStatus* status, unsigned index, int subType) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setSubType(status, index, subType);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopsetLengthDispatcher(IMetadataBuilder* self, IStatus* status, unsigned index, unsigned length) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setLength(status, index, length);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopsetCharSetDispatcher(IMetadataBuilder* self, IStatus* status, unsigned index, unsigned charSet) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setCharSet(status, index, charSet);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopsetScaleDispatcher(IMetadataBuilder* self, IStatus* status, unsigned index, unsigned scale) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setScale(status, index, scale);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG clooptruncateDispatcher(IMetadataBuilder* self, IStatus* status, unsigned count) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::truncate(status, count);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopmoveNameToIndexDispatcher(IMetadataBuilder* self, IStatus* status, const char* name, unsigned index) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::moveNameToIndex(status, name, index);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopremoveDispatcher(IMetadataBuilder* self, IStatus* status, unsigned index) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::remove(status, index);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static unsigned CLOOP_CARG cloopaddFieldDispatcher(IMetadataBuilder* self, IStatus* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::addField(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<unsigned>(0);
			}
		}

		static IMessageMetadata* CLOOP_CARG cloopgetMetadataDispatcher(IMetadataBuilder* self, IStatus* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getMetadata(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IMessageMetadata*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IReferenceCountedImpl<Name, Inherit<IVersionedImpl<Name, Inherit<IMetadataBuilder> > > > >
	class IMetadataBuilderImpl : public IMetadataBuilderBaseImpl<Name, Base>
	{
	protected:
		IMetadataBuilderImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IMetadataBuilderImpl()
		{
		}

		virtual void setType(IStatus* status, unsigned index, unsigned type) = 0;
		virtual void setSubType(IStatus* status, unsigned index, int subType) = 0;
		virtual void setLength(IStatus* status, unsigned index, unsigned length) = 0;
		virtual void setCharSet(IStatus* status, unsigned index, unsigned charSet) = 0;
		virtual void setScale(IStatus* status, unsigned index, unsigned scale) = 0;
		virtual void truncate(IStatus* status, unsigned count) = 0;
		virtual void moveNameToIndex(IStatus* status, const char* name, unsigned index) = 0;
		virtual void remove(IStatus* status, unsigned index) = 0;
		virtual unsigned addField(IStatus* status) = 0;
		virtual IMessageMetadata* getMetadata(IStatus* status) = 0;
	};

	template <typename Name, typename Base>
	class IResultSetBaseImpl : public Base
	{
	public:
		typedef IResultSet Declaration;

		IResultSetBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->fetchNext = &Name::cloopfetchNextDispatcher;
					this->fetchPrior = &Name::cloopfetchPriorDispatcher;
					this->fetchFirst = &Name::cloopfetchFirstDispatcher;
					this->fetchLast = &Name::cloopfetchLastDispatcher;
					this->fetchAbsolute = &Name::cloopfetchAbsoluteDispatcher;
					this->fetchRelative = &Name::cloopfetchRelativeDispatcher;
					this->isEof = &Name::cloopisEofDispatcher;
					this->isBof = &Name::cloopisBofDispatcher;
					this->getMetadata = &Name::cloopgetMetadataDispatcher;
					this->close = &Name::cloopcloseDispatcher;
					this->setDelayedOutputFormat = &Name::cloopsetDelayedOutputFormatDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static int CLOOP_CARG cloopfetchNextDispatcher(IResultSet* self, IStatus* status, void* message) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::fetchNext(status, message);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<int>(0);
			}
		}

		static int CLOOP_CARG cloopfetchPriorDispatcher(IResultSet* self, IStatus* status, void* message) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::fetchPrior(status, message);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<int>(0);
			}
		}

		static int CLOOP_CARG cloopfetchFirstDispatcher(IResultSet* self, IStatus* status, void* message) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::fetchFirst(status, message);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<int>(0);
			}
		}

		static int CLOOP_CARG cloopfetchLastDispatcher(IResultSet* self, IStatus* status, void* message) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::fetchLast(status, message);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<int>(0);
			}
		}

		static int CLOOP_CARG cloopfetchAbsoluteDispatcher(IResultSet* self, IStatus* status, unsigned position, void* message) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::fetchAbsolute(status, position, message);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<int>(0);
			}
		}

		static int CLOOP_CARG cloopfetchRelativeDispatcher(IResultSet* self, IStatus* status, int offset, void* message) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::fetchRelative(status, offset, message);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<int>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG cloopisEofDispatcher(IResultSet* self, IStatus* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::isEof(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG cloopisBofDispatcher(IResultSet* self, IStatus* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::isBof(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static IMessageMetadata* CLOOP_CARG cloopgetMetadataDispatcher(IResultSet* self, IStatus* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getMetadata(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IMessageMetadata*>(0);
			}
		}

		static void CLOOP_CARG cloopcloseDispatcher(IResultSet* self, IStatus* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::close(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopsetDelayedOutputFormatDispatcher(IResultSet* self, IStatus* status, IMessageMetadata* format) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setDelayedOutputFormat(status, format);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IReferenceCountedImpl<Name, Inherit<IVersionedImpl<Name, Inherit<IResultSet> > > > >
	class IResultSetImpl : public IResultSetBaseImpl<Name, Base>
	{
	protected:
		IResultSetImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IResultSetImpl()
		{
		}

		virtual int fetchNext(IStatus* status, void* message) = 0;
		virtual int fetchPrior(IStatus* status, void* message) = 0;
		virtual int fetchFirst(IStatus* status, void* message) = 0;
		virtual int fetchLast(IStatus* status, void* message) = 0;
		virtual int fetchAbsolute(IStatus* status, unsigned position, void* message) = 0;
		virtual int fetchRelative(IStatus* status, int offset, void* message) = 0;
		virtual FB_BOOLEAN isEof(IStatus* status) = 0;
		virtual FB_BOOLEAN isBof(IStatus* status) = 0;
		virtual IMessageMetadata* getMetadata(IStatus* status) = 0;
		virtual void close(IStatus* status) = 0;
		virtual void setDelayedOutputFormat(IStatus* status, IMessageMetadata* format) = 0;
	};

	template <typename Name, typename Base>
	class IStatementBaseImpl : public Base
	{
	public:
		typedef IStatement Declaration;

		IStatementBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->getInfo = &Name::cloopgetInfoDispatcher;
					this->getType = &Name::cloopgetTypeDispatcher;
					this->getPlan = &Name::cloopgetPlanDispatcher;
					this->getAffectedRecords = &Name::cloopgetAffectedRecordsDispatcher;
					this->getInputMetadata = &Name::cloopgetInputMetadataDispatcher;
					this->getOutputMetadata = &Name::cloopgetOutputMetadataDispatcher;
					this->execute = &Name::cloopexecuteDispatcher;
					this->openCursor = &Name::cloopopenCursorDispatcher;
					this->setCursorName = &Name::cloopsetCursorNameDispatcher;
					this->free = &Name::cloopfreeDispatcher;
					this->getFlags = &Name::cloopgetFlagsDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopgetInfoDispatcher(IStatement* self, IStatus* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::getInfo(status, itemsLength, items, bufferLength, buffer);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static unsigned CLOOP_CARG cloopgetTypeDispatcher(IStatement* self, IStatus* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getType(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<unsigned>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetPlanDispatcher(IStatement* self, IStatus* status, FB_BOOLEAN detailed) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPlan(status, detailed);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<const char*>(0);
			}
		}

		static ISC_UINT64 CLOOP_CARG cloopgetAffectedRecordsDispatcher(IStatement* self, IStatus* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getAffectedRecords(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<ISC_UINT64>(0);
			}
		}

		static IMessageMetadata* CLOOP_CARG cloopgetInputMetadataDispatcher(IStatement* self, IStatus* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getInputMetadata(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IMessageMetadata*>(0);
			}
		}

		static IMessageMetadata* CLOOP_CARG cloopgetOutputMetadataDispatcher(IStatement* self, IStatus* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOutputMetadata(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IMessageMetadata*>(0);
			}
		}

		static ITransaction* CLOOP_CARG cloopexecuteDispatcher(IStatement* self, IStatus* status, ITransaction* transaction, IMessageMetadata* inMetadata, void* inBuffer, IMessageMetadata* outMetadata, void* outBuffer) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::execute(status, transaction, inMetadata, inBuffer, outMetadata, outBuffer);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<ITransaction*>(0);
			}
		}

		static IResultSet* CLOOP_CARG cloopopenCursorDispatcher(IStatement* self, IStatus* status, ITransaction* transaction, IMessageMetadata* inMetadata, void* inBuffer, IMessageMetadata* outMetadata) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::openCursor(status, transaction, inMetadata, inBuffer, outMetadata);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IResultSet*>(0);
			}
		}

		static void CLOOP_CARG cloopsetCursorNameDispatcher(IStatement* self, IStatus* status, const char* name) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setCursorName(status, name);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopfreeDispatcher(IStatement* self, IStatus* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::free(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static unsigned CLOOP_CARG cloopgetFlagsDispatcher(IStatement* self, IStatus* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getFlags(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<unsigned>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IReferenceCountedImpl<Name, Inherit<IVersionedImpl<Name, Inherit<IStatement> > > > >
	class IStatementImpl : public IStatementBaseImpl<Name, Base>
	{
	protected:
		IStatementImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IStatementImpl()
		{
		}

		virtual void getInfo(IStatus* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) = 0;
		virtual unsigned getType(IStatus* status) = 0;
		virtual const char* getPlan(IStatus* status, FB_BOOLEAN detailed) = 0;
		virtual ISC_UINT64 getAffectedRecords(IStatus* status) = 0;
		virtual IMessageMetadata* getInputMetadata(IStatus* status) = 0;
		virtual IMessageMetadata* getOutputMetadata(IStatus* status) = 0;
		virtual ITransaction* execute(IStatus* status, ITransaction* transaction, IMessageMetadata* inMetadata, void* inBuffer, IMessageMetadata* outMetadata, void* outBuffer) = 0;
		virtual IResultSet* openCursor(IStatus* status, ITransaction* transaction, IMessageMetadata* inMetadata, void* inBuffer, IMessageMetadata* outMetadata) = 0;
		virtual void setCursorName(IStatus* status, const char* name) = 0;
		virtual void free(IStatus* status) = 0;
		virtual unsigned getFlags(IStatus* status) = 0;
	};

	template <typename Name, typename Base>
	class IRequestBaseImpl : public Base
	{
	public:
		typedef IRequest Declaration;

		IRequestBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->receive = &Name::cloopreceiveDispatcher;
					this->send = &Name::cloopsendDispatcher;
					this->getInfo = &Name::cloopgetInfoDispatcher;
					this->start = &Name::cloopstartDispatcher;
					this->startAndSend = &Name::cloopstartAndSendDispatcher;
					this->unwind = &Name::cloopunwindDispatcher;
					this->free = &Name::cloopfreeDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopreceiveDispatcher(IRequest* self, IStatus* status, int level, unsigned msgType, unsigned length, unsigned char* message) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::receive(status, level, msgType, length, message);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopsendDispatcher(IRequest* self, IStatus* status, int level, unsigned msgType, unsigned length, const unsigned char* message) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::send(status, level, msgType, length, message);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopgetInfoDispatcher(IRequest* self, IStatus* status, int level, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::getInfo(status, level, itemsLength, items, bufferLength, buffer);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopstartDispatcher(IRequest* self, IStatus* status, ITransaction* tra, int level) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::start(status, tra, level);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopstartAndSendDispatcher(IRequest* self, IStatus* status, ITransaction* tra, int level, unsigned msgType, unsigned length, const unsigned char* message) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::startAndSend(status, tra, level, msgType, length, message);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopunwindDispatcher(IRequest* self, IStatus* status, int level) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::unwind(status, level);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopfreeDispatcher(IRequest* self, IStatus* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::free(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IReferenceCountedImpl<Name, Inherit<IVersionedImpl<Name, Inherit<IRequest> > > > >
	class IRequestImpl : public IRequestBaseImpl<Name, Base>
	{
	protected:
		IRequestImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IRequestImpl()
		{
		}

		virtual void receive(IStatus* status, int level, unsigned msgType, unsigned length, unsigned char* message) = 0;
		virtual void send(IStatus* status, int level, unsigned msgType, unsigned length, const unsigned char* message) = 0;
		virtual void getInfo(IStatus* status, int level, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) = 0;
		virtual void start(IStatus* status, ITransaction* tra, int level) = 0;
		virtual void startAndSend(IStatus* status, ITransaction* tra, int level, unsigned msgType, unsigned length, const unsigned char* message) = 0;
		virtual void unwind(IStatus* status, int level) = 0;
		virtual void free(IStatus* status) = 0;
	};

	template <typename Name, typename Base>
	class IEventsBaseImpl : public Base
	{
	public:
		typedef IEvents Declaration;

		IEventsBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->cancel = &Name::cloopcancelDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopcancelDispatcher(IEvents* self, IStatus* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::cancel(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IReferenceCountedImpl<Name, Inherit<IVersionedImpl<Name, Inherit<IEvents> > > > >
	class IEventsImpl : public IEventsBaseImpl<Name, Base>
	{
	protected:
		IEventsImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IEventsImpl()
		{
		}

		virtual void cancel(IStatus* status) = 0;
	};

	template <typename Name, typename Base>
	class IAttachmentBaseImpl : public Base
	{
	public:
		typedef IAttachment Declaration;

		IAttachmentBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->getInfo = &Name::cloopgetInfoDispatcher;
					this->startTransaction = &Name::cloopstartTransactionDispatcher;
					this->reconnectTransaction = &Name::cloopreconnectTransactionDispatcher;
					this->compileRequest = &Name::cloopcompileRequestDispatcher;
					this->transactRequest = &Name::clooptransactRequestDispatcher;
					this->createBlob = &Name::cloopcreateBlobDispatcher;
					this->openBlob = &Name::cloopopenBlobDispatcher;
					this->getSlice = &Name::cloopgetSliceDispatcher;
					this->putSlice = &Name::cloopputSliceDispatcher;
					this->executeDyn = &Name::cloopexecuteDynDispatcher;
					this->prepare = &Name::cloopprepareDispatcher;
					this->execute = &Name::cloopexecuteDispatcher;
					this->openCursor = &Name::cloopopenCursorDispatcher;
					this->queEvents = &Name::cloopqueEventsDispatcher;
					this->cancelOperation = &Name::cloopcancelOperationDispatcher;
					this->ping = &Name::clooppingDispatcher;
					this->detach = &Name::cloopdetachDispatcher;
					this->dropDatabase = &Name::cloopdropDatabaseDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopgetInfoDispatcher(IAttachment* self, IStatus* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::getInfo(status, itemsLength, items, bufferLength, buffer);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static ITransaction* CLOOP_CARG cloopstartTransactionDispatcher(IAttachment* self, IStatus* status, unsigned tpbLength, const unsigned char* tpb) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::startTransaction(status, tpbLength, tpb);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<ITransaction*>(0);
			}
		}

		static ITransaction* CLOOP_CARG cloopreconnectTransactionDispatcher(IAttachment* self, IStatus* status, unsigned length, const unsigned char* id) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::reconnectTransaction(status, length, id);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<ITransaction*>(0);
			}
		}

		static IRequest* CLOOP_CARG cloopcompileRequestDispatcher(IAttachment* self, IStatus* status, unsigned blrLength, const unsigned char* blr) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::compileRequest(status, blrLength, blr);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IRequest*>(0);
			}
		}

		static void CLOOP_CARG clooptransactRequestDispatcher(IAttachment* self, IStatus* status, ITransaction* transaction, unsigned blrLength, const unsigned char* blr, unsigned inMsgLength, const unsigned char* inMsg, unsigned outMsgLength, unsigned char* outMsg) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::transactRequest(status, transaction, blrLength, blr, inMsgLength, inMsg, outMsgLength, outMsg);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static IBlob* CLOOP_CARG cloopcreateBlobDispatcher(IAttachment* self, IStatus* status, ITransaction* transaction, ISC_QUAD* id, unsigned bpbLength, const unsigned char* bpb) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::createBlob(status, transaction, id, bpbLength, bpb);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IBlob*>(0);
			}
		}

		static IBlob* CLOOP_CARG cloopopenBlobDispatcher(IAttachment* self, IStatus* status, ITransaction* transaction, ISC_QUAD* id, unsigned bpbLength, const unsigned char* bpb) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::openBlob(status, transaction, id, bpbLength, bpb);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IBlob*>(0);
			}
		}

		static int CLOOP_CARG cloopgetSliceDispatcher(IAttachment* self, IStatus* status, ITransaction* transaction, ISC_QUAD* id, unsigned sdlLength, const unsigned char* sdl, unsigned paramLength, const unsigned char* param, int sliceLength, unsigned char* slice) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getSlice(status, transaction, id, sdlLength, sdl, paramLength, param, sliceLength, slice);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<int>(0);
			}
		}

		static void CLOOP_CARG cloopputSliceDispatcher(IAttachment* self, IStatus* status, ITransaction* transaction, ISC_QUAD* id, unsigned sdlLength, const unsigned char* sdl, unsigned paramLength, const unsigned char* param, int sliceLength, unsigned char* slice) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::putSlice(status, transaction, id, sdlLength, sdl, paramLength, param, sliceLength, slice);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopexecuteDynDispatcher(IAttachment* self, IStatus* status, ITransaction* transaction, unsigned length, const unsigned char* dyn) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::executeDyn(status, transaction, length, dyn);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static IStatement* CLOOP_CARG cloopprepareDispatcher(IAttachment* self, IStatus* status, ITransaction* tra, unsigned stmtLength, const char* sqlStmt, unsigned dialect, unsigned flags) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::prepare(status, tra, stmtLength, sqlStmt, dialect, flags);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IStatement*>(0);
			}
		}

		static ITransaction* CLOOP_CARG cloopexecuteDispatcher(IAttachment* self, IStatus* status, ITransaction* transaction, unsigned stmtLength, const char* sqlStmt, unsigned dialect, IMessageMetadata* inMetadata, void* inBuffer, IMessageMetadata* outMetadata, void* outBuffer) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::execute(status, transaction, stmtLength, sqlStmt, dialect, inMetadata, inBuffer, outMetadata, outBuffer);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<ITransaction*>(0);
			}
		}

		static IResultSet* CLOOP_CARG cloopopenCursorDispatcher(IAttachment* self, IStatus* status, ITransaction* transaction, unsigned stmtLength, const char* sqlStmt, unsigned dialect, IMessageMetadata* inMetadata, void* inBuffer, IMessageMetadata* outMetadata, const char* cursorName) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::openCursor(status, transaction, stmtLength, sqlStmt, dialect, inMetadata, inBuffer, outMetadata, cursorName);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IResultSet*>(0);
			}
		}

		static IEvents* CLOOP_CARG cloopqueEventsDispatcher(IAttachment* self, IStatus* status, IEventCallback* callback, unsigned length, const unsigned char* events) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::queEvents(status, callback, length, events);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IEvents*>(0);
			}
		}

		static void CLOOP_CARG cloopcancelOperationDispatcher(IAttachment* self, IStatus* status, int option) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::cancelOperation(status, option);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG clooppingDispatcher(IAttachment* self, IStatus* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::ping(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopdetachDispatcher(IAttachment* self, IStatus* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::detach(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopdropDatabaseDispatcher(IAttachment* self, IStatus* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::dropDatabase(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IReferenceCountedImpl<Name, Inherit<IVersionedImpl<Name, Inherit<IAttachment> > > > >
	class IAttachmentImpl : public IAttachmentBaseImpl<Name, Base>
	{
	protected:
		IAttachmentImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IAttachmentImpl()
		{
		}

		virtual void getInfo(IStatus* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) = 0;
		virtual ITransaction* startTransaction(IStatus* status, unsigned tpbLength, const unsigned char* tpb) = 0;
		virtual ITransaction* reconnectTransaction(IStatus* status, unsigned length, const unsigned char* id) = 0;
		virtual IRequest* compileRequest(IStatus* status, unsigned blrLength, const unsigned char* blr) = 0;
		virtual void transactRequest(IStatus* status, ITransaction* transaction, unsigned blrLength, const unsigned char* blr, unsigned inMsgLength, const unsigned char* inMsg, unsigned outMsgLength, unsigned char* outMsg) = 0;
		virtual IBlob* createBlob(IStatus* status, ITransaction* transaction, ISC_QUAD* id, unsigned bpbLength, const unsigned char* bpb) = 0;
		virtual IBlob* openBlob(IStatus* status, ITransaction* transaction, ISC_QUAD* id, unsigned bpbLength, const unsigned char* bpb) = 0;
		virtual int getSlice(IStatus* status, ITransaction* transaction, ISC_QUAD* id, unsigned sdlLength, const unsigned char* sdl, unsigned paramLength, const unsigned char* param, int sliceLength, unsigned char* slice) = 0;
		virtual void putSlice(IStatus* status, ITransaction* transaction, ISC_QUAD* id, unsigned sdlLength, const unsigned char* sdl, unsigned paramLength, const unsigned char* param, int sliceLength, unsigned char* slice) = 0;
		virtual void executeDyn(IStatus* status, ITransaction* transaction, unsigned length, const unsigned char* dyn) = 0;
		virtual IStatement* prepare(IStatus* status, ITransaction* tra, unsigned stmtLength, const char* sqlStmt, unsigned dialect, unsigned flags) = 0;
		virtual ITransaction* execute(IStatus* status, ITransaction* transaction, unsigned stmtLength, const char* sqlStmt, unsigned dialect, IMessageMetadata* inMetadata, void* inBuffer, IMessageMetadata* outMetadata, void* outBuffer) = 0;
		virtual IResultSet* openCursor(IStatus* status, ITransaction* transaction, unsigned stmtLength, const char* sqlStmt, unsigned dialect, IMessageMetadata* inMetadata, void* inBuffer, IMessageMetadata* outMetadata, const char* cursorName) = 0;
		virtual IEvents* queEvents(IStatus* status, IEventCallback* callback, unsigned length, const unsigned char* events) = 0;
		virtual void cancelOperation(IStatus* status, int option) = 0;
		virtual void ping(IStatus* status) = 0;
		virtual void detach(IStatus* status) = 0;
		virtual void dropDatabase(IStatus* status) = 0;
	};

	template <typename Name, typename Base>
	class IServiceBaseImpl : public Base
	{
	public:
		typedef IService Declaration;

		IServiceBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->detach = &Name::cloopdetachDispatcher;
					this->query = &Name::cloopqueryDispatcher;
					this->start = &Name::cloopstartDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopdetachDispatcher(IService* self, IStatus* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::detach(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopqueryDispatcher(IService* self, IStatus* status, unsigned sendLength, const unsigned char* sendItems, unsigned receiveLength, const unsigned char* receiveItems, unsigned bufferLength, unsigned char* buffer) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::query(status, sendLength, sendItems, receiveLength, receiveItems, bufferLength, buffer);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopstartDispatcher(IService* self, IStatus* status, unsigned spbLength, const unsigned char* spb) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::start(status, spbLength, spb);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IReferenceCountedImpl<Name, Inherit<IVersionedImpl<Name, Inherit<IService> > > > >
	class IServiceImpl : public IServiceBaseImpl<Name, Base>
	{
	protected:
		IServiceImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IServiceImpl()
		{
		}

		virtual void detach(IStatus* status) = 0;
		virtual void query(IStatus* status, unsigned sendLength, const unsigned char* sendItems, unsigned receiveLength, const unsigned char* receiveItems, unsigned bufferLength, unsigned char* buffer) = 0;
		virtual void start(IStatus* status, unsigned spbLength, const unsigned char* spb) = 0;
	};

	template <typename Name, typename Base>
	class IProviderBaseImpl : public Base
	{
	public:
		typedef IProvider Declaration;

		IProviderBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->setOwner = &Name::cloopsetOwnerDispatcher;
					this->getOwner = &Name::cloopgetOwnerDispatcher;
					this->attachDatabase = &Name::cloopattachDatabaseDispatcher;
					this->createDatabase = &Name::cloopcreateDatabaseDispatcher;
					this->attachServiceManager = &Name::cloopattachServiceManagerDispatcher;
					this->shutdown = &Name::cloopshutdownDispatcher;
					this->setDbCryptCallback = &Name::cloopsetDbCryptCallbackDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static IAttachment* CLOOP_CARG cloopattachDatabaseDispatcher(IProvider* self, IStatus* status, const char* fileName, unsigned dpbLength, const unsigned char* dpb) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::attachDatabase(status, fileName, dpbLength, dpb);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IAttachment*>(0);
			}
		}

		static IAttachment* CLOOP_CARG cloopcreateDatabaseDispatcher(IProvider* self, IStatus* status, const char* fileName, unsigned dpbLength, const unsigned char* dpb) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::createDatabase(status, fileName, dpbLength, dpb);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IAttachment*>(0);
			}
		}

		static IService* CLOOP_CARG cloopattachServiceManagerDispatcher(IProvider* self, IStatus* status, const char* service, unsigned spbLength, const unsigned char* spb) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::attachServiceManager(status, service, spbLength, spb);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IService*>(0);
			}
		}

		static void CLOOP_CARG cloopshutdownDispatcher(IProvider* self, IStatus* status, unsigned timeout, const int reason) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::shutdown(status, timeout, reason);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopsetDbCryptCallbackDispatcher(IProvider* self, IStatus* status, ICryptKeyCallback* cryptCallback) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setDbCryptCallback(status, cryptCallback);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopsetOwnerDispatcher(IPluginBase* self, IReferenceCounted* r) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setOwner(r);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static IReferenceCounted* CLOOP_CARG cloopgetOwnerDispatcher(IPluginBase* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOwner();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IReferenceCounted*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IPluginBaseImpl<Name, Inherit<IReferenceCountedImpl<Name, Inherit<IVersionedImpl<Name, Inherit<IProvider> > > > > > >
	class IProviderImpl : public IProviderBaseImpl<Name, Base>
	{
	protected:
		IProviderImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IProviderImpl()
		{
		}

		virtual IAttachment* attachDatabase(IStatus* status, const char* fileName, unsigned dpbLength, const unsigned char* dpb) = 0;
		virtual IAttachment* createDatabase(IStatus* status, const char* fileName, unsigned dpbLength, const unsigned char* dpb) = 0;
		virtual IService* attachServiceManager(IStatus* status, const char* service, unsigned spbLength, const unsigned char* spb) = 0;
		virtual void shutdown(IStatus* status, unsigned timeout, const int reason) = 0;
		virtual void setDbCryptCallback(IStatus* status, ICryptKeyCallback* cryptCallback) = 0;
	};

	template <typename Name, typename Base>
	class IDtcStartBaseImpl : public Base
	{
	public:
		typedef IDtcStart Declaration;

		IDtcStartBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->dispose = &Name::cloopdisposeDispatcher;
					this->setComponent = &Name::cloopsetComponentDispatcher;
					this->setWithParam = &Name::cloopsetWithParamDispatcher;
					this->getCount = &Name::cloopgetCountDispatcher;
					this->getAttachment = &Name::cloopgetAttachmentDispatcher;
					this->getTpb = &Name::cloopgetTpbDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopsetComponentDispatcher(IDtcStart* self, IStatus* status, IAttachment* att) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setComponent(status, att);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopsetWithParamDispatcher(IDtcStart* self, IStatus* status, IAttachment* att, unsigned length, const unsigned char* tpb) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setWithParam(status, att, length, tpb);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static unsigned CLOOP_CARG cloopgetCountDispatcher(IDtcStart* self, IStatus* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getCount(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<unsigned>(0);
			}
		}

		static IAttachment* CLOOP_CARG cloopgetAttachmentDispatcher(IDtcStart* self, IStatus* status, unsigned pos) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getAttachment(status, pos);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IAttachment*>(0);
			}
		}

		static const unsigned char* CLOOP_CARG cloopgetTpbDispatcher(IDtcStart* self, IStatus* status, unsigned pos, unsigned* length) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getTpb(status, pos, length);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<const unsigned char*>(0);
			}
		}

		static void CLOOP_CARG cloopdisposeDispatcher(IDisposable* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::dispose();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IDisposableImpl<Name, Inherit<IVersionedImpl<Name, Inherit<IDtcStart> > > > >
	class IDtcStartImpl : public IDtcStartBaseImpl<Name, Base>
	{
	protected:
		IDtcStartImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IDtcStartImpl()
		{
		}

		virtual void setComponent(IStatus* status, IAttachment* att) = 0;
		virtual void setWithParam(IStatus* status, IAttachment* att, unsigned length, const unsigned char* tpb) = 0;
		virtual unsigned getCount(IStatus* status) = 0;
		virtual IAttachment* getAttachment(IStatus* status, unsigned pos) = 0;
		virtual const unsigned char* getTpb(IStatus* status, unsigned pos, unsigned* length) = 0;
	};

	template <typename Name, typename Base>
	class IDtcBaseImpl : public Base
	{
	public:
		typedef IDtc Declaration;

		IDtcBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->start = &Name::cloopstartDispatcher;
					this->join = &Name::cloopjoinDispatcher;
					this->startBuilder = &Name::cloopstartBuilderDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static ITransaction* CLOOP_CARG cloopstartDispatcher(IDtc* self, IStatus* status, IDtcStart* components) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::start(status, components);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<ITransaction*>(0);
			}
		}

		static ITransaction* CLOOP_CARG cloopjoinDispatcher(IDtc* self, IStatus* status, ITransaction* one, ITransaction* two) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::join(status, one, two);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<ITransaction*>(0);
			}
		}

		static IDtcStart* CLOOP_CARG cloopstartBuilderDispatcher(IDtc* self, IStatus* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::startBuilder(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IDtcStart*>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IVersionedImpl<Name, Inherit<IDtc> > >
	class IDtcImpl : public IDtcBaseImpl<Name, Base>
	{
	protected:
		IDtcImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IDtcImpl()
		{
		}

		virtual ITransaction* start(IStatus* status, IDtcStart* components) = 0;
		virtual ITransaction* join(IStatus* status, ITransaction* one, ITransaction* two) = 0;
		virtual IDtcStart* startBuilder(IStatus* status) = 0;
	};

	template <typename Name, typename Base>
	class IAuthBaseImpl : public Base
	{
	public:
		typedef IAuth Declaration;

		IAuthBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->setOwner = &Name::cloopsetOwnerDispatcher;
					this->getOwner = &Name::cloopgetOwnerDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopsetOwnerDispatcher(IPluginBase* self, IReferenceCounted* r) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setOwner(r);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static IReferenceCounted* CLOOP_CARG cloopgetOwnerDispatcher(IPluginBase* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOwner();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IReferenceCounted*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IPluginBaseImpl<Name, Inherit<IReferenceCountedImpl<Name, Inherit<IVersionedImpl<Name, Inherit<IAuth> > > > > > >
	class IAuthImpl : public IAuthBaseImpl<Name, Base>
	{
	protected:
		IAuthImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IAuthImpl()
		{
		}

	};

	template <typename Name, typename Base>
	class IWriterBaseImpl : public Base
	{
	public:
		typedef IWriter Declaration;

		IWriterBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->reset = &Name::cloopresetDispatcher;
					this->add = &Name::cloopaddDispatcher;
					this->setType = &Name::cloopsetTypeDispatcher;
					this->setDb = &Name::cloopsetDbDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopresetDispatcher(IWriter* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::reset();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static void CLOOP_CARG cloopaddDispatcher(IWriter* self, IStatus* status, const char* name) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::add(status, name);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopsetTypeDispatcher(IWriter* self, IStatus* status, const char* value) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setType(status, value);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopsetDbDispatcher(IWriter* self, IStatus* status, const char* value) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setDb(status, value);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IVersionedImpl<Name, Inherit<IWriter> > >
	class IWriterImpl : public IWriterBaseImpl<Name, Base>
	{
	protected:
		IWriterImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IWriterImpl()
		{
		}

		virtual void reset() = 0;
		virtual void add(IStatus* status, const char* name) = 0;
		virtual void setType(IStatus* status, const char* value) = 0;
		virtual void setDb(IStatus* status, const char* value) = 0;
	};

	template <typename Name, typename Base>
	class IServerBlockBaseImpl : public Base
	{
	public:
		typedef IServerBlock Declaration;

		IServerBlockBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getLogin = &Name::cloopgetLoginDispatcher;
					this->getData = &Name::cloopgetDataDispatcher;
					this->putData = &Name::cloopputDataDispatcher;
					this->putKey = &Name::cloopputKeyDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetLoginDispatcher(IServerBlock* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getLogin();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const unsigned char* CLOOP_CARG cloopgetDataDispatcher(IServerBlock* self, unsigned* length) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getData(length);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const unsigned char*>(0);
			}
		}

		static void CLOOP_CARG cloopputDataDispatcher(IServerBlock* self, IStatus* status, unsigned length, const void* data) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::putData(status, length, data);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopputKeyDispatcher(IServerBlock* self, IStatus* status, FbCryptKey* cryptKey) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::putKey(status, cryptKey);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IVersionedImpl<Name, Inherit<IServerBlock> > >
	class IServerBlockImpl : public IServerBlockBaseImpl<Name, Base>
	{
	protected:
		IServerBlockImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IServerBlockImpl()
		{
		}

		virtual const char* getLogin() = 0;
		virtual const unsigned char* getData(unsigned* length) = 0;
		virtual void putData(IStatus* status, unsigned length, const void* data) = 0;
		virtual void putKey(IStatus* status, FbCryptKey* cryptKey) = 0;
	};

	template <typename Name, typename Base>
	class IClientBlockBaseImpl : public Base
	{
	public:
		typedef IClientBlock Declaration;

		IClientBlockBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->getLogin = &Name::cloopgetLoginDispatcher;
					this->getPassword = &Name::cloopgetPasswordDispatcher;
					this->getData = &Name::cloopgetDataDispatcher;
					this->putData = &Name::cloopputDataDispatcher;
					this->putKey = &Name::cloopputKeyDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetLoginDispatcher(IClientBlock* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getLogin();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetPasswordDispatcher(IClientBlock* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPassword();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const unsigned char* CLOOP_CARG cloopgetDataDispatcher(IClientBlock* self, unsigned* length) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getData(length);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const unsigned char*>(0);
			}
		}

		static void CLOOP_CARG cloopputDataDispatcher(IClientBlock* self, IStatus* status, unsigned length, const void* data) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::putData(status, length, data);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopputKeyDispatcher(IClientBlock* self, IStatus* status, FbCryptKey* cryptKey) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::putKey(status, cryptKey);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IReferenceCountedImpl<Name, Inherit<IVersionedImpl<Name, Inherit<IClientBlock> > > > >
	class IClientBlockImpl : public IClientBlockBaseImpl<Name, Base>
	{
	protected:
		IClientBlockImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IClientBlockImpl()
		{
		}

		virtual const char* getLogin() = 0;
		virtual const char* getPassword() = 0;
		virtual const unsigned char* getData(unsigned* length) = 0;
		virtual void putData(IStatus* status, unsigned length, const void* data) = 0;
		virtual void putKey(IStatus* status, FbCryptKey* cryptKey) = 0;
	};

	template <typename Name, typename Base>
	class IServerBaseImpl : public Base
	{
	public:
		typedef IServer Declaration;

		IServerBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->setOwner = &Name::cloopsetOwnerDispatcher;
					this->getOwner = &Name::cloopgetOwnerDispatcher;
					this->authenticate = &Name::cloopauthenticateDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static int CLOOP_CARG cloopauthenticateDispatcher(IServer* self, IStatus* status, IServerBlock* sBlock, IWriter* writerInterface) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::authenticate(status, sBlock, writerInterface);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<int>(0);
			}
		}

		static void CLOOP_CARG cloopsetOwnerDispatcher(IPluginBase* self, IReferenceCounted* r) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setOwner(r);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static IReferenceCounted* CLOOP_CARG cloopgetOwnerDispatcher(IPluginBase* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOwner();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IReferenceCounted*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IAuthImpl<Name, Inherit<IPluginBaseImpl<Name, Inherit<IReferenceCountedImpl<Name, Inherit<IVersionedImpl<Name, Inherit<IServer> > > > > > > > >
	class IServerImpl : public IServerBaseImpl<Name, Base>
	{
	protected:
		IServerImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IServerImpl()
		{
		}

		virtual int authenticate(IStatus* status, IServerBlock* sBlock, IWriter* writerInterface) = 0;
	};

	template <typename Name, typename Base>
	class IClientBaseImpl : public Base
	{
	public:
		typedef IClient Declaration;

		IClientBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->setOwner = &Name::cloopsetOwnerDispatcher;
					this->getOwner = &Name::cloopgetOwnerDispatcher;
					this->authenticate = &Name::cloopauthenticateDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static int CLOOP_CARG cloopauthenticateDispatcher(IClient* self, IStatus* status, IClientBlock* cBlock) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::authenticate(status, cBlock);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<int>(0);
			}
		}

		static void CLOOP_CARG cloopsetOwnerDispatcher(IPluginBase* self, IReferenceCounted* r) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setOwner(r);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static IReferenceCounted* CLOOP_CARG cloopgetOwnerDispatcher(IPluginBase* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOwner();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IReferenceCounted*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IAuthImpl<Name, Inherit<IPluginBaseImpl<Name, Inherit<IReferenceCountedImpl<Name, Inherit<IVersionedImpl<Name, Inherit<IClient> > > > > > > > >
	class IClientImpl : public IClientBaseImpl<Name, Base>
	{
	protected:
		IClientImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IClientImpl()
		{
		}

		virtual int authenticate(IStatus* status, IClientBlock* cBlock) = 0;
	};

	template <typename Name, typename Base>
	class IUserFieldBaseImpl : public Base
	{
	public:
		typedef IUserField Declaration;

		IUserFieldBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->entered = &Name::cloopenteredDispatcher;
					this->specified = &Name::cloopspecifiedDispatcher;
					this->setEntered = &Name::cloopsetEnteredDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static int CLOOP_CARG cloopenteredDispatcher(IUserField* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::entered();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static int CLOOP_CARG cloopspecifiedDispatcher(IUserField* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::specified();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static void CLOOP_CARG cloopsetEnteredDispatcher(IUserField* self, IStatus* status, int newValue) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setEntered(status, newValue);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IVersionedImpl<Name, Inherit<IUserField> > >
	class IUserFieldImpl : public IUserFieldBaseImpl<Name, Base>
	{
	protected:
		IUserFieldImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IUserFieldImpl()
		{
		}

		virtual int entered() = 0;
		virtual int specified() = 0;
		virtual void setEntered(IStatus* status, int newValue) = 0;
	};

	template <typename Name, typename Base>
	class ICharUserFieldBaseImpl : public Base
	{
	public:
		typedef ICharUserField Declaration;

		ICharUserFieldBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->entered = &Name::cloopenteredDispatcher;
					this->specified = &Name::cloopspecifiedDispatcher;
					this->setEntered = &Name::cloopsetEnteredDispatcher;
					this->get = &Name::cloopgetDispatcher;
					this->set = &Name::cloopsetDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetDispatcher(ICharUserField* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::get();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static void CLOOP_CARG cloopsetDispatcher(ICharUserField* self, IStatus* status, const char* newValue) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::set(status, newValue);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static int CLOOP_CARG cloopenteredDispatcher(IUserField* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::entered();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static int CLOOP_CARG cloopspecifiedDispatcher(IUserField* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::specified();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static void CLOOP_CARG cloopsetEnteredDispatcher(IUserField* self, IStatus* status, int newValue) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setEntered(status, newValue);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IUserFieldImpl<Name, Inherit<IVersionedImpl<Name, Inherit<ICharUserField> > > > >
	class ICharUserFieldImpl : public ICharUserFieldBaseImpl<Name, Base>
	{
	protected:
		ICharUserFieldImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ICharUserFieldImpl()
		{
		}

		virtual const char* get() = 0;
		virtual void set(IStatus* status, const char* newValue) = 0;
	};

	template <typename Name, typename Base>
	class IIntUserFieldBaseImpl : public Base
	{
	public:
		typedef IIntUserField Declaration;

		IIntUserFieldBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->entered = &Name::cloopenteredDispatcher;
					this->specified = &Name::cloopspecifiedDispatcher;
					this->setEntered = &Name::cloopsetEnteredDispatcher;
					this->get = &Name::cloopgetDispatcher;
					this->set = &Name::cloopsetDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static int CLOOP_CARG cloopgetDispatcher(IIntUserField* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::get();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static void CLOOP_CARG cloopsetDispatcher(IIntUserField* self, IStatus* status, int newValue) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::set(status, newValue);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static int CLOOP_CARG cloopenteredDispatcher(IUserField* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::entered();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static int CLOOP_CARG cloopspecifiedDispatcher(IUserField* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::specified();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static void CLOOP_CARG cloopsetEnteredDispatcher(IUserField* self, IStatus* status, int newValue) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setEntered(status, newValue);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IUserFieldImpl<Name, Inherit<IVersionedImpl<Name, Inherit<IIntUserField> > > > >
	class IIntUserFieldImpl : public IIntUserFieldBaseImpl<Name, Base>
	{
	protected:
		IIntUserFieldImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IIntUserFieldImpl()
		{
		}

		virtual int get() = 0;
		virtual void set(IStatus* status, int newValue) = 0;
	};

	template <typename Name, typename Base>
	class IUserBaseImpl : public Base
	{
	public:
		typedef IUser Declaration;

		IUserBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->operation = &Name::cloopoperationDispatcher;
					this->userName = &Name::cloopuserNameDispatcher;
					this->password = &Name::clooppasswordDispatcher;
					this->firstName = &Name::cloopfirstNameDispatcher;
					this->lastName = &Name::clooplastNameDispatcher;
					this->middleName = &Name::cloopmiddleNameDispatcher;
					this->comment = &Name::cloopcommentDispatcher;
					this->attributes = &Name::cloopattributesDispatcher;
					this->active = &Name::cloopactiveDispatcher;
					this->admin = &Name::cloopadminDispatcher;
					this->clear = &Name::cloopclearDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static int CLOOP_CARG cloopoperationDispatcher(IUser* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::operation();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static ICharUserField* CLOOP_CARG cloopuserNameDispatcher(IUser* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::userName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ICharUserField*>(0);
			}
		}

		static ICharUserField* CLOOP_CARG clooppasswordDispatcher(IUser* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::password();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ICharUserField*>(0);
			}
		}

		static ICharUserField* CLOOP_CARG cloopfirstNameDispatcher(IUser* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::firstName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ICharUserField*>(0);
			}
		}

		static ICharUserField* CLOOP_CARG clooplastNameDispatcher(IUser* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::lastName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ICharUserField*>(0);
			}
		}

		static ICharUserField* CLOOP_CARG cloopmiddleNameDispatcher(IUser* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::middleName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ICharUserField*>(0);
			}
		}

		static ICharUserField* CLOOP_CARG cloopcommentDispatcher(IUser* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::comment();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ICharUserField*>(0);
			}
		}

		static ICharUserField* CLOOP_CARG cloopattributesDispatcher(IUser* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::attributes();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ICharUserField*>(0);
			}
		}

		static IIntUserField* CLOOP_CARG cloopactiveDispatcher(IUser* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::active();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IIntUserField*>(0);
			}
		}

		static IIntUserField* CLOOP_CARG cloopadminDispatcher(IUser* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::admin();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IIntUserField*>(0);
			}
		}

		static void CLOOP_CARG cloopclearDispatcher(IUser* self, IStatus* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::clear(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IVersionedImpl<Name, Inherit<IUser> > >
	class IUserImpl : public IUserBaseImpl<Name, Base>
	{
	protected:
		IUserImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IUserImpl()
		{
		}

		virtual int operation() = 0;
		virtual ICharUserField* userName() = 0;
		virtual ICharUserField* password() = 0;
		virtual ICharUserField* firstName() = 0;
		virtual ICharUserField* lastName() = 0;
		virtual ICharUserField* middleName() = 0;
		virtual ICharUserField* comment() = 0;
		virtual ICharUserField* attributes() = 0;
		virtual IIntUserField* active() = 0;
		virtual IIntUserField* admin() = 0;
		virtual void clear(IStatus* status) = 0;
	};

	template <typename Name, typename Base>
	class IListUsersBaseImpl : public Base
	{
	public:
		typedef IListUsers Declaration;

		IListUsersBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->list = &Name::clooplistDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG clooplistDispatcher(IListUsers* self, IStatus* status, IUser* user) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::list(status, user);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IVersionedImpl<Name, Inherit<IListUsers> > >
	class IListUsersImpl : public IListUsersBaseImpl<Name, Base>
	{
	protected:
		IListUsersImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IListUsersImpl()
		{
		}

		virtual void list(IStatus* status, IUser* user) = 0;
	};

	template <typename Name, typename Base>
	class ILogonInfoBaseImpl : public Base
	{
	public:
		typedef ILogonInfo Declaration;

		ILogonInfoBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->name = &Name::cloopnameDispatcher;
					this->role = &Name::clooproleDispatcher;
					this->networkProtocol = &Name::cloopnetworkProtocolDispatcher;
					this->remoteAddress = &Name::cloopremoteAddressDispatcher;
					this->authBlock = &Name::cloopauthBlockDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopnameDispatcher(ILogonInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::name();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG clooproleDispatcher(ILogonInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::role();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopnetworkProtocolDispatcher(ILogonInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::networkProtocol();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopremoteAddressDispatcher(ILogonInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::remoteAddress();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const unsigned char* CLOOP_CARG cloopauthBlockDispatcher(ILogonInfo* self, unsigned* length) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::authBlock(length);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const unsigned char*>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IVersionedImpl<Name, Inherit<ILogonInfo> > >
	class ILogonInfoImpl : public ILogonInfoBaseImpl<Name, Base>
	{
	protected:
		ILogonInfoImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ILogonInfoImpl()
		{
		}

		virtual const char* name() = 0;
		virtual const char* role() = 0;
		virtual const char* networkProtocol() = 0;
		virtual const char* remoteAddress() = 0;
		virtual const unsigned char* authBlock(unsigned* length) = 0;
	};

	template <typename Name, typename Base>
	class IManagementBaseImpl : public Base
	{
	public:
		typedef IManagement Declaration;

		IManagementBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->setOwner = &Name::cloopsetOwnerDispatcher;
					this->getOwner = &Name::cloopgetOwnerDispatcher;
					this->start = &Name::cloopstartDispatcher;
					this->execute = &Name::cloopexecuteDispatcher;
					this->commit = &Name::cloopcommitDispatcher;
					this->rollback = &Name::clooprollbackDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopstartDispatcher(IManagement* self, IStatus* status, ILogonInfo* logonInfo) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::start(status, logonInfo);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static int CLOOP_CARG cloopexecuteDispatcher(IManagement* self, IStatus* status, IUser* user, IListUsers* callback) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::execute(status, user, callback);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<int>(0);
			}
		}

		static void CLOOP_CARG cloopcommitDispatcher(IManagement* self, IStatus* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::commit(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG clooprollbackDispatcher(IManagement* self, IStatus* status) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::rollback(status);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopsetOwnerDispatcher(IPluginBase* self, IReferenceCounted* r) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setOwner(r);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static IReferenceCounted* CLOOP_CARG cloopgetOwnerDispatcher(IPluginBase* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOwner();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IReferenceCounted*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IPluginBaseImpl<Name, Inherit<IReferenceCountedImpl<Name, Inherit<IVersionedImpl<Name, Inherit<IManagement> > > > > > >
	class IManagementImpl : public IManagementBaseImpl<Name, Base>
	{
	protected:
		IManagementImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IManagementImpl()
		{
		}

		virtual void start(IStatus* status, ILogonInfo* logonInfo) = 0;
		virtual int execute(IStatus* status, IUser* user, IListUsers* callback) = 0;
		virtual void commit(IStatus* status) = 0;
		virtual void rollback(IStatus* status) = 0;
	};

	template <typename Name, typename Base>
	class IWireCryptPluginBaseImpl : public Base
	{
	public:
		typedef IWireCryptPlugin Declaration;

		IWireCryptPluginBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->setOwner = &Name::cloopsetOwnerDispatcher;
					this->getOwner = &Name::cloopgetOwnerDispatcher;
					this->getKnownTypes = &Name::cloopgetKnownTypesDispatcher;
					this->setKey = &Name::cloopsetKeyDispatcher;
					this->encrypt = &Name::cloopencryptDispatcher;
					this->decrypt = &Name::cloopdecryptDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetKnownTypesDispatcher(IWireCryptPlugin* self, IStatus* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getKnownTypes(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<const char*>(0);
			}
		}

		static void CLOOP_CARG cloopsetKeyDispatcher(IWireCryptPlugin* self, IStatus* status, FbCryptKey* key) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setKey(status, key);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopencryptDispatcher(IWireCryptPlugin* self, IStatus* status, unsigned length, const void* from, void* to) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::encrypt(status, length, from, to);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopdecryptDispatcher(IWireCryptPlugin* self, IStatus* status, unsigned length, const void* from, void* to) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::decrypt(status, length, from, to);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopsetOwnerDispatcher(IPluginBase* self, IReferenceCounted* r) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setOwner(r);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static IReferenceCounted* CLOOP_CARG cloopgetOwnerDispatcher(IPluginBase* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOwner();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IReferenceCounted*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IPluginBaseImpl<Name, Inherit<IReferenceCountedImpl<Name, Inherit<IVersionedImpl<Name, Inherit<IWireCryptPlugin> > > > > > >
	class IWireCryptPluginImpl : public IWireCryptPluginBaseImpl<Name, Base>
	{
	protected:
		IWireCryptPluginImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IWireCryptPluginImpl()
		{
		}

		virtual const char* getKnownTypes(IStatus* status) = 0;
		virtual void setKey(IStatus* status, FbCryptKey* key) = 0;
		virtual void encrypt(IStatus* status, unsigned length, const void* from, void* to) = 0;
		virtual void decrypt(IStatus* status, unsigned length, const void* from, void* to) = 0;
	};

	template <typename Name, typename Base>
	class ICryptKeyCallbackBaseImpl : public Base
	{
	public:
		typedef ICryptKeyCallback Declaration;

		ICryptKeyCallbackBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->callback = &Name::cloopcallbackDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static unsigned CLOOP_CARG cloopcallbackDispatcher(ICryptKeyCallback* self, unsigned dataLength, const void* data, unsigned bufferLength, void* buffer) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::callback(dataLength, data, bufferLength, buffer);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IVersionedImpl<Name, Inherit<ICryptKeyCallback> > >
	class ICryptKeyCallbackImpl : public ICryptKeyCallbackBaseImpl<Name, Base>
	{
	protected:
		ICryptKeyCallbackImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ICryptKeyCallbackImpl()
		{
		}

		virtual unsigned callback(unsigned dataLength, const void* data, unsigned bufferLength, void* buffer) = 0;
	};

	template <typename Name, typename Base>
	class IKeyHolderPluginBaseImpl : public Base
	{
	public:
		typedef IKeyHolderPlugin Declaration;

		IKeyHolderPluginBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->setOwner = &Name::cloopsetOwnerDispatcher;
					this->getOwner = &Name::cloopgetOwnerDispatcher;
					this->keyCallback = &Name::cloopkeyCallbackDispatcher;
					this->keyHandle = &Name::cloopkeyHandleDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static int CLOOP_CARG cloopkeyCallbackDispatcher(IKeyHolderPlugin* self, IStatus* status, ICryptKeyCallback* callback) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::keyCallback(status, callback);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<int>(0);
			}
		}

		static ICryptKeyCallback* CLOOP_CARG cloopkeyHandleDispatcher(IKeyHolderPlugin* self, IStatus* status, const char* keyName) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::keyHandle(status, keyName);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<ICryptKeyCallback*>(0);
			}
		}

		static void CLOOP_CARG cloopsetOwnerDispatcher(IPluginBase* self, IReferenceCounted* r) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setOwner(r);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static IReferenceCounted* CLOOP_CARG cloopgetOwnerDispatcher(IPluginBase* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOwner();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IReferenceCounted*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IPluginBaseImpl<Name, Inherit<IReferenceCountedImpl<Name, Inherit<IVersionedImpl<Name, Inherit<IKeyHolderPlugin> > > > > > >
	class IKeyHolderPluginImpl : public IKeyHolderPluginBaseImpl<Name, Base>
	{
	protected:
		IKeyHolderPluginImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IKeyHolderPluginImpl()
		{
		}

		virtual int keyCallback(IStatus* status, ICryptKeyCallback* callback) = 0;
		virtual ICryptKeyCallback* keyHandle(IStatus* status, const char* keyName) = 0;
	};

	template <typename Name, typename Base>
	class IDbCryptPluginBaseImpl : public Base
	{
	public:
		typedef IDbCryptPlugin Declaration;

		IDbCryptPluginBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->setOwner = &Name::cloopsetOwnerDispatcher;
					this->getOwner = &Name::cloopgetOwnerDispatcher;
					this->setKey = &Name::cloopsetKeyDispatcher;
					this->encrypt = &Name::cloopencryptDispatcher;
					this->decrypt = &Name::cloopdecryptDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopsetKeyDispatcher(IDbCryptPlugin* self, IStatus* status, unsigned length, IKeyHolderPlugin** sources) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setKey(status, length, sources);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopencryptDispatcher(IDbCryptPlugin* self, IStatus* status, unsigned length, const void* from, void* to) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::encrypt(status, length, from, to);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopdecryptDispatcher(IDbCryptPlugin* self, IStatus* status, unsigned length, const void* from, void* to) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::decrypt(status, length, from, to);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopsetOwnerDispatcher(IPluginBase* self, IReferenceCounted* r) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setOwner(r);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static IReferenceCounted* CLOOP_CARG cloopgetOwnerDispatcher(IPluginBase* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOwner();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IReferenceCounted*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IPluginBaseImpl<Name, Inherit<IReferenceCountedImpl<Name, Inherit<IVersionedImpl<Name, Inherit<IDbCryptPlugin> > > > > > >
	class IDbCryptPluginImpl : public IDbCryptPluginBaseImpl<Name, Base>
	{
	protected:
		IDbCryptPluginImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IDbCryptPluginImpl()
		{
		}

		virtual void setKey(IStatus* status, unsigned length, IKeyHolderPlugin** sources) = 0;
		virtual void encrypt(IStatus* status, unsigned length, const void* from, void* to) = 0;
		virtual void decrypt(IStatus* status, unsigned length, const void* from, void* to) = 0;
	};

	template <typename Name, typename Base>
	class IExternalContextBaseImpl : public Base
	{
	public:
		typedef IExternalContext Declaration;

		IExternalContextBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getMaster = &Name::cloopgetMasterDispatcher;
					this->getEngine = &Name::cloopgetEngineDispatcher;
					this->getAttachment = &Name::cloopgetAttachmentDispatcher;
					this->getTransaction = &Name::cloopgetTransactionDispatcher;
					this->getUserName = &Name::cloopgetUserNameDispatcher;
					this->getDatabaseName = &Name::cloopgetDatabaseNameDispatcher;
					this->getClientCharSet = &Name::cloopgetClientCharSetDispatcher;
					this->obtainInfoCode = &Name::cloopobtainInfoCodeDispatcher;
					this->getInfo = &Name::cloopgetInfoDispatcher;
					this->setInfo = &Name::cloopsetInfoDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static IMaster* CLOOP_CARG cloopgetMasterDispatcher(IExternalContext* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getMaster();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IMaster*>(0);
			}
		}

		static IExternalEngine* CLOOP_CARG cloopgetEngineDispatcher(IExternalContext* self, IStatus* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getEngine(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IExternalEngine*>(0);
			}
		}

		static IAttachment* CLOOP_CARG cloopgetAttachmentDispatcher(IExternalContext* self, IStatus* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getAttachment(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IAttachment*>(0);
			}
		}

		static ITransaction* CLOOP_CARG cloopgetTransactionDispatcher(IExternalContext* self, IStatus* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getTransaction(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<ITransaction*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetUserNameDispatcher(IExternalContext* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getUserName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetDatabaseNameDispatcher(IExternalContext* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getDatabaseName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetClientCharSetDispatcher(IExternalContext* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getClientCharSet();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static int CLOOP_CARG cloopobtainInfoCodeDispatcher(IExternalContext* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::obtainInfoCode();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static void* CLOOP_CARG cloopgetInfoDispatcher(IExternalContext* self, int code) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getInfo(code);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<void*>(0);
			}
		}

		static void* CLOOP_CARG cloopsetInfoDispatcher(IExternalContext* self, int code, void* value) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::setInfo(code, value);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<void*>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IVersionedImpl<Name, Inherit<IExternalContext> > >
	class IExternalContextImpl : public IExternalContextBaseImpl<Name, Base>
	{
	protected:
		IExternalContextImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IExternalContextImpl()
		{
		}

		virtual IMaster* getMaster() = 0;
		virtual IExternalEngine* getEngine(IStatus* status) = 0;
		virtual IAttachment* getAttachment(IStatus* status) = 0;
		virtual ITransaction* getTransaction(IStatus* status) = 0;
		virtual const char* getUserName() = 0;
		virtual const char* getDatabaseName() = 0;
		virtual const char* getClientCharSet() = 0;
		virtual int obtainInfoCode() = 0;
		virtual void* getInfo(int code) = 0;
		virtual void* setInfo(int code, void* value) = 0;
	};

	template <typename Name, typename Base>
	class IExternalResultSetBaseImpl : public Base
	{
	public:
		typedef IExternalResultSet Declaration;

		IExternalResultSetBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->dispose = &Name::cloopdisposeDispatcher;
					this->fetch = &Name::cloopfetchDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static FB_BOOLEAN CLOOP_CARG cloopfetchDispatcher(IExternalResultSet* self, IStatus* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::fetch(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static void CLOOP_CARG cloopdisposeDispatcher(IDisposable* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::dispose();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IDisposableImpl<Name, Inherit<IVersionedImpl<Name, Inherit<IExternalResultSet> > > > >
	class IExternalResultSetImpl : public IExternalResultSetBaseImpl<Name, Base>
	{
	protected:
		IExternalResultSetImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IExternalResultSetImpl()
		{
		}

		virtual FB_BOOLEAN fetch(IStatus* status) = 0;
	};

	template <typename Name, typename Base>
	class IExternalFunctionBaseImpl : public Base
	{
	public:
		typedef IExternalFunction Declaration;

		IExternalFunctionBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->dispose = &Name::cloopdisposeDispatcher;
					this->getCharSet = &Name::cloopgetCharSetDispatcher;
					this->execute = &Name::cloopexecuteDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopgetCharSetDispatcher(IExternalFunction* self, IStatus* status, IExternalContext* context, char* name, unsigned nameSize) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::getCharSet(status, context, name, nameSize);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopexecuteDispatcher(IExternalFunction* self, IStatus* status, IExternalContext* context, void* inMsg, void* outMsg) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::execute(status, context, inMsg, outMsg);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopdisposeDispatcher(IDisposable* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::dispose();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IDisposableImpl<Name, Inherit<IVersionedImpl<Name, Inherit<IExternalFunction> > > > >
	class IExternalFunctionImpl : public IExternalFunctionBaseImpl<Name, Base>
	{
	protected:
		IExternalFunctionImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IExternalFunctionImpl()
		{
		}

		virtual void getCharSet(IStatus* status, IExternalContext* context, char* name, unsigned nameSize) = 0;
		virtual void execute(IStatus* status, IExternalContext* context, void* inMsg, void* outMsg) = 0;
	};

	template <typename Name, typename Base>
	class IExternalProcedureBaseImpl : public Base
	{
	public:
		typedef IExternalProcedure Declaration;

		IExternalProcedureBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->dispose = &Name::cloopdisposeDispatcher;
					this->getCharSet = &Name::cloopgetCharSetDispatcher;
					this->open = &Name::cloopopenDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopgetCharSetDispatcher(IExternalProcedure* self, IStatus* status, IExternalContext* context, char* name, unsigned nameSize) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::getCharSet(status, context, name, nameSize);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static IExternalResultSet* CLOOP_CARG cloopopenDispatcher(IExternalProcedure* self, IStatus* status, IExternalContext* context, void* inMsg, void* outMsg) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::open(status, context, inMsg, outMsg);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IExternalResultSet*>(0);
			}
		}

		static void CLOOP_CARG cloopdisposeDispatcher(IDisposable* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::dispose();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IDisposableImpl<Name, Inherit<IVersionedImpl<Name, Inherit<IExternalProcedure> > > > >
	class IExternalProcedureImpl : public IExternalProcedureBaseImpl<Name, Base>
	{
	protected:
		IExternalProcedureImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IExternalProcedureImpl()
		{
		}

		virtual void getCharSet(IStatus* status, IExternalContext* context, char* name, unsigned nameSize) = 0;
		virtual IExternalResultSet* open(IStatus* status, IExternalContext* context, void* inMsg, void* outMsg) = 0;
	};

	template <typename Name, typename Base>
	class IExternalTriggerBaseImpl : public Base
	{
	public:
		typedef IExternalTrigger Declaration;

		IExternalTriggerBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->dispose = &Name::cloopdisposeDispatcher;
					this->getCharSet = &Name::cloopgetCharSetDispatcher;
					this->execute = &Name::cloopexecuteDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopgetCharSetDispatcher(IExternalTrigger* self, IStatus* status, IExternalContext* context, char* name, unsigned nameSize) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::getCharSet(status, context, name, nameSize);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopexecuteDispatcher(IExternalTrigger* self, IStatus* status, IExternalContext* context, unsigned action, void* oldMsg, void* newMsg) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::execute(status, context, action, oldMsg, newMsg);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopdisposeDispatcher(IDisposable* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::dispose();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IDisposableImpl<Name, Inherit<IVersionedImpl<Name, Inherit<IExternalTrigger> > > > >
	class IExternalTriggerImpl : public IExternalTriggerBaseImpl<Name, Base>
	{
	protected:
		IExternalTriggerImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IExternalTriggerImpl()
		{
		}

		virtual void getCharSet(IStatus* status, IExternalContext* context, char* name, unsigned nameSize) = 0;
		virtual void execute(IStatus* status, IExternalContext* context, unsigned action, void* oldMsg, void* newMsg) = 0;
	};

	template <typename Name, typename Base>
	class IRoutineMetadataBaseImpl : public Base
	{
	public:
		typedef IRoutineMetadata Declaration;

		IRoutineMetadataBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getPackage = &Name::cloopgetPackageDispatcher;
					this->getName = &Name::cloopgetNameDispatcher;
					this->getEntryPoint = &Name::cloopgetEntryPointDispatcher;
					this->getBody = &Name::cloopgetBodyDispatcher;
					this->getInputMetadata = &Name::cloopgetInputMetadataDispatcher;
					this->getOutputMetadata = &Name::cloopgetOutputMetadataDispatcher;
					this->getTriggerMetadata = &Name::cloopgetTriggerMetadataDispatcher;
					this->getTriggerTable = &Name::cloopgetTriggerTableDispatcher;
					this->getTriggerType = &Name::cloopgetTriggerTypeDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetPackageDispatcher(const IRoutineMetadata* self, IStatus* status) throw()
		{
			try
			{
				return static_cast<const Name*>(self)->Name::getPackage(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetNameDispatcher(const IRoutineMetadata* self, IStatus* status) throw()
		{
			try
			{
				return static_cast<const Name*>(self)->Name::getName(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetEntryPointDispatcher(const IRoutineMetadata* self, IStatus* status) throw()
		{
			try
			{
				return static_cast<const Name*>(self)->Name::getEntryPoint(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetBodyDispatcher(const IRoutineMetadata* self, IStatus* status) throw()
		{
			try
			{
				return static_cast<const Name*>(self)->Name::getBody(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<const char*>(0);
			}
		}

		static IMessageMetadata* CLOOP_CARG cloopgetInputMetadataDispatcher(const IRoutineMetadata* self, IStatus* status) throw()
		{
			try
			{
				return static_cast<const Name*>(self)->Name::getInputMetadata(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IMessageMetadata*>(0);
			}
		}

		static IMessageMetadata* CLOOP_CARG cloopgetOutputMetadataDispatcher(const IRoutineMetadata* self, IStatus* status) throw()
		{
			try
			{
				return static_cast<const Name*>(self)->Name::getOutputMetadata(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IMessageMetadata*>(0);
			}
		}

		static IMessageMetadata* CLOOP_CARG cloopgetTriggerMetadataDispatcher(const IRoutineMetadata* self, IStatus* status) throw()
		{
			try
			{
				return static_cast<const Name*>(self)->Name::getTriggerMetadata(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IMessageMetadata*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetTriggerTableDispatcher(const IRoutineMetadata* self, IStatus* status) throw()
		{
			try
			{
				return static_cast<const Name*>(self)->Name::getTriggerTable(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<const char*>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetTriggerTypeDispatcher(const IRoutineMetadata* self, IStatus* status) throw()
		{
			try
			{
				return static_cast<const Name*>(self)->Name::getTriggerType(status);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<unsigned>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IVersionedImpl<Name, Inherit<IRoutineMetadata> > >
	class IRoutineMetadataImpl : public IRoutineMetadataBaseImpl<Name, Base>
	{
	protected:
		IRoutineMetadataImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IRoutineMetadataImpl()
		{
		}

		virtual const char* getPackage(IStatus* status) const = 0;
		virtual const char* getName(IStatus* status) const = 0;
		virtual const char* getEntryPoint(IStatus* status) const = 0;
		virtual const char* getBody(IStatus* status) const = 0;
		virtual IMessageMetadata* getInputMetadata(IStatus* status) const = 0;
		virtual IMessageMetadata* getOutputMetadata(IStatus* status) const = 0;
		virtual IMessageMetadata* getTriggerMetadata(IStatus* status) const = 0;
		virtual const char* getTriggerTable(IStatus* status) const = 0;
		virtual unsigned getTriggerType(IStatus* status) const = 0;
	};

	template <typename Name, typename Base>
	class IExternalEngineBaseImpl : public Base
	{
	public:
		typedef IExternalEngine Declaration;

		IExternalEngineBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->setOwner = &Name::cloopsetOwnerDispatcher;
					this->getOwner = &Name::cloopgetOwnerDispatcher;
					this->open = &Name::cloopopenDispatcher;
					this->openAttachment = &Name::cloopopenAttachmentDispatcher;
					this->closeAttachment = &Name::cloopcloseAttachmentDispatcher;
					this->makeFunction = &Name::cloopmakeFunctionDispatcher;
					this->makeProcedure = &Name::cloopmakeProcedureDispatcher;
					this->makeTrigger = &Name::cloopmakeTriggerDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopopenDispatcher(IExternalEngine* self, IStatus* status, IExternalContext* context, char* charSet, unsigned charSetSize) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::open(status, context, charSet, charSetSize);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopopenAttachmentDispatcher(IExternalEngine* self, IStatus* status, IExternalContext* context) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::openAttachment(status, context);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopcloseAttachmentDispatcher(IExternalEngine* self, IStatus* status, IExternalContext* context) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::closeAttachment(status, context);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static IExternalFunction* CLOOP_CARG cloopmakeFunctionDispatcher(IExternalEngine* self, IStatus* status, IExternalContext* context, IRoutineMetadata* metadata, IMetadataBuilder* inBuilder, IMetadataBuilder* outBuilder) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::makeFunction(status, context, metadata, inBuilder, outBuilder);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IExternalFunction*>(0);
			}
		}

		static IExternalProcedure* CLOOP_CARG cloopmakeProcedureDispatcher(IExternalEngine* self, IStatus* status, IExternalContext* context, IRoutineMetadata* metadata, IMetadataBuilder* inBuilder, IMetadataBuilder* outBuilder) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::makeProcedure(status, context, metadata, inBuilder, outBuilder);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IExternalProcedure*>(0);
			}
		}

		static IExternalTrigger* CLOOP_CARG cloopmakeTriggerDispatcher(IExternalEngine* self, IStatus* status, IExternalContext* context, IRoutineMetadata* metadata, IMetadataBuilder* fieldsBuilder) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::makeTrigger(status, context, metadata, fieldsBuilder);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IExternalTrigger*>(0);
			}
		}

		static void CLOOP_CARG cloopsetOwnerDispatcher(IPluginBase* self, IReferenceCounted* r) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setOwner(r);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static IReferenceCounted* CLOOP_CARG cloopgetOwnerDispatcher(IPluginBase* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOwner();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IReferenceCounted*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IPluginBaseImpl<Name, Inherit<IReferenceCountedImpl<Name, Inherit<IVersionedImpl<Name, Inherit<IExternalEngine> > > > > > >
	class IExternalEngineImpl : public IExternalEngineBaseImpl<Name, Base>
	{
	protected:
		IExternalEngineImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IExternalEngineImpl()
		{
		}

		virtual void open(IStatus* status, IExternalContext* context, char* charSet, unsigned charSetSize) = 0;
		virtual void openAttachment(IStatus* status, IExternalContext* context) = 0;
		virtual void closeAttachment(IStatus* status, IExternalContext* context) = 0;
		virtual IExternalFunction* makeFunction(IStatus* status, IExternalContext* context, IRoutineMetadata* metadata, IMetadataBuilder* inBuilder, IMetadataBuilder* outBuilder) = 0;
		virtual IExternalProcedure* makeProcedure(IStatus* status, IExternalContext* context, IRoutineMetadata* metadata, IMetadataBuilder* inBuilder, IMetadataBuilder* outBuilder) = 0;
		virtual IExternalTrigger* makeTrigger(IStatus* status, IExternalContext* context, IRoutineMetadata* metadata, IMetadataBuilder* fieldsBuilder) = 0;
	};

	template <typename Name, typename Base>
	class ITimerBaseImpl : public Base
	{
	public:
		typedef ITimer Declaration;

		ITimerBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->handler = &Name::cloophandlerDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloophandlerDispatcher(ITimer* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::handler();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IReferenceCountedImpl<Name, Inherit<IVersionedImpl<Name, Inherit<ITimer> > > > >
	class ITimerImpl : public ITimerBaseImpl<Name, Base>
	{
	protected:
		ITimerImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITimerImpl()
		{
		}

		virtual void handler() = 0;
	};

	template <typename Name, typename Base>
	class ITimerControlBaseImpl : public Base
	{
	public:
		typedef ITimerControl Declaration;

		ITimerControlBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->start = &Name::cloopstartDispatcher;
					this->stop = &Name::cloopstopDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopstartDispatcher(ITimerControl* self, IStatus* status, ITimer* timer, ISC_UINT64 microSeconds) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::start(status, timer, microSeconds);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopstopDispatcher(ITimerControl* self, IStatus* status, ITimer* timer) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::stop(status, timer);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IVersionedImpl<Name, Inherit<ITimerControl> > >
	class ITimerControlImpl : public ITimerControlBaseImpl<Name, Base>
	{
	protected:
		ITimerControlImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITimerControlImpl()
		{
		}

		virtual void start(IStatus* status, ITimer* timer, ISC_UINT64 microSeconds) = 0;
		virtual void stop(IStatus* status, ITimer* timer) = 0;
	};

	template <typename Name, typename Base>
	class IVersionCallbackBaseImpl : public Base
	{
	public:
		typedef IVersionCallback Declaration;

		IVersionCallbackBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->callback = &Name::cloopcallbackDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopcallbackDispatcher(IVersionCallback* self, IStatus* status, const char* text) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::callback(status, text);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IVersionedImpl<Name, Inherit<IVersionCallback> > >
	class IVersionCallbackImpl : public IVersionCallbackBaseImpl<Name, Base>
	{
	protected:
		IVersionCallbackImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IVersionCallbackImpl()
		{
		}

		virtual void callback(IStatus* status, const char* text) = 0;
	};

	template <typename Name, typename Base>
	class IUtlBaseImpl : public Base
	{
	public:
		typedef IUtl Declaration;

		IUtlBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getFbVersion = &Name::cloopgetFbVersionDispatcher;
					this->loadBlob = &Name::clooploadBlobDispatcher;
					this->dumpBlob = &Name::cloopdumpBlobDispatcher;
					this->getPerfCounters = &Name::cloopgetPerfCountersDispatcher;
					this->executeCreateDatabase = &Name::cloopexecuteCreateDatabaseDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopgetFbVersionDispatcher(IUtl* self, IStatus* status, IAttachment* att, IVersionCallback* callback) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::getFbVersion(status, att, callback);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG clooploadBlobDispatcher(IUtl* self, IStatus* status, ISC_QUAD* blobId, IAttachment* att, ITransaction* tra, const char* file, FB_BOOLEAN txt) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::loadBlob(status, blobId, att, tra, file, txt);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopdumpBlobDispatcher(IUtl* self, IStatus* status, ISC_QUAD* blobId, IAttachment* att, ITransaction* tra, const char* file, FB_BOOLEAN txt) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::dumpBlob(status, blobId, att, tra, file, txt);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static void CLOOP_CARG cloopgetPerfCountersDispatcher(IUtl* self, IStatus* status, IAttachment* att, const char* countersSet, ISC_INT64* counters) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::getPerfCounters(status, att, countersSet, counters);
			}
			catch (...)
			{
				Policy::catchException(status);
			}
		}

		static IAttachment* CLOOP_CARG cloopexecuteCreateDatabaseDispatcher(IUtl* self, IStatus* status, unsigned stmtLength, const char* creatDBstatement, unsigned dialect, FB_BOOLEAN* stmtIsCreateDb) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::executeCreateDatabase(status, stmtLength, creatDBstatement, dialect, stmtIsCreateDb);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<IAttachment*>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IVersionedImpl<Name, Inherit<IUtl> > >
	class IUtlImpl : public IUtlBaseImpl<Name, Base>
	{
	protected:
		IUtlImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IUtlImpl()
		{
		}

		virtual void getFbVersion(IStatus* status, IAttachment* att, IVersionCallback* callback) = 0;
		virtual void loadBlob(IStatus* status, ISC_QUAD* blobId, IAttachment* att, ITransaction* tra, const char* file, FB_BOOLEAN txt) = 0;
		virtual void dumpBlob(IStatus* status, ISC_QUAD* blobId, IAttachment* att, ITransaction* tra, const char* file, FB_BOOLEAN txt) = 0;
		virtual void getPerfCounters(IStatus* status, IAttachment* att, const char* countersSet, ISC_INT64* counters) = 0;
		virtual IAttachment* executeCreateDatabase(IStatus* status, unsigned stmtLength, const char* creatDBstatement, unsigned dialect, FB_BOOLEAN* stmtIsCreateDb) = 0;
	};

	template <typename Name, typename Base>
	class ITraceConnectionBaseImpl : public Base
	{
	public:
		typedef ITraceConnection Declaration;

		ITraceConnectionBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getKind = &Name::cloopgetKindDispatcher;
					this->getProcessID = &Name::cloopgetProcessIDDispatcher;
					this->getUserName = &Name::cloopgetUserNameDispatcher;
					this->getRoleName = &Name::cloopgetRoleNameDispatcher;
					this->getCharSet = &Name::cloopgetCharSetDispatcher;
					this->getRemoteProtocol = &Name::cloopgetRemoteProtocolDispatcher;
					this->getRemoteAddress = &Name::cloopgetRemoteAddressDispatcher;
					this->getRemoteProcessID = &Name::cloopgetRemoteProcessIDDispatcher;
					this->getRemoteProcessName = &Name::cloopgetRemoteProcessNameDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static unsigned CLOOP_CARG cloopgetKindDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getKind();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static int CLOOP_CARG cloopgetProcessIDDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getProcessID();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetUserNameDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getUserName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRoleNameDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRoleName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetCharSetDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getCharSet();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRemoteProtocolDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRemoteProtocol();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRemoteAddressDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRemoteAddress();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static int CLOOP_CARG cloopgetRemoteProcessIDDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRemoteProcessID();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRemoteProcessNameDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRemoteProcessName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IVersionedImpl<Name, Inherit<ITraceConnection> > >
	class ITraceConnectionImpl : public ITraceConnectionBaseImpl<Name, Base>
	{
	protected:
		ITraceConnectionImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITraceConnectionImpl()
		{
		}

		virtual unsigned getKind() = 0;
		virtual int getProcessID() = 0;
		virtual const char* getUserName() = 0;
		virtual const char* getRoleName() = 0;
		virtual const char* getCharSet() = 0;
		virtual const char* getRemoteProtocol() = 0;
		virtual const char* getRemoteAddress() = 0;
		virtual int getRemoteProcessID() = 0;
		virtual const char* getRemoteProcessName() = 0;
	};

	template <typename Name, typename Base>
	class ITraceDatabaseConnectionBaseImpl : public Base
	{
	public:
		typedef ITraceDatabaseConnection Declaration;

		ITraceDatabaseConnectionBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getKind = &Name::cloopgetKindDispatcher;
					this->getProcessID = &Name::cloopgetProcessIDDispatcher;
					this->getUserName = &Name::cloopgetUserNameDispatcher;
					this->getRoleName = &Name::cloopgetRoleNameDispatcher;
					this->getCharSet = &Name::cloopgetCharSetDispatcher;
					this->getRemoteProtocol = &Name::cloopgetRemoteProtocolDispatcher;
					this->getRemoteAddress = &Name::cloopgetRemoteAddressDispatcher;
					this->getRemoteProcessID = &Name::cloopgetRemoteProcessIDDispatcher;
					this->getRemoteProcessName = &Name::cloopgetRemoteProcessNameDispatcher;
					this->getConnectionID = &Name::cloopgetConnectionIDDispatcher;
					this->getDatabaseName = &Name::cloopgetDatabaseNameDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static int CLOOP_CARG cloopgetConnectionIDDispatcher(ITraceDatabaseConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getConnectionID();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetDatabaseNameDispatcher(ITraceDatabaseConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getDatabaseName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetKindDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getKind();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static int CLOOP_CARG cloopgetProcessIDDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getProcessID();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetUserNameDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getUserName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRoleNameDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRoleName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetCharSetDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getCharSet();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRemoteProtocolDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRemoteProtocol();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRemoteAddressDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRemoteAddress();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static int CLOOP_CARG cloopgetRemoteProcessIDDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRemoteProcessID();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRemoteProcessNameDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRemoteProcessName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = ITraceConnectionImpl<Name, Inherit<IVersionedImpl<Name, Inherit<ITraceDatabaseConnection> > > > >
	class ITraceDatabaseConnectionImpl : public ITraceDatabaseConnectionBaseImpl<Name, Base>
	{
	protected:
		ITraceDatabaseConnectionImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITraceDatabaseConnectionImpl()
		{
		}

		virtual int getConnectionID() = 0;
		virtual const char* getDatabaseName() = 0;
	};

	template <typename Name, typename Base>
	class ITraceTransactionBaseImpl : public Base
	{
	public:
		typedef ITraceTransaction Declaration;

		ITraceTransactionBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getTransactionID = &Name::cloopgetTransactionIDDispatcher;
					this->getReadOnly = &Name::cloopgetReadOnlyDispatcher;
					this->getWait = &Name::cloopgetWaitDispatcher;
					this->getIsolation = &Name::cloopgetIsolationDispatcher;
					this->getPerf = &Name::cloopgetPerfDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static unsigned CLOOP_CARG cloopgetTransactionIDDispatcher(ITraceTransaction* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getTransactionID();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG cloopgetReadOnlyDispatcher(ITraceTransaction* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getReadOnly();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static int CLOOP_CARG cloopgetWaitDispatcher(ITraceTransaction* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getWait();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetIsolationDispatcher(ITraceTransaction* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getIsolation();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static PerformanceInfo* CLOOP_CARG cloopgetPerfDispatcher(ITraceTransaction* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPerf();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PerformanceInfo*>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IVersionedImpl<Name, Inherit<ITraceTransaction> > >
	class ITraceTransactionImpl : public ITraceTransactionBaseImpl<Name, Base>
	{
	protected:
		ITraceTransactionImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITraceTransactionImpl()
		{
		}

		virtual unsigned getTransactionID() = 0;
		virtual FB_BOOLEAN getReadOnly() = 0;
		virtual int getWait() = 0;
		virtual unsigned getIsolation() = 0;
		virtual PerformanceInfo* getPerf() = 0;
	};

	template <typename Name, typename Base>
	class ITraceParamsBaseImpl : public Base
	{
	public:
		typedef ITraceParams Declaration;

		ITraceParamsBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getCount = &Name::cloopgetCountDispatcher;
					this->getParam = &Name::cloopgetParamDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static unsigned CLOOP_CARG cloopgetCountDispatcher(ITraceParams* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getCount();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static const dsc* CLOOP_CARG cloopgetParamDispatcher(ITraceParams* self, unsigned idx) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getParam(idx);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const dsc*>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IVersionedImpl<Name, Inherit<ITraceParams> > >
	class ITraceParamsImpl : public ITraceParamsBaseImpl<Name, Base>
	{
	protected:
		ITraceParamsImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITraceParamsImpl()
		{
		}

		virtual unsigned getCount() = 0;
		virtual const dsc* getParam(unsigned idx) = 0;
	};

	template <typename Name, typename Base>
	class ITraceStatementBaseImpl : public Base
	{
	public:
		typedef ITraceStatement Declaration;

		ITraceStatementBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getStmtID = &Name::cloopgetStmtIDDispatcher;
					this->getPerf = &Name::cloopgetPerfDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static int CLOOP_CARG cloopgetStmtIDDispatcher(ITraceStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getStmtID();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PerformanceInfo* CLOOP_CARG cloopgetPerfDispatcher(ITraceStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPerf();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PerformanceInfo*>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IVersionedImpl<Name, Inherit<ITraceStatement> > >
	class ITraceStatementImpl : public ITraceStatementBaseImpl<Name, Base>
	{
	protected:
		ITraceStatementImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITraceStatementImpl()
		{
		}

		virtual int getStmtID() = 0;
		virtual PerformanceInfo* getPerf() = 0;
	};

	template <typename Name, typename Base>
	class ITraceSQLStatementBaseImpl : public Base
	{
	public:
		typedef ITraceSQLStatement Declaration;

		ITraceSQLStatementBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getStmtID = &Name::cloopgetStmtIDDispatcher;
					this->getPerf = &Name::cloopgetPerfDispatcher;
					this->getText = &Name::cloopgetTextDispatcher;
					this->getPlan = &Name::cloopgetPlanDispatcher;
					this->getInputs = &Name::cloopgetInputsDispatcher;
					this->getTextUTF8 = &Name::cloopgetTextUTF8Dispatcher;
					this->getExplainedPlan = &Name::cloopgetExplainedPlanDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetTextDispatcher(ITraceSQLStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getText();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetPlanDispatcher(ITraceSQLStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPlan();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static ITraceParams* CLOOP_CARG cloopgetInputsDispatcher(ITraceSQLStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getInputs();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ITraceParams*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetTextUTF8Dispatcher(ITraceSQLStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getTextUTF8();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetExplainedPlanDispatcher(ITraceSQLStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getExplainedPlan();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static int CLOOP_CARG cloopgetStmtIDDispatcher(ITraceStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getStmtID();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PerformanceInfo* CLOOP_CARG cloopgetPerfDispatcher(ITraceStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPerf();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PerformanceInfo*>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = ITraceStatementImpl<Name, Inherit<IVersionedImpl<Name, Inherit<ITraceSQLStatement> > > > >
	class ITraceSQLStatementImpl : public ITraceSQLStatementBaseImpl<Name, Base>
	{
	protected:
		ITraceSQLStatementImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITraceSQLStatementImpl()
		{
		}

		virtual const char* getText() = 0;
		virtual const char* getPlan() = 0;
		virtual ITraceParams* getInputs() = 0;
		virtual const char* getTextUTF8() = 0;
		virtual const char* getExplainedPlan() = 0;
	};

	template <typename Name, typename Base>
	class ITraceBLRStatementBaseImpl : public Base
	{
	public:
		typedef ITraceBLRStatement Declaration;

		ITraceBLRStatementBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getStmtID = &Name::cloopgetStmtIDDispatcher;
					this->getPerf = &Name::cloopgetPerfDispatcher;
					this->getData = &Name::cloopgetDataDispatcher;
					this->getDataLength = &Name::cloopgetDataLengthDispatcher;
					this->getText = &Name::cloopgetTextDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const unsigned char* CLOOP_CARG cloopgetDataDispatcher(ITraceBLRStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getData();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const unsigned char*>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetDataLengthDispatcher(ITraceBLRStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getDataLength();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetTextDispatcher(ITraceBLRStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getText();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static int CLOOP_CARG cloopgetStmtIDDispatcher(ITraceStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getStmtID();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PerformanceInfo* CLOOP_CARG cloopgetPerfDispatcher(ITraceStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPerf();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PerformanceInfo*>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = ITraceStatementImpl<Name, Inherit<IVersionedImpl<Name, Inherit<ITraceBLRStatement> > > > >
	class ITraceBLRStatementImpl : public ITraceBLRStatementBaseImpl<Name, Base>
	{
	protected:
		ITraceBLRStatementImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITraceBLRStatementImpl()
		{
		}

		virtual const unsigned char* getData() = 0;
		virtual unsigned getDataLength() = 0;
		virtual const char* getText() = 0;
	};

	template <typename Name, typename Base>
	class ITraceDYNRequestBaseImpl : public Base
	{
	public:
		typedef ITraceDYNRequest Declaration;

		ITraceDYNRequestBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getData = &Name::cloopgetDataDispatcher;
					this->getDataLength = &Name::cloopgetDataLengthDispatcher;
					this->getText = &Name::cloopgetTextDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const unsigned char* CLOOP_CARG cloopgetDataDispatcher(ITraceDYNRequest* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getData();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const unsigned char*>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetDataLengthDispatcher(ITraceDYNRequest* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getDataLength();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetTextDispatcher(ITraceDYNRequest* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getText();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IVersionedImpl<Name, Inherit<ITraceDYNRequest> > >
	class ITraceDYNRequestImpl : public ITraceDYNRequestBaseImpl<Name, Base>
	{
	protected:
		ITraceDYNRequestImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITraceDYNRequestImpl()
		{
		}

		virtual const unsigned char* getData() = 0;
		virtual unsigned getDataLength() = 0;
		virtual const char* getText() = 0;
	};

	template <typename Name, typename Base>
	class ITraceContextVariableBaseImpl : public Base
	{
	public:
		typedef ITraceContextVariable Declaration;

		ITraceContextVariableBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getNameSpace = &Name::cloopgetNameSpaceDispatcher;
					this->getVarName = &Name::cloopgetVarNameDispatcher;
					this->getVarValue = &Name::cloopgetVarValueDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetNameSpaceDispatcher(ITraceContextVariable* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getNameSpace();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetVarNameDispatcher(ITraceContextVariable* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getVarName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetVarValueDispatcher(ITraceContextVariable* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getVarValue();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IVersionedImpl<Name, Inherit<ITraceContextVariable> > >
	class ITraceContextVariableImpl : public ITraceContextVariableBaseImpl<Name, Base>
	{
	protected:
		ITraceContextVariableImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITraceContextVariableImpl()
		{
		}

		virtual const char* getNameSpace() = 0;
		virtual const char* getVarName() = 0;
		virtual const char* getVarValue() = 0;
	};

	template <typename Name, typename Base>
	class ITraceProcedureBaseImpl : public Base
	{
	public:
		typedef ITraceProcedure Declaration;

		ITraceProcedureBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getProcName = &Name::cloopgetProcNameDispatcher;
					this->getInputs = &Name::cloopgetInputsDispatcher;
					this->getPerf = &Name::cloopgetPerfDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetProcNameDispatcher(ITraceProcedure* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getProcName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static ITraceParams* CLOOP_CARG cloopgetInputsDispatcher(ITraceProcedure* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getInputs();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ITraceParams*>(0);
			}
		}

		static PerformanceInfo* CLOOP_CARG cloopgetPerfDispatcher(ITraceProcedure* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPerf();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PerformanceInfo*>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IVersionedImpl<Name, Inherit<ITraceProcedure> > >
	class ITraceProcedureImpl : public ITraceProcedureBaseImpl<Name, Base>
	{
	protected:
		ITraceProcedureImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITraceProcedureImpl()
		{
		}

		virtual const char* getProcName() = 0;
		virtual ITraceParams* getInputs() = 0;
		virtual PerformanceInfo* getPerf() = 0;
	};

	template <typename Name, typename Base>
	class ITraceFunctionBaseImpl : public Base
	{
	public:
		typedef ITraceFunction Declaration;

		ITraceFunctionBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getFuncName = &Name::cloopgetFuncNameDispatcher;
					this->getInputs = &Name::cloopgetInputsDispatcher;
					this->getResult = &Name::cloopgetResultDispatcher;
					this->getPerf = &Name::cloopgetPerfDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetFuncNameDispatcher(ITraceFunction* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getFuncName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static ITraceParams* CLOOP_CARG cloopgetInputsDispatcher(ITraceFunction* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getInputs();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ITraceParams*>(0);
			}
		}

		static ITraceParams* CLOOP_CARG cloopgetResultDispatcher(ITraceFunction* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getResult();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ITraceParams*>(0);
			}
		}

		static PerformanceInfo* CLOOP_CARG cloopgetPerfDispatcher(ITraceFunction* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPerf();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PerformanceInfo*>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IVersionedImpl<Name, Inherit<ITraceFunction> > >
	class ITraceFunctionImpl : public ITraceFunctionBaseImpl<Name, Base>
	{
	protected:
		ITraceFunctionImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITraceFunctionImpl()
		{
		}

		virtual const char* getFuncName() = 0;
		virtual ITraceParams* getInputs() = 0;
		virtual ITraceParams* getResult() = 0;
		virtual PerformanceInfo* getPerf() = 0;
	};

	template <typename Name, typename Base>
	class ITraceTriggerBaseImpl : public Base
	{
	public:
		typedef ITraceTrigger Declaration;

		ITraceTriggerBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getTriggerName = &Name::cloopgetTriggerNameDispatcher;
					this->getRelationName = &Name::cloopgetRelationNameDispatcher;
					this->getAction = &Name::cloopgetActionDispatcher;
					this->getWhich = &Name::cloopgetWhichDispatcher;
					this->getPerf = &Name::cloopgetPerfDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetTriggerNameDispatcher(ITraceTrigger* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getTriggerName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRelationNameDispatcher(ITraceTrigger* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRelationName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static int CLOOP_CARG cloopgetActionDispatcher(ITraceTrigger* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getAction();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static int CLOOP_CARG cloopgetWhichDispatcher(ITraceTrigger* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getWhich();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PerformanceInfo* CLOOP_CARG cloopgetPerfDispatcher(ITraceTrigger* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPerf();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PerformanceInfo*>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IVersionedImpl<Name, Inherit<ITraceTrigger> > >
	class ITraceTriggerImpl : public ITraceTriggerBaseImpl<Name, Base>
	{
	protected:
		ITraceTriggerImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITraceTriggerImpl()
		{
		}

		virtual const char* getTriggerName() = 0;
		virtual const char* getRelationName() = 0;
		virtual int getAction() = 0;
		virtual int getWhich() = 0;
		virtual PerformanceInfo* getPerf() = 0;
	};

	template <typename Name, typename Base>
	class ITraceServiceConnectionBaseImpl : public Base
	{
	public:
		typedef ITraceServiceConnection Declaration;

		ITraceServiceConnectionBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getKind = &Name::cloopgetKindDispatcher;
					this->getProcessID = &Name::cloopgetProcessIDDispatcher;
					this->getUserName = &Name::cloopgetUserNameDispatcher;
					this->getRoleName = &Name::cloopgetRoleNameDispatcher;
					this->getCharSet = &Name::cloopgetCharSetDispatcher;
					this->getRemoteProtocol = &Name::cloopgetRemoteProtocolDispatcher;
					this->getRemoteAddress = &Name::cloopgetRemoteAddressDispatcher;
					this->getRemoteProcessID = &Name::cloopgetRemoteProcessIDDispatcher;
					this->getRemoteProcessName = &Name::cloopgetRemoteProcessNameDispatcher;
					this->getServiceID = &Name::cloopgetServiceIDDispatcher;
					this->getServiceMgr = &Name::cloopgetServiceMgrDispatcher;
					this->getServiceName = &Name::cloopgetServiceNameDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void* CLOOP_CARG cloopgetServiceIDDispatcher(ITraceServiceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getServiceID();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<void*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetServiceMgrDispatcher(ITraceServiceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getServiceMgr();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetServiceNameDispatcher(ITraceServiceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getServiceName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetKindDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getKind();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static int CLOOP_CARG cloopgetProcessIDDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getProcessID();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetUserNameDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getUserName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRoleNameDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRoleName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetCharSetDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getCharSet();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRemoteProtocolDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRemoteProtocol();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRemoteAddressDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRemoteAddress();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static int CLOOP_CARG cloopgetRemoteProcessIDDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRemoteProcessID();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRemoteProcessNameDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRemoteProcessName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = ITraceConnectionImpl<Name, Inherit<IVersionedImpl<Name, Inherit<ITraceServiceConnection> > > > >
	class ITraceServiceConnectionImpl : public ITraceServiceConnectionBaseImpl<Name, Base>
	{
	protected:
		ITraceServiceConnectionImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITraceServiceConnectionImpl()
		{
		}

		virtual void* getServiceID() = 0;
		virtual const char* getServiceMgr() = 0;
		virtual const char* getServiceName() = 0;
	};

	template <typename Name, typename Base>
	class ITraceStatusVectorBaseImpl : public Base
	{
	public:
		typedef ITraceStatusVector Declaration;

		ITraceStatusVectorBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->hasError = &Name::cloophasErrorDispatcher;
					this->hasWarning = &Name::cloophasWarningDispatcher;
					this->getStatus = &Name::cloopgetStatusDispatcher;
					this->getText = &Name::cloopgetTextDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static FB_BOOLEAN CLOOP_CARG cloophasErrorDispatcher(ITraceStatusVector* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::hasError();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG cloophasWarningDispatcher(ITraceStatusVector* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::hasWarning();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static const intptr_t* CLOOP_CARG cloopgetStatusDispatcher(ITraceStatusVector* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getStatus();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const intptr_t*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetTextDispatcher(ITraceStatusVector* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getText();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IVersionedImpl<Name, Inherit<ITraceStatusVector> > >
	class ITraceStatusVectorImpl : public ITraceStatusVectorBaseImpl<Name, Base>
	{
	protected:
		ITraceStatusVectorImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITraceStatusVectorImpl()
		{
		}

		virtual FB_BOOLEAN hasError() = 0;
		virtual FB_BOOLEAN hasWarning() = 0;
		virtual const intptr_t* getStatus() = 0;
		virtual const char* getText() = 0;
	};

	template <typename Name, typename Base>
	class ITraceSweepInfoBaseImpl : public Base
	{
	public:
		typedef ITraceSweepInfo Declaration;

		ITraceSweepInfoBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getOIT = &Name::cloopgetOITDispatcher;
					this->getOST = &Name::cloopgetOSTDispatcher;
					this->getOAT = &Name::cloopgetOATDispatcher;
					this->getNext = &Name::cloopgetNextDispatcher;
					this->getPerf = &Name::cloopgetPerfDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static ISC_UINT64 CLOOP_CARG cloopgetOITDispatcher(ITraceSweepInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOIT();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ISC_UINT64>(0);
			}
		}

		static ISC_UINT64 CLOOP_CARG cloopgetOSTDispatcher(ITraceSweepInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOST();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ISC_UINT64>(0);
			}
		}

		static ISC_UINT64 CLOOP_CARG cloopgetOATDispatcher(ITraceSweepInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOAT();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ISC_UINT64>(0);
			}
		}

		static ISC_UINT64 CLOOP_CARG cloopgetNextDispatcher(ITraceSweepInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getNext();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ISC_UINT64>(0);
			}
		}

		static PerformanceInfo* CLOOP_CARG cloopgetPerfDispatcher(ITraceSweepInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPerf();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<PerformanceInfo*>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IVersionedImpl<Name, Inherit<ITraceSweepInfo> > >
	class ITraceSweepInfoImpl : public ITraceSweepInfoBaseImpl<Name, Base>
	{
	protected:
		ITraceSweepInfoImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITraceSweepInfoImpl()
		{
		}

		virtual ISC_UINT64 getOIT() = 0;
		virtual ISC_UINT64 getOST() = 0;
		virtual ISC_UINT64 getOAT() = 0;
		virtual ISC_UINT64 getNext() = 0;
		virtual PerformanceInfo* getPerf() = 0;
	};

	template <typename Name, typename Base>
	class ITraceLogWriterBaseImpl : public Base
	{
	public:
		typedef ITraceLogWriter Declaration;

		ITraceLogWriterBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->write = &Name::cloopwriteDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static unsigned CLOOP_CARG cloopwriteDispatcher(ITraceLogWriter* self, const void* buf, unsigned size) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::write(buf, size);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IReferenceCountedImpl<Name, Inherit<IVersionedImpl<Name, Inherit<ITraceLogWriter> > > > >
	class ITraceLogWriterImpl : public ITraceLogWriterBaseImpl<Name, Base>
	{
	protected:
		ITraceLogWriterImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITraceLogWriterImpl()
		{
		}

		virtual unsigned write(const void* buf, unsigned size) = 0;
	};

	template <typename Name, typename Base>
	class ITraceInitInfoBaseImpl : public Base
	{
	public:
		typedef ITraceInitInfo Declaration;

		ITraceInitInfoBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->getConfigText = &Name::cloopgetConfigTextDispatcher;
					this->getTraceSessionID = &Name::cloopgetTraceSessionIDDispatcher;
					this->getTraceSessionName = &Name::cloopgetTraceSessionNameDispatcher;
					this->getFirebirdRootDirectory = &Name::cloopgetFirebirdRootDirectoryDispatcher;
					this->getDatabaseName = &Name::cloopgetDatabaseNameDispatcher;
					this->getConnection = &Name::cloopgetConnectionDispatcher;
					this->getLogWriter = &Name::cloopgetLogWriterDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetConfigTextDispatcher(ITraceInitInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getConfigText();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static int CLOOP_CARG cloopgetTraceSessionIDDispatcher(ITraceInitInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getTraceSessionID();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetTraceSessionNameDispatcher(ITraceInitInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getTraceSessionName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetFirebirdRootDirectoryDispatcher(ITraceInitInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getFirebirdRootDirectory();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetDatabaseNameDispatcher(ITraceInitInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getDatabaseName();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static ITraceDatabaseConnection* CLOOP_CARG cloopgetConnectionDispatcher(ITraceInitInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getConnection();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ITraceDatabaseConnection*>(0);
			}
		}

		static ITraceLogWriter* CLOOP_CARG cloopgetLogWriterDispatcher(ITraceInitInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getLogWriter();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ITraceLogWriter*>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IVersionedImpl<Name, Inherit<ITraceInitInfo> > >
	class ITraceInitInfoImpl : public ITraceInitInfoBaseImpl<Name, Base>
	{
	protected:
		ITraceInitInfoImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITraceInitInfoImpl()
		{
		}

		virtual const char* getConfigText() = 0;
		virtual int getTraceSessionID() = 0;
		virtual const char* getTraceSessionName() = 0;
		virtual const char* getFirebirdRootDirectory() = 0;
		virtual const char* getDatabaseName() = 0;
		virtual ITraceDatabaseConnection* getConnection() = 0;
		virtual ITraceLogWriter* getLogWriter() = 0;
	};

	template <typename Name, typename Base>
	class ITracePluginBaseImpl : public Base
	{
	public:
		typedef ITracePlugin Declaration;

		ITracePluginBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->trace_get_error = &Name::clooptrace_get_errorDispatcher;
					this->trace_attach = &Name::clooptrace_attachDispatcher;
					this->trace_detach = &Name::clooptrace_detachDispatcher;
					this->trace_transaction_start = &Name::clooptrace_transaction_startDispatcher;
					this->trace_transaction_end = &Name::clooptrace_transaction_endDispatcher;
					this->trace_proc_execute = &Name::clooptrace_proc_executeDispatcher;
					this->trace_trigger_execute = &Name::clooptrace_trigger_executeDispatcher;
					this->trace_set_context = &Name::clooptrace_set_contextDispatcher;
					this->trace_dsql_prepare = &Name::clooptrace_dsql_prepareDispatcher;
					this->trace_dsql_free = &Name::clooptrace_dsql_freeDispatcher;
					this->trace_dsql_execute = &Name::clooptrace_dsql_executeDispatcher;
					this->trace_blr_compile = &Name::clooptrace_blr_compileDispatcher;
					this->trace_blr_execute = &Name::clooptrace_blr_executeDispatcher;
					this->trace_dyn_execute = &Name::clooptrace_dyn_executeDispatcher;
					this->trace_service_attach = &Name::clooptrace_service_attachDispatcher;
					this->trace_service_start = &Name::clooptrace_service_startDispatcher;
					this->trace_service_query = &Name::clooptrace_service_queryDispatcher;
					this->trace_service_detach = &Name::clooptrace_service_detachDispatcher;
					this->trace_event_error = &Name::clooptrace_event_errorDispatcher;
					this->trace_event_sweep = &Name::clooptrace_event_sweepDispatcher;
					this->trace_func_execute = &Name::clooptrace_func_executeDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG clooptrace_get_errorDispatcher(ITracePlugin* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_get_error();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_attachDispatcher(ITracePlugin* self, ITraceDatabaseConnection* connection, FB_BOOLEAN create_db, unsigned att_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_attach(connection, create_db, att_result);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_detachDispatcher(ITracePlugin* self, ITraceDatabaseConnection* connection, FB_BOOLEAN drop_db) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_detach(connection, drop_db);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_transaction_startDispatcher(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, unsigned tpb_length, const unsigned char* tpb, unsigned tra_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_transaction_start(connection, transaction, tpb_length, tpb, tra_result);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_transaction_endDispatcher(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, FB_BOOLEAN commit, FB_BOOLEAN retain_context, unsigned tra_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_transaction_end(connection, transaction, commit, retain_context, tra_result);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_proc_executeDispatcher(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceProcedure* procedure, FB_BOOLEAN started, unsigned proc_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_proc_execute(connection, transaction, procedure, started, proc_result);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_trigger_executeDispatcher(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceTrigger* trigger, FB_BOOLEAN started, unsigned trig_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_trigger_execute(connection, transaction, trigger, started, trig_result);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_set_contextDispatcher(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceContextVariable* variable) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_set_context(connection, transaction, variable);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_dsql_prepareDispatcher(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceSQLStatement* statement, ISC_INT64 time_millis, unsigned req_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_dsql_prepare(connection, transaction, statement, time_millis, req_result);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_dsql_freeDispatcher(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceSQLStatement* statement, unsigned option) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_dsql_free(connection, statement, option);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_dsql_executeDispatcher(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceSQLStatement* statement, FB_BOOLEAN started, unsigned req_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_dsql_execute(connection, transaction, statement, started, req_result);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_blr_compileDispatcher(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceBLRStatement* statement, ISC_INT64 time_millis, unsigned req_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_blr_compile(connection, transaction, statement, time_millis, req_result);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_blr_executeDispatcher(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceBLRStatement* statement, unsigned req_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_blr_execute(connection, transaction, statement, req_result);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_dyn_executeDispatcher(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceDYNRequest* request, ISC_INT64 time_millis, unsigned req_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_dyn_execute(connection, transaction, request, time_millis, req_result);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_service_attachDispatcher(ITracePlugin* self, ITraceServiceConnection* service, unsigned att_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_service_attach(service, att_result);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_service_startDispatcher(ITracePlugin* self, ITraceServiceConnection* service, unsigned switches_length, const char* switches, unsigned start_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_service_start(service, switches_length, switches, start_result);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_service_queryDispatcher(ITracePlugin* self, ITraceServiceConnection* service, unsigned send_item_length, const unsigned char* send_items, unsigned recv_item_length, const unsigned char* recv_items, unsigned query_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_service_query(service, send_item_length, send_items, recv_item_length, recv_items, query_result);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_service_detachDispatcher(ITracePlugin* self, ITraceServiceConnection* service, unsigned detach_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_service_detach(service, detach_result);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_event_errorDispatcher(ITracePlugin* self, ITraceConnection* connection, ITraceStatusVector* status, const char* function) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_event_error(connection, status, function);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_event_sweepDispatcher(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceSweepInfo* sweep, unsigned sweep_state) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_event_sweep(connection, sweep, sweep_state);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_func_executeDispatcher(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceFunction* function, FB_BOOLEAN started, unsigned func_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_func_execute(connection, transaction, function, started, func_result);
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IReferenceCountedImpl<Name, Inherit<IVersionedImpl<Name, Inherit<ITracePlugin> > > > >
	class ITracePluginImpl : public ITracePluginBaseImpl<Name, Base>
	{
	protected:
		ITracePluginImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITracePluginImpl()
		{
		}

		virtual const char* trace_get_error() = 0;
		virtual FB_BOOLEAN trace_attach(ITraceDatabaseConnection* connection, FB_BOOLEAN create_db, unsigned att_result) = 0;
		virtual FB_BOOLEAN trace_detach(ITraceDatabaseConnection* connection, FB_BOOLEAN drop_db) = 0;
		virtual FB_BOOLEAN trace_transaction_start(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, unsigned tpb_length, const unsigned char* tpb, unsigned tra_result) = 0;
		virtual FB_BOOLEAN trace_transaction_end(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, FB_BOOLEAN commit, FB_BOOLEAN retain_context, unsigned tra_result) = 0;
		virtual FB_BOOLEAN trace_proc_execute(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceProcedure* procedure, FB_BOOLEAN started, unsigned proc_result) = 0;
		virtual FB_BOOLEAN trace_trigger_execute(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceTrigger* trigger, FB_BOOLEAN started, unsigned trig_result) = 0;
		virtual FB_BOOLEAN trace_set_context(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceContextVariable* variable) = 0;
		virtual FB_BOOLEAN trace_dsql_prepare(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceSQLStatement* statement, ISC_INT64 time_millis, unsigned req_result) = 0;
		virtual FB_BOOLEAN trace_dsql_free(ITraceDatabaseConnection* connection, ITraceSQLStatement* statement, unsigned option) = 0;
		virtual FB_BOOLEAN trace_dsql_execute(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceSQLStatement* statement, FB_BOOLEAN started, unsigned req_result) = 0;
		virtual FB_BOOLEAN trace_blr_compile(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceBLRStatement* statement, ISC_INT64 time_millis, unsigned req_result) = 0;
		virtual FB_BOOLEAN trace_blr_execute(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceBLRStatement* statement, unsigned req_result) = 0;
		virtual FB_BOOLEAN trace_dyn_execute(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceDYNRequest* request, ISC_INT64 time_millis, unsigned req_result) = 0;
		virtual FB_BOOLEAN trace_service_attach(ITraceServiceConnection* service, unsigned att_result) = 0;
		virtual FB_BOOLEAN trace_service_start(ITraceServiceConnection* service, unsigned switches_length, const char* switches, unsigned start_result) = 0;
		virtual FB_BOOLEAN trace_service_query(ITraceServiceConnection* service, unsigned send_item_length, const unsigned char* send_items, unsigned recv_item_length, const unsigned char* recv_items, unsigned query_result) = 0;
		virtual FB_BOOLEAN trace_service_detach(ITraceServiceConnection* service, unsigned detach_result) = 0;
		virtual FB_BOOLEAN trace_event_error(ITraceConnection* connection, ITraceStatusVector* status, const char* function) = 0;
		virtual FB_BOOLEAN trace_event_sweep(ITraceDatabaseConnection* connection, ITraceSweepInfo* sweep, unsigned sweep_state) = 0;
		virtual FB_BOOLEAN trace_func_execute(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceFunction* function, FB_BOOLEAN started, unsigned func_result) = 0;
	};

	template <typename Name, typename Base>
	class ITraceFactoryBaseImpl : public Base
	{
	public:
		typedef ITraceFactory Declaration;

		ITraceFactoryBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getModule = &Name::cloopgetModuleDispatcher;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->setOwner = &Name::cloopsetOwnerDispatcher;
					this->getOwner = &Name::cloopgetOwnerDispatcher;
					this->trace_needs = &Name::clooptrace_needsDispatcher;
					this->trace_create = &Name::clooptrace_createDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static ISC_UINT64 CLOOP_CARG clooptrace_needsDispatcher(ITraceFactory* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_needs();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<ISC_UINT64>(0);
			}
		}

		static ITracePlugin* CLOOP_CARG clooptrace_createDispatcher(ITraceFactory* self, IStatus* status, ITraceInitInfo* init_info) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_create(status, init_info);
			}
			catch (...)
			{
				Policy::catchException(status);
				return static_cast<ITracePlugin*>(0);
			}
		}

		static void CLOOP_CARG cloopsetOwnerDispatcher(IPluginBase* self, IReferenceCounted* r) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setOwner(r);
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static IReferenceCounted* CLOOP_CARG cloopgetOwnerDispatcher(IPluginBase* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOwner();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IReferenceCounted*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				Policy::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<int>(0);
			}
		}

		static IPluginModule* CLOOP_CARG cloopgetModuleDispatcher(IVersioned* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getModule();
			}
			catch (...)
			{
				Policy::catchException(0);
				return static_cast<IPluginModule*>(0);
			}
		}
	};

	template <typename Name, typename Base = IPluginBaseImpl<Name, Inherit<IReferenceCountedImpl<Name, Inherit<IVersionedImpl<Name, Inherit<ITraceFactory> > > > > > >
	class ITraceFactoryImpl : public ITraceFactoryBaseImpl<Name, Base>
	{
	protected:
		ITraceFactoryImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITraceFactoryImpl()
		{
		}

		virtual ISC_UINT64 trace_needs() = 0;
		virtual ITracePlugin* trace_create(IStatus* status, ITraceInitInfo* init_info) = 0;
	};
};

template <typename Policy> const unsigned FirebirdApi<Policy>::IStatus::FB_HAS_WARNINGS;
template <typename Policy> const unsigned FirebirdApi<Policy>::IStatus::FB_HAS_ERRORS;
template <typename Policy> const int FirebirdApi<Policy>::IStatus::FB_ERROR;
template <typename Policy> const int FirebirdApi<Policy>::IStatus::FB_OK;
template <typename Policy> const int FirebirdApi<Policy>::IStatus::FB_EOF;
template <typename Policy> const int FirebirdApi<Policy>::IStatus::FB_SEGMENT;

template <typename Policy> const unsigned FirebirdApi<Policy>::IPluginManager::Provider;
template <typename Policy> const unsigned FirebirdApi<Policy>::IPluginManager::FirstNonLibPlugin;
template <typename Policy> const unsigned FirebirdApi<Policy>::IPluginManager::AuthServer;
template <typename Policy> const unsigned FirebirdApi<Policy>::IPluginManager::AuthClient;
template <typename Policy> const unsigned FirebirdApi<Policy>::IPluginManager::AuthUserManagement;
template <typename Policy> const unsigned FirebirdApi<Policy>::IPluginManager::ExternalEngine;
template <typename Policy> const unsigned FirebirdApi<Policy>::IPluginManager::Trace;
template <typename Policy> const unsigned FirebirdApi<Policy>::IPluginManager::WireCrypt;
template <typename Policy> const unsigned FirebirdApi<Policy>::IPluginManager::DbCrypt;
template <typename Policy> const unsigned FirebirdApi<Policy>::IPluginManager::KeyHolder;
template <typename Policy> const unsigned FirebirdApi<Policy>::IPluginManager::MaxType;

template <typename Policy> const unsigned FirebirdApi<Policy>::IConfigManager::FB_DIR_BIN;
template <typename Policy> const unsigned FirebirdApi<Policy>::IConfigManager::FB_DIR_SBIN;
template <typename Policy> const unsigned FirebirdApi<Policy>::IConfigManager::FB_DIR_CONF;
template <typename Policy> const unsigned FirebirdApi<Policy>::IConfigManager::FB_DIR_LIB;
template <typename Policy> const unsigned FirebirdApi<Policy>::IConfigManager::FB_DIR_INC;
template <typename Policy> const unsigned FirebirdApi<Policy>::IConfigManager::FB_DIR_DOC;
template <typename Policy> const unsigned FirebirdApi<Policy>::IConfigManager::FB_DIR_UDF;
template <typename Policy> const unsigned FirebirdApi<Policy>::IConfigManager::FB_DIR_SAMPLE;
template <typename Policy> const unsigned FirebirdApi<Policy>::IConfigManager::FB_DIR_SAMPLEDB;
template <typename Policy> const unsigned FirebirdApi<Policy>::IConfigManager::FB_DIR_HELP;
template <typename Policy> const unsigned FirebirdApi<Policy>::IConfigManager::FB_DIR_INTL;
template <typename Policy> const unsigned FirebirdApi<Policy>::IConfigManager::FB_DIR_MISC;
template <typename Policy> const unsigned FirebirdApi<Policy>::IConfigManager::FB_DIR_SECDB;
template <typename Policy> const unsigned FirebirdApi<Policy>::IConfigManager::FB_DIR_MSG;
template <typename Policy> const unsigned FirebirdApi<Policy>::IConfigManager::FB_DIR_LOG;
template <typename Policy> const unsigned FirebirdApi<Policy>::IConfigManager::FB_DIR_GUARD;
template <typename Policy> const unsigned FirebirdApi<Policy>::IConfigManager::FB_DIR_PLUGINS;
template <typename Policy> const unsigned FirebirdApi<Policy>::IConfigManager::FB_DIRCOUNT;

template <typename Policy> const unsigned FirebirdApi<Policy>::IStatement::PREPARE_PREFETCH_NONE;
template <typename Policy> const unsigned FirebirdApi<Policy>::IStatement::PREPARE_PREFETCH_TYPE;
template <typename Policy> const unsigned FirebirdApi<Policy>::IStatement::PREPARE_PREFETCH_INPUT_PARAMETERS;
template <typename Policy> const unsigned FirebirdApi<Policy>::IStatement::PREPARE_PREFETCH_OUTPUT_PARAMETERS;
template <typename Policy> const unsigned FirebirdApi<Policy>::IStatement::PREPARE_PREFETCH_LEGACY_PLAN;
template <typename Policy> const unsigned FirebirdApi<Policy>::IStatement::PREPARE_PREFETCH_DETAILED_PLAN;
template <typename Policy> const unsigned FirebirdApi<Policy>::IStatement::PREPARE_PREFETCH_AFFECTED_RECORDS;
template <typename Policy> const unsigned FirebirdApi<Policy>::IStatement::PREPARE_PREFETCH_FLAGS;
template <typename Policy> const unsigned FirebirdApi<Policy>::IStatement::PREPARE_PREFETCH_METADATA;
template <typename Policy> const unsigned FirebirdApi<Policy>::IStatement::PREPARE_PREFETCH_ALL;
template <typename Policy> const unsigned FirebirdApi<Policy>::IStatement::FLAG_HAS_CURSOR;
template <typename Policy> const unsigned FirebirdApi<Policy>::IStatement::FLAG_REPEAT_EXECUTE;

template <typename Policy> const int FirebirdApi<Policy>::IAuth::AUTH_FAILED;
template <typename Policy> const int FirebirdApi<Policy>::IAuth::AUTH_SUCCESS;
template <typename Policy> const int FirebirdApi<Policy>::IAuth::AUTH_MORE_DATA;
template <typename Policy> const int FirebirdApi<Policy>::IAuth::AUTH_CONTINUE;

template <typename Policy> const unsigned FirebirdApi<Policy>::IExternalTrigger::TYPE_BEFORE;
template <typename Policy> const unsigned FirebirdApi<Policy>::IExternalTrigger::TYPE_AFTER;
template <typename Policy> const unsigned FirebirdApi<Policy>::IExternalTrigger::TYPE_DATABASE;
template <typename Policy> const unsigned FirebirdApi<Policy>::IExternalTrigger::ACTION_INSERT;
template <typename Policy> const unsigned FirebirdApi<Policy>::IExternalTrigger::ACTION_UPDATE;
template <typename Policy> const unsigned FirebirdApi<Policy>::IExternalTrigger::ACTION_DELETE;
template <typename Policy> const unsigned FirebirdApi<Policy>::IExternalTrigger::ACTION_CONNECT;
template <typename Policy> const unsigned FirebirdApi<Policy>::IExternalTrigger::ACTION_DISCONNECT;
template <typename Policy> const unsigned FirebirdApi<Policy>::IExternalTrigger::ACTION_TRANS_START;
template <typename Policy> const unsigned FirebirdApi<Policy>::IExternalTrigger::ACTION_TRANS_COMMIT;
template <typename Policy> const unsigned FirebirdApi<Policy>::IExternalTrigger::ACTION_TRANS_ROLLBACK;
template <typename Policy> const unsigned FirebirdApi<Policy>::IExternalTrigger::ACTION_DDL;

template <typename Policy> const unsigned FirebirdApi<Policy>::ITraceConnection::TRACE_CONNECTION_DATABASE;
template <typename Policy> const unsigned FirebirdApi<Policy>::ITraceConnection::TRACE_CONNECTION_SERVICE;

template <typename Policy> const unsigned FirebirdApi<Policy>::ITraceTransaction::TRA_ISO_CONSISTENCY;
template <typename Policy> const unsigned FirebirdApi<Policy>::ITraceTransaction::TRA_ISO_CONCURRENCY;
template <typename Policy> const unsigned FirebirdApi<Policy>::ITraceTransaction::TRA_ISO_READ_COMMITTED_RECVER;
template <typename Policy> const unsigned FirebirdApi<Policy>::ITraceTransaction::TRA_ISO_READ_COMMITTED_NORECVER;

template <typename Policy> const unsigned FirebirdApi<Policy>::ITraceTrigger::TRACE_ALL;
template <typename Policy> const unsigned FirebirdApi<Policy>::ITraceTrigger::TRACE_BEFORE;
template <typename Policy> const unsigned FirebirdApi<Policy>::ITraceTrigger::TRACE_AFTER;

template <typename Policy> const unsigned FirebirdApi<Policy>::ITracePlugin::TRACE_RESULT_SUCCESS;
template <typename Policy> const unsigned FirebirdApi<Policy>::ITracePlugin::TRACE_RESULT_FAILED;
template <typename Policy> const unsigned FirebirdApi<Policy>::ITracePlugin::TRACE_RESULT_UNAUTHORIZED;
template <typename Policy> const unsigned FirebirdApi<Policy>::ITracePlugin::SWEEP_STATE_STARTED;
template <typename Policy> const unsigned FirebirdApi<Policy>::ITracePlugin::SWEEP_STATE_FINISHED;
template <typename Policy> const unsigned FirebirdApi<Policy>::ITracePlugin::SWEEP_STATE_FAILED;
template <typename Policy> const unsigned FirebirdApi<Policy>::ITracePlugin::SWEEP_STATE_PROGRESS;

template <typename Policy> const unsigned FirebirdApi<Policy>::ITraceFactory::TRACE_EVENT_ATTACH;
template <typename Policy> const unsigned FirebirdApi<Policy>::ITraceFactory::TRACE_EVENT_DETACH;
template <typename Policy> const unsigned FirebirdApi<Policy>::ITraceFactory::TRACE_EVENT_TRANSACTION_START;
template <typename Policy> const unsigned FirebirdApi<Policy>::ITraceFactory::TRACE_EVENT_TRANSACTION_END;
template <typename Policy> const unsigned FirebirdApi<Policy>::ITraceFactory::TRACE_EVENT_SET_CONTEXT;
template <typename Policy> const unsigned FirebirdApi<Policy>::ITraceFactory::TRACE_EVENT_PROC_EXECUTE;
template <typename Policy> const unsigned FirebirdApi<Policy>::ITraceFactory::TRACE_EVENT_TRIGGER_EXECUTE;
template <typename Policy> const unsigned FirebirdApi<Policy>::ITraceFactory::TRACE_EVENT_DSQL_PREPARE;
template <typename Policy> const unsigned FirebirdApi<Policy>::ITraceFactory::TRACE_EVENT_DSQL_FREE;
template <typename Policy> const unsigned FirebirdApi<Policy>::ITraceFactory::TRACE_EVENT_DSQL_EXECUTE;
template <typename Policy> const unsigned FirebirdApi<Policy>::ITraceFactory::TRACE_EVENT_BLR_COMPILE;
template <typename Policy> const unsigned FirebirdApi<Policy>::ITraceFactory::TRACE_EVENT_BLR_EXECUTE;
template <typename Policy> const unsigned FirebirdApi<Policy>::ITraceFactory::TRACE_EVENT_DYN_EXECUTE;
template <typename Policy> const unsigned FirebirdApi<Policy>::ITraceFactory::TRACE_EVENT_SERVICE_ATTACH;
template <typename Policy> const unsigned FirebirdApi<Policy>::ITraceFactory::TRACE_EVENT_SERVICE_START;
template <typename Policy> const unsigned FirebirdApi<Policy>::ITraceFactory::TRACE_EVENT_SERVICE_QUERY;
template <typename Policy> const unsigned FirebirdApi<Policy>::ITraceFactory::TRACE_EVENT_SERVICE_DETACH;
template <typename Policy> const unsigned FirebirdApi<Policy>::ITraceFactory::TRACE_EVENT_ERROR;
template <typename Policy> const unsigned FirebirdApi<Policy>::ITraceFactory::TRACE_EVENT_SWEEP;
template <typename Policy> const unsigned FirebirdApi<Policy>::ITraceFactory::TRACE_EVENT_FUNC_EXECUTE;
template <typename Policy> const unsigned FirebirdApi<Policy>::ITraceFactory::TRACE_EVENT_MAX;


#endif	// IDL_FB_INTERFACES_H
